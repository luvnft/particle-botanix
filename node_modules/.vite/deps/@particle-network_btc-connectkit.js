import {
  require_crypto
} from "./chunk-JOTEBLDP.js";
import {
  require_hash,
  require_inherits_browser,
  require_minimalistic_assert
} from "./chunk-DED2FP65.js";
import {
  require_bs58,
  require_safe_buffer
} from "./chunk-2Y4ARUIX.js";
import {
  require_buffer
} from "./chunk-R246B23A.js";
import "./chunk-MYBMDLPB.js";
import {
  require_buffer as require_buffer2
} from "./chunk-OXM6T7ON.js";
import {
  AbiConstructorNotFoundError,
  AbiConstructorParamsNotFoundError,
  AbiDecodingDataSizeTooSmallError,
  AbiDecodingZeroDataError,
  AbiEventNotFoundError,
  AbiEventSignatureEmptyTopicsError,
  AbiEventSignatureNotFoundError,
  BaseError,
  BytesSizeMismatchError,
  CallExecutionError,
  ChainDisconnectedError,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  Hash,
  HttpRequestError,
  InternalRpcError,
  InvalidAddressError,
  InvalidInputRpcError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  InvalidSerializableTransactionError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  ParseRpcError,
  PositionOutOfBoundsError,
  ProviderDisconnectedError,
  RawContractError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TimeoutError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  TransactionRejectedRpcError,
  UnauthorizedProviderError,
  UnknownNodeError,
  UnknownRpcError,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  addressResolverAbi,
  assertRequest,
  bytesToHex,
  call,
  concat,
  concatHex,
  createBatchScheduler,
  createView,
  decodeAbiParameters,
  decodeFunctionResult,
  defineFormatter,
  encodeAbiParameters,
  encodeFunctionData,
  exists,
  extract,
  formatAbiItem,
  formatEther,
  formatGwei,
  formatTransactionRequest,
  formatUnits,
  getAbiItem,
  getChainContractAddress,
  getNodeError,
  hexToBigInt,
  hexToNumber,
  isAddress,
  isHex,
  keccak256,
  multicall3Abi,
  numberToHex,
  output,
  panicReasons,
  parseAccount,
  prettyPrint,
  rotr,
  size,
  stringToBytes,
  stringify,
  textResolverAbi,
  toBytes,
  toBytes2,
  toEventSelector,
  toHex,
  trim,
  universalResolverResolveAbi,
  universalResolverReverseAbi,
  universalSignatureValidatorAbi,
  wrapConstructor
} from "./chunk-JYSHRMSU.js";
import {
  equalBytes
} from "./chunk-VCUXZ5V6.js";
import {
  require_jsx_runtime
} from "./chunk-U62YBD46.js";
import {
  chains_exports
} from "./chunk-NEFF4NAT.js";
import {
  require_react_dom
} from "./chunk-ZRYTYW4C.js";
import {
  require_react
} from "./chunk-YP55OVAM.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter4() {
      EventEmitter4.init.call(this);
    }
    module2.exports = EventEmitter4;
    module2.exports.once = once;
    EventEmitter4.EventEmitter = EventEmitter4;
    EventEmitter4.prototype._events = void 0;
    EventEmitter4.prototype._eventsCount = 0;
    EventEmitter4.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter4, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter4.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter4.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter4.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter4.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter4.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter4.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter4.prototype.on = EventEmitter4.prototype.addListener;
    EventEmitter4.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter4.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter4.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter4.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter4.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter4.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject2;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root2;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports2, module2) {
    var root2 = require_root();
    var now = function() {
      return root2.Date.now();
    };
    module2.exports = now;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports2, module2) {
    var isObject2 = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait2, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait2 = toNumber(wait2) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait2);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait2);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait2);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module2.exports = debounce2;
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root2.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto4;
        if (typeof window !== "undefined" && window.crypto) {
          crypto4 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto4 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto4 = globalThis.crypto;
        }
        if (!crypto4 && typeof window !== "undefined" && window.msCrypto) {
          crypto4 = window.msCrypto;
        }
        if (!crypto4 && typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto4 = globalThis.crypto;
        }
        if (!crypto4 && typeof __require === "function") {
          try {
            crypto4 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto4) {
            if (typeof crypto4.getRandomValues === "function") {
              try {
                return crypto4.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto4.randomBytes === "function") {
              try {
                return crypto4.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports2, module2) {
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K2 = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA2563 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f3 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f3 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K2[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f3;
              f3 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f3 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA2563);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA2563);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f3) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f3(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify3(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify3(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify3(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/bitcore-lib/package.json
var require_package = __commonJS({
  "node_modules/bitcore-lib/package.json"(exports2, module2) {
    module2.exports = {
      name: "bitcore-lib",
      version: "10.0.28",
      description: "A pure and powerful JavaScript Bitcoin library.",
      author: "BitPay <dev@bitpay.com>",
      main: "index.js",
      scripts: {
        test: "gulp test",
        "test:ci": "npm run test",
        coverage: "gulp coverage",
        build: "gulp",
        pub: "npm run build && npm publish"
      },
      keywords: [
        "bitcoin",
        "transaction",
        "address",
        "p2p",
        "ecies",
        "cryptocurrency",
        "blockchain",
        "payment",
        "bip21",
        "bip32",
        "bip37",
        "bip69",
        "bip70",
        "multisig"
      ],
      repository: {
        type: "git",
        url: "https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib"
      },
      browser: {
        request: "browser-request"
      },
      dependencies: {
        bech32: "=2.0.0",
        "bip-schnorr": "=0.6.4",
        "bn.js": "=4.11.8",
        bs58: "^4.0.1",
        "buffer-compare": "=1.1.1",
        elliptic: "^6.5.3",
        inherits: "=2.0.1",
        lodash: "^4.17.20"
      },
      devDependencies: {
        "bitcore-build": "^10.0.21",
        brfs: "^2.0.1",
        chai: "^4.2.0",
        gulp: "^4.0.0",
        sinon: "^7.1.1"
      },
      license: "MIT",
      gitHead: "c47030e29c2ef353b41955d78fd0ca5c8422c590"
    };
  }
});

// node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer2().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number2.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number2, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number2, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod2; i++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size3) {
        while (this.length < size3) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input, output3) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output3.words[i] = input.words[i];
        }
        output3.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output3.words[output3.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION3 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter2 = 0;
        var maskSrcKey = function() {
          var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid2 ? "Symbol(src)_1." + uid2 : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash3(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash3.prototype.clear = hashClear;
        Hash3.prototype["delete"] = hashDelete;
        Hash3.prototype.get = hashGet;
        Hash3.prototype.has = hashHas;
        Hash3.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash3(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash3()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size4 = data.size;
          data.set(key, value);
          this.size += data.size == size4 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined2 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait2, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString3(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString3(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString3(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString3(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size4 = data.size;
            switch (data.type) {
              case "drop":
                start += size4;
                break;
              case "dropRight":
                end -= size4;
                break;
              case "take":
                end = nativeMin(end, start + size4);
                break;
              case "takeRight":
                start = nativeMax(start, end - size4);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait2) {
          return root2.setTimeout(func, wait2);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size4) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size4 = size4 === undefined2 ? length : size4;
          while (++index2 < size4) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size4;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size4, guard) {
          if (guard ? isIterateeCall(array, size4, guard) : size4 === undefined2) {
            size4 = 1;
          } else {
            size4 = nativeMax(toInteger(size4), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size4 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size4));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size4);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size3(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait2, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait2 = toNumber(wait2) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait2);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait2);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait2);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait2, args) {
          return baseDelay(func, toNumber(wait2) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread3(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait2, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait2, {
            "leading": leading,
            "maxWait": wait2,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER2;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype3, properties) {
          var result2 = baseCreate(prototype3);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert2 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString3(string).toLowerCase());
        }
        function deburr(string) {
          string = toString3(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string, target, position) {
          string = toString3(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString3(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString3(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString3(string), n);
        }
        function replace() {
          var args = arguments, string = toString3(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split2(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString3(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString3(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString3(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString3(value).toLowerCase();
        }
        function toUpper(value) {
          return toString3(value).toUpperCase();
        }
        function trim3(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString3(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString3(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString3(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method2 = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter2;
          return toString3(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind2;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat2;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults2;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert2;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method2;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice2;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split2;
        lodash.spread = spread3;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray2;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith2;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey2;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach2;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer2;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer2;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp2;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad2;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size3;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString3;
        lodash.toUpper = toUpper;
        lodash.trim = trim3;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach2;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION3;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root2._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/bitcore-lib/lib/errors/spec.js
var require_spec = __commonJS({
  "node_modules/bitcore-lib/lib/errors/spec.js"(exports2, module2) {
    "use strict";
    var docsURL = "http://bitcore.io/";
    module2.exports = [{
      name: "InvalidB58Char",
      message: "Invalid Base58 character: {0} in {1}"
    }, {
      name: "InvalidB58Checksum",
      message: "Invalid Base58 checksum for {0}"
    }, {
      name: "InvalidNetwork",
      message: "Invalid version for network: got {0}"
    }, {
      name: "InvalidState",
      message: "Invalid state: {0}"
    }, {
      name: "NotImplemented",
      message: "Function {0} was not implemented yet"
    }, {
      name: "InvalidNetworkArgument",
      message: 'Invalid network: must be "livenet" or "testnet", got {0}'
    }, {
      name: "InvalidArgument",
      message: function() {
        return "Invalid Argument" + (arguments[0] ? ": " + arguments[0] : "") + (arguments[1] ? " Documentation: " + docsURL + arguments[1] : "");
      }
    }, {
      name: "AbstractMethodInvoked",
      message: "Abstract Method Invocation: {0}"
    }, {
      name: "InvalidArgumentType",
      message: function() {
        return "Invalid Argument for " + arguments[2] + ", expected " + arguments[1] + " but got " + typeof arguments[0];
      }
    }, {
      name: "Unit",
      message: "Internal Error on Unit {0}",
      errors: [{
        "name": "UnknownCode",
        "message": "Unrecognized unit code: {0}"
      }, {
        "name": "InvalidRate",
        "message": "Invalid exchange rate: {0}"
      }]
    }, {
      name: "MerkleBlock",
      message: "Internal Error on MerkleBlock {0}",
      errors: [{
        "name": "InvalidMerkleTree",
        "message": "This MerkleBlock contain an invalid Merkle Tree"
      }]
    }, {
      name: "Transaction",
      message: "Internal Error on Transaction {0}",
      errors: [{
        name: "Input",
        message: "Internal Error on Input {0}",
        errors: [
          {
            name: "MissingScript",
            message: "Need a script to create an input"
          },
          {
            name: "UnsupportedScript",
            message: "Unsupported input script type: {0}"
          },
          {
            name: "MissingPreviousOutput",
            message: "No previous output information."
          },
          {
            name: "BlockHeightOutOfRange",
            message: "Block Height can only be between 0 and 65535"
          },
          {
            name: "LockTimeRange",
            message: "Seconds needs to be more that 0 and less that 33553920"
          }
        ]
      }, {
        name: "NeedMoreInfo",
        message: "{0}"
      }, {
        name: "InvalidSorting",
        message: "The sorting function provided did not return the change output as one of the array elements"
      }, {
        name: "InvalidOutputAmountSum",
        message: "{0}"
      }, {
        name: "MissingSignatures",
        message: "Some inputs have not been fully signed"
      }, {
        name: "InvalidIndex",
        message: "Invalid index: {0} is not between 0, {1}"
      }, {
        name: "UnableToVerifySignature",
        message: "Unable to verify signature: {0}"
      }, {
        name: "DustOutputs",
        message: "Dust amount detected in one output"
      }, {
        name: "InvalidSatoshis",
        message: "Output satoshis are invalid"
      }, {
        name: "FeeError",
        message: "Internal Error on Fee {0}",
        errors: [{
          name: "TooSmall",
          message: "Fee is too small: {0}"
        }, {
          name: "TooLarge",
          message: "Fee is too large: {0}"
        }, {
          name: "Different",
          message: "Unspent value is different from specified fee: {0}"
        }]
      }, {
        name: "ChangeAddressMissing",
        message: "Change address is missing"
      }, {
        name: "BlockHeightTooHigh",
        message: "Block Height can be at most 2^32 -1"
      }, {
        name: "NLockTimeOutOfRange",
        message: "Block Height can only be between 0 and 499 999 999"
      }, {
        name: "LockTimeTooEarly",
        message: "Lock Time can't be earlier than UNIX date 500 000 000"
      }]
    }, {
      name: "Script",
      message: "Internal Error on Script {0}",
      errors: [{
        name: "UnrecognizedAddress",
        message: "Expected argument {0} to be an address"
      }, {
        name: "CantDeriveAddress",
        message: "Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out."
      }, {
        name: "InvalidBuffer",
        message: "Invalid script buffer: can't parse valid script from given buffer {0}"
      }]
    }, {
      name: "HDPrivateKey",
      message: "Internal Error on HDPrivateKey {0}",
      errors: [{
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument {0}, expected string, or number and boolean"
      }, {
        name: "InvalidEntropyArgument",
        message: "Invalid entropy: must be an hexa string or binary buffer, got {0}",
        errors: [{
          name: "TooMuchEntropy",
          message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
        }, {
          name: "NotEnoughEntropy",
          message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
        }]
      }, {
        name: "InvalidLength",
        message: "Invalid length for xprivkey string in {0}"
      }, {
        name: "InvalidPath",
        message: "Invalid derivation path: {0}"
      }, {
        name: "UnrecognizedArgument",
        message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
      }]
    }, {
      name: "HDPublicKey",
      message: "Internal Error on HDPublicKey {0}",
      errors: [{
        name: "ArgumentIsPrivateExtended",
        message: "Argument is an extended private key: {0}"
      }, {
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument: got {0}"
      }, {
        name: "InvalidLength",
        message: 'Invalid length for xpubkey: got "{0}"'
      }, {
        name: "InvalidPath",
        message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
      }, {
        name: "InvalidIndexCantDeriveHardened",
        message: "Invalid argument: creating a hardened path requires an HDPrivateKey"
      }, {
        name: "MustSupplyArgument",
        message: "Must supply an argument to create a HDPublicKey"
      }, {
        name: "UnrecognizedArgument",
        message: "Invalid argument for creation, must be string, json, buffer, or object"
      }]
    }];
  }
});

// node_modules/bitcore-lib/lib/errors/index.js
var require_errors = __commonJS({
  "node_modules/bitcore-lib/lib/errors/index.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    function format(message, args) {
      return message.replace("{0}", args[0]).replace("{1}", args[1]).replace("{2}", args[2]);
    }
    var traverseNode = function(parent, errorDefinition) {
      var NodeError = function() {
        if (_.isString(errorDefinition.message)) {
          this.message = format(errorDefinition.message, arguments);
        } else if (_.isFunction(errorDefinition.message)) {
          this.message = errorDefinition.message.apply(null, arguments);
        } else {
          throw new Error("Invalid error definition for " + errorDefinition.name);
        }
        this.stack = this.message + "\n" + new Error().stack;
      };
      NodeError.prototype = Object.create(parent.prototype);
      NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
      parent[errorDefinition.name] = NodeError;
      if (errorDefinition.errors) {
        childDefinitions(NodeError, errorDefinition.errors);
      }
      return NodeError;
    };
    var childDefinitions = function(parent, childDefinitions2) {
      _.each(childDefinitions2, function(childDefinition) {
        traverseNode(parent, childDefinition);
      });
    };
    var traverseRoot = function(parent, errorsDefinition) {
      childDefinitions(parent, errorsDefinition);
      return parent;
    };
    var bitcore2 = {};
    bitcore2.Error = function() {
      this.message = "Internal error";
      this.stack = this.message + "\n" + new Error().stack;
    };
    bitcore2.Error.prototype = Object.create(Error.prototype);
    bitcore2.Error.prototype.name = "bitcore.Error";
    var data = require_spec();
    traverseRoot(bitcore2.Error, data);
    module2.exports = bitcore2.Error;
    module2.exports.extend = function(spec) {
      return traverseNode(bitcore2.Error, spec);
    };
  }
});

// node_modules/bitcore-lib/lib/util/preconditions.js
var require_preconditions = __commonJS({
  "node_modules/bitcore-lib/lib/util/preconditions.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var _ = require_lodash();
    module2.exports = {
      checkState: function(condition, message) {
        if (!condition) {
          throw new errors.InvalidState(message);
        }
      },
      checkArgument: function(condition, argumentName, message, docsPath4) {
        if (!condition) {
          throw new errors.InvalidArgument(argumentName, message, docsPath4);
        }
      },
      checkArgumentType: function(argument, type, argumentName) {
        argumentName = argumentName || "(unknown name)";
        if (_.isString(type)) {
          if (type === "Buffer") {
            var buffer2 = require_buffer();
            if (!buffer2.Buffer.isBuffer(argument)) {
              throw new errors.InvalidArgumentType(argument, type, argumentName);
            }
          } else if (typeof argument !== type) {
            throw new errors.InvalidArgumentType(argument, type, argumentName);
          }
        } else {
          if (!(argument instanceof type)) {
            throw new errors.InvalidArgumentType(argument, type.name, argumentName);
          }
        }
      }
    };
  }
});

// node_modules/bitcore-lib/lib/crypto/bn.js
var require_bn2 = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/bn.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var $ = require_preconditions();
    var _ = require_lodash();
    var reversebuf = function(buf) {
      var buf2 = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        buf2[i] = buf[buf.length - 1 - i];
      }
      return buf2;
    };
    BN.Zero = new BN(0);
    BN.One = new BN(1);
    BN.Minus1 = new BN(-1);
    BN.fromNumber = function(n) {
      $.checkArgument(_.isNumber(n));
      return new BN(n);
    };
    BN.fromString = function(str, base) {
      $.checkArgument(_.isString(str));
      return new BN(str, base);
    };
    BN.fromBuffer = function(buf, opts) {
      if (typeof opts !== "undefined" && opts.endian === "little") {
        buf = reversebuf(buf);
      }
      var hex = buf.toString("hex");
      var bn = new BN(hex, 16);
      return bn;
    };
    BN.fromSM = function(buf, opts) {
      var ret;
      if (buf.length === 0) {
        return BN.fromBuffer(Buffer.from([0]));
      }
      var endian = "big";
      if (opts) {
        endian = opts.endian;
      }
      if (endian === "little") {
        buf = reversebuf(buf);
      }
      if (buf[0] & 128) {
        buf[0] = buf[0] & 127;
        ret = BN.fromBuffer(buf);
        ret.neg().copy(ret);
      } else {
        ret = BN.fromBuffer(buf);
      }
      return ret;
    };
    BN.prototype.toNumber = function() {
      return parseInt(this.toString(10), 10);
    };
    BN.prototype.toBuffer = function(opts) {
      var buf, hex;
      if (opts && opts.size) {
        hex = this.toString(16, 2);
        var natlen = hex.length / 2;
        buf = Buffer.from(hex, "hex");
        if (natlen === opts.size) {
          buf = buf;
        } else if (natlen > opts.size) {
          buf = BN.trim(buf, natlen);
        } else if (natlen < opts.size) {
          buf = BN.pad(buf, natlen, opts.size);
        }
      } else {
        hex = this.toString(16, 2);
        buf = Buffer.from(hex, "hex");
      }
      if (typeof opts !== "undefined" && opts.endian === "little") {
        buf = reversebuf(buf);
      }
      return buf;
    };
    BN.prototype.toSMBigEndian = function() {
      var buf;
      if (this.cmp(BN.Zero) === -1) {
        buf = this.neg().toBuffer();
        if (buf[0] & 128) {
          buf = Buffer.concat([Buffer.from([128]), buf]);
        } else {
          buf[0] = buf[0] | 128;
        }
      } else {
        buf = this.toBuffer();
        if (buf[0] & 128) {
          buf = Buffer.concat([Buffer.from([0]), buf]);
        }
      }
      if (buf.length === 1 & buf[0] === 0) {
        buf = Buffer.from([]);
      }
      return buf;
    };
    BN.prototype.toSM = function(opts) {
      var endian = opts ? opts.endian : "big";
      var buf = this.toSMBigEndian();
      if (endian === "little") {
        buf = reversebuf(buf);
      }
      return buf;
    };
    BN.fromScriptNumBuffer = function(buf, fRequireMinimal, size3) {
      var nMaxNumSize = size3 || 4;
      $.checkArgument(buf.length <= nMaxNumSize, new Error("script number overflow"));
      if (fRequireMinimal && buf.length > 0) {
        if ((buf[buf.length - 1] & 127) === 0) {
          if (buf.length <= 1 || (buf[buf.length - 2] & 128) === 0) {
            throw new Error("non-minimally encoded script number");
          }
        }
      }
      return BN.fromSM(buf, {
        endian: "little"
      });
    };
    BN.prototype.toScriptNumBuffer = function() {
      return this.toSM({
        endian: "little"
      });
    };
    BN.trim = function(buf, natlen) {
      return buf.slice(natlen - buf.length, buf.length);
    };
    BN.pad = function(buf, natlen, size3) {
      var rbuf = Buffer.alloc(size3);
      for (var i = 0; i < buf.length; i++) {
        rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
      }
      for (i = 0; i < size3 - natlen; i++) {
        rbuf[i] = 0;
      }
      return rbuf;
    };
    module2.exports = BN;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr2 = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr2.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call2 = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module2.exports = bind2.call(call2, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen2 = doEval2("%AsyncGenerator%");
        if (gen2 && getProto) {
          value = getProto(gen2.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var $exec = bind2.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(fn, "length", length, true, true);
        } else {
          define2(fn, "length", length);
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind2, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports2, module2) {
    "use strict";
    var toStr2 = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr2.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr2 = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all3 = document.all;
      if (toStr2.call(all3) === toStr2.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr2.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all3;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr2.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr2 = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty2.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty2.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach2 = function forEach3(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr2.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module2.exports = forEach2;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf2 = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf2) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf2(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf2(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach2(cache, function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      });
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach2(cache, function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name, 1);
          } catch (e) {
          }
        }
      });
      return found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray2(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports2) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray2 = require_is_typed_array();
    function uncurryThis(f3) {
      return f3.call.bind(f3);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView2(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView2;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer2(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer2;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method2) {
      Object.defineProperty(exports2, method2, {
        enumerable: false,
        value: function() {
          throw new Error(method2 + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    module2.exports = function isBuffer2(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors2 = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors2[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors2;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f3) {
      if (!isString2(f3)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f3).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject2(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean2(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined2(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined2(ctx.depth))
        ctx.depth = 2;
      if (isUndefined2(ctx.colors))
        ctx.colors = false;
      if (isUndefined2(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style2 = inspect.styles[styleType];
      if (style2) {
        return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp2(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output3;
      if (array) {
        output3 = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output3 = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output3, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined2(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean2(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output3 = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output3.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output3.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output3.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output3;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined2(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output3, base, braces) {
      var numLinesEst = 0;
      var length = output3.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output3.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output3.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray2;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp2(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp2;
    exports2.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate2(d) {
      return isObject2(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate2;
    exports2.types.isDate = isDate2;
    function isError(e) {
      return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad2(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad2(d.getHours()),
        pad2(d.getMinutes()),
        pad2(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject2(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// node_modules/assert/build/internal/errors.js
var require_errors2 = __commonJS({
  "node_modules/assert/build/internal/errors.js"(exports2, module2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var codes = {};
    var assert2;
    var util;
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inherits(NodeError2, _Base);
        var _super = _createSuper(NodeError2);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck(this, NodeError2);
          _this = _super.call(this, getMessage(arg1, arg2, arg3));
          _this.code = code;
          return _this;
        }
        return _createClass(NodeError2);
      }(Base);
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      if (assert2 === void 0)
        assert2 = require_assert();
      assert2(typeof name === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith2(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof(actual));
      return msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util === void 0)
        util = require_util();
      var inspected = util.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
      var type;
      if (value && value.constructor && value.constructor.name) {
        type = "instance of ".concat(value.constructor.name);
      } else {
        type = "type ".concat(_typeof(value));
      }
      return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert2 === void 0)
        assert2 = require_assert();
      assert2(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    module2.exports.codes = codes;
  }
});

// node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS({
  "node_modules/assert/build/internal/assert/assertion_error.js"(exports2, module2) {
    "use strict";
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var _require = require_util();
    var inspect = _require.inspect;
    var _require2 = require_errors2();
    var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      count = Math.floor(count);
      if (str.length == 0 || count == 0)
        return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count) {
        str += str;
        count--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys.forEach(function(key) {
        target[key] = source[key];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        showHidden: false,
        breakLength: Infinity,
        showProxy: false,
        sorted: true,
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i] === expectedLines[0][i]) {
              i++;
            }
            if (i > 2) {
              indicator = "\n  ".concat(repeat(" ", i), "^");
              i = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0)
          break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i = 0; i < maxLines; i++) {
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
          printedLines++;
        } else if (expectedLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i];
          var actualLine = actualLines[i];
          var divergingLines = actualLine !== expectedLine && (!endsWith2(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith2(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = function(_Error, _inspect$custom) {
      _inherits(AssertionError2, _Error);
      var _super = _createSuper(AssertionError2);
      function AssertionError2(options) {
        var _this;
        _classCallCheck(this, AssertionError2);
        if (_typeof(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) {
          _this = _super.call(this, String(message));
        } else {
          if (process.stderr && process.stderr.isTTY) {
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _super.call(this, createErrDiff(actual, expected, operator));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
              base = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _super.call(this, "".concat(base, " ").concat(res[0]));
            } else {
              _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _super.call(this, "".concat(_res).concat(other));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
      }
      _createClass(AssertionError2, [{
        key: "toString",
        value: function toString3() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: _inspect$custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError2;
    }(_wrapNativeSuper(Error), inspect.custom);
    module2.exports = AssertionError;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr2 = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr2.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr2.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr2 = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction2 = toStr2.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString2 = isObject2 && toStr2.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction2 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr2;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice2 = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice2.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/object.assign/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object.assign/implementation.js"(exports2, module2) {
    "use strict";
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module2.exports = function assign(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = toObject(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s = 1; s < arguments.length; ++s) {
        var from = toObject(arguments[s]);
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j = 0; j < syms.length; ++j) {
            var key = syms[j];
            if ($propIsEnumerable(from, key)) {
              $push(keys, key);
            }
          }
        }
        for (var i = 0; i < keys.length; ++i) {
          var nextKey = keys[i];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// node_modules/object.assign/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.assign/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map = {};
      for (var i = 0; i < letters.length; ++i) {
        map[letters[i]] = letters[i];
      }
      var obj = Object.assign({}, map);
      var actual = "";
      for (var k in obj) {
        actual += k;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e) {
        return thrower[1] === "y";
      }
      return false;
    };
    module2.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// node_modules/object-is/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/object-is/implementation.js"(exports2, module2) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module2.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/object-is/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    module2.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr2 = Object.prototype.toString;
    var concat2 = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction2 = function(fn) {
      return typeof fn === "function" && toStr2.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction2(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates2 = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat2.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates2[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill2();
    var define2 = require_define_properties();
    module2.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/is-nan/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/is-nan/implementation.js"(exports2, module2) {
    "use strict";
    module2.exports = function isNaN2(value) {
      return value !== value;
    };
  }
});

// node_modules/is-nan/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/is-nan/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation5();
    module2.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation;
    };
  }
});

// node_modules/is-nan/shim.js
var require_shim2 = __commonJS({
  "node_modules/is-nan/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill3();
    module2.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      define2(Number, { isNaN: polyfill }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/is-nan/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Number);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS({
  "node_modules/assert/build/internal/util/comparisons.js"(exports2, module2) {
    "use strict";
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f3 = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t)
              return;
            f3 = false;
          } else
            for (; !(f3 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f3 = true)
              ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f3 && null != t.return && (u = t.return(), Object(u) !== u))
              return;
          } finally {
            if (o)
              throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map) {
      var array = [];
      map.forEach(function(value, key) {
        return array.push([key, value]);
      });
      return array;
    };
    var objectIs = Object.is ? Object.is : require_object_is();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f3) {
      return f3.call.bind(f3);
    }
    var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = require_util().types;
    var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
    var isArrayBufferView2 = _require$types.isArrayBufferView;
    var isDate2 = _require$types.isDate;
    var isMap = _require$types.isMap;
    var isRegExp2 = _require$types.isRegExp;
    var isSet = _require$types.isSet;
    var isNativeError = _require$types.isNativeError;
    var isBoxedPrimitive = _require$types.isBoxedPrimitive;
    var isNumberObject = _require$types.isNumberObject;
    var isStringObject = _require$types.isStringObject;
    var isBooleanObject = _require$types.isBooleanObject;
    var isBigIntObject = _require$types.isBigIntObject;
    var isSymbolObject = _require$types.isSymbolObject;
    var isFloat32Array = _require$types.isFloat32Array;
    var isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10)
        return true;
      for (var i = 0; i < key.length; i++) {
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57)
          return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var ONLY_ENUMERABLE = void 0;
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0)
          return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        }
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate2(val1)) {
        if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp2(val1)) {
        if (!isRegExp2(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView2(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i = 0;
      for (; i < aKeys.length; i++) {
        if (!hasOwnProperty2(val2, aKeys[i])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            var key = symbolKeysA[i];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key)) {
                return false;
              }
              aKeys.push(key);
              count++;
            } else if (propertyIsEnumerable(val2, key)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo2) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo2)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo2) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo2)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo2);
    }
    function setEquiv(a, b, strict, memo2) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i = 0; i < aValues.length; i++) {
        var val = aValues[i];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict)
            return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo2))
              return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo2)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo2) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo2) && innerDeepEqual(item1, map.get(key2), strict, memo2)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo2) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key);
        } else {
          var item2 = b.get(key);
          if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo2)) {
            if (strict)
              return false;
            if (!mapMightHaveLoosePrim(a, b, key, item1, memo2))
              return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(_key) === "object" && _key !== null) {
            if (!mapHasEqualEntry(set, a, _key, item, strict, memo2))
              return false;
          } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo2)) && !mapHasEqualEntry(set, a, _key, item, false, memo2)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys, memos, iterationType) {
      var i = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i < a.length; i++) {
          if (hasOwnProperty2(a, i)) {
            if (!hasOwnProperty2(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty2(b, i)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i < keysA.length; i++) {
              var key = keysA[i];
              if (!hasOwnProperty2(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys.length; i++) {
        var _key2 = keys[i];
        if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module2.exports = {
      isDeepEqual,
      isDeepStrictEqual
    };
  }
});

// node_modules/assert/build/assert.js
var require_assert = __commonJS({
  "node_modules/assert/build/assert.js"(exports2, module2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_errors2();
    var _require$codes = _require.codes;
    var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
    var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var AssertionError = require_assertion_error();
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var _require$types = require_util().types;
    var isPromise = _require$types.isPromise;
    var isRegExp2 = _require$types.isRegExp;
    var objectAssign = require_polyfill()();
    var objectIs = require_polyfill2()();
    var RegExpPrototypeTest = require_callBound()("RegExp.prototype.test");
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert2 = module2.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error)
        throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2)
          operator = "!=";
      }
      if (message instanceof Error)
        throw message;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message !== void 0) {
        errArgs.message = message;
      }
      var err = new AssertionError(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert2.fail = fail;
    assert2.AssertionError = AssertionError;
    function innerOk(fn, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) {
          throw message;
        }
        var err = new AssertionError({
          actual: value,
          expected: true,
          message,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert2.ok = ok;
    assert2.equal = function equal(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert2.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert2.deepEqual = function deepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepEqual",
          stackStartFn: deepEqual
        });
      }
    };
    assert2.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert2.strictEqual = function strictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "strictEqual",
          stackStartFn: strictEqual
        });
      }
    };
    assert2.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = _createClass(function Comparison2(obj, keys, actual) {
      var _this = this;
      _classCallCheck(this, Comparison2);
      keys.forEach(function(key) {
        if (key in obj) {
          if (actual !== void 0 && typeof actual[key] === "string" && isRegExp2(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
            _this[key] = actual[key];
          } else {
            _this[key] = obj[key];
          }
        }
      });
    });
    function compareExceptionKey(actual, expected, key, message, keys, fn) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a = new Comparison(actual, keys);
          var b = new Comparison(expected, keys, actual);
          var err = new AssertionError({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp2(expected))
          return RegExpPrototypeTest(expected, actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof(actual) !== "object" || actual === null) {
          var err = new AssertionError({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error) {
          keys.push("name", "message");
        } else if (keys.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        keys.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp2(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
            return;
          }
          compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message = error;
        error = void 0;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL)
        return;
      if (typeof error === "string") {
        message = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert2.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert2.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert2.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert2.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert2.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message += err.constructor.name;
          } else {
            message += err.message;
          }
        } else {
          message += inspect(err);
        }
        var newErr = new AssertionError({
          actual: err,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i = 0; i < tmp2.length; i++) {
            var pos = tmp1.indexOf(tmp2[i]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function internalMatch(string, regexp, message, fn, fnName) {
      if (!isRegExp2(regexp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      }
      var match = fnName === "match";
      if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
        if (message instanceof Error) {
          throw message;
        }
        var generatedMessage = !message;
        message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
        var err = new AssertionError({
          actual: string,
          expected: regexp,
          message,
          operator: fnName,
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    assert2.match = function match(string, regexp, message) {
      internalMatch(string, regexp, message, match, "match");
    };
    assert2.doesNotMatch = function doesNotMatch(string, regexp, message) {
      internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert2.strict = objectAssign(strict, assert2, {
      equal: assert2.strictEqual,
      deepEqual: assert2.deepStrictEqual,
      notEqual: assert2.notStrictEqual,
      notDeepEqual: assert2.notDeepStrictEqual
    });
    assert2.strict.strict = assert2.strict;
  }
});

// node_modules/bitcore-lib/lib/util/js.js
var require_js = __commonJS({
  "node_modules/bitcore-lib/lib/util/js.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var isHexa = function isHexa2(value) {
      if (!_.isString(value)) {
        return false;
      }
      return /^[0-9a-fA-F]+$/.test(value);
    };
    module2.exports = {
      isValidJSON: function isValidJSON(arg) {
        var parsed;
        if (!_.isString(arg)) {
          return false;
        }
        try {
          parsed = JSON.parse(arg);
        } catch (e) {
          return false;
        }
        if (typeof parsed === "object") {
          return true;
        }
        return false;
      },
      isHexa,
      isHexaString: isHexa,
      cloneArray: function(array) {
        return [].concat(array);
      },
      defineImmutable: function defineImmutable(target, values) {
        Object.keys(values).forEach(function(key) {
          Object.defineProperty(target, key, {
            configurable: false,
            enumerable: true,
            value: values[key]
          });
        });
        return target;
      },
      isNaturalNumber: function isNaturalNumber(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
      }
    };
  }
});

// node_modules/bitcore-lib/lib/util/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/bitcore-lib/lib/util/buffer.js"(exports2, module2) {
    "use strict";
    var buffer2 = require_buffer();
    var assert2 = require_assert();
    var js = require_js();
    var $ = require_preconditions();
    function equals(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      var length = a.length;
      for (var i = 0; i < length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      fill: function fill(buffer3, value) {
        $.checkArgumentType(buffer3, "Buffer", "buffer");
        $.checkArgumentType(value, "number", "value");
        var length = buffer3.length;
        for (var i = 0; i < length; i++) {
          buffer3[i] = value;
        }
        return buffer3;
      },
      copy: function(original) {
        var buffer3 = Buffer.alloc(original.length);
        original.copy(buffer3);
        return buffer3;
      },
      isBuffer: function isBuffer2(arg) {
        return buffer2.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
      },
      emptyBuffer: function emptyBuffer(bytes2) {
        $.checkArgumentType(bytes2, "number", "bytes");
        var result = Buffer.alloc(bytes2);
        for (var i = 0; i < bytes2; i++) {
          result.write("\0", i);
        }
        return result;
      },
      concat: buffer2.Buffer.concat,
      equals,
      equal: equals,
      integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
        $.checkArgumentType(integer, "number", "integer");
        return Buffer.from([integer & 255]);
      },
      integerAsBuffer: function integerAsBuffer(integer) {
        $.checkArgumentType(integer, "number", "integer");
        var bytes2 = [];
        bytes2.push(integer >> 24 & 255);
        bytes2.push(integer >> 16 & 255);
        bytes2.push(integer >> 8 & 255);
        bytes2.push(integer & 255);
        return Buffer.from(bytes2);
      },
      integerFromBuffer: function integerFromBuffer(buffer3) {
        $.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3[0] << 24 | buffer3[1] << 16 | buffer3[2] << 8 | buffer3[3];
      },
      integerFromSingleByteBuffer: function integerFromBuffer(buffer3) {
        $.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3[0];
      },
      bufferToHex: function bufferToHex(buffer3) {
        $.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3.toString("hex");
      },
      reverse: function reverse(param) {
        return Buffer.from(param).reverse();
      }
    };
    module2.exports.NULL_HASH = module2.exports.fill(Buffer.alloc(32), 0);
    module2.exports.EMPTY_BUFFER = Buffer.alloc(0);
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/package.json
var require_package2 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.5",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index2) {
        var c = string.charCodeAt(index2);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod2; i++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size3) {
        while (this.length < size3) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input, output3) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output3.words[i] = input.words[i];
        }
        output3.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output3.words[output3.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode3(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN = require_bn3();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes2) {
      return typeof bytes2 === "string" ? utils.toArray(bytes2, "hex") : bytes2;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes2) {
      return new BN(bytes2, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto4 = require_crypto();
        if (typeof crypto4.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto4.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto4;
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert2 = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert2(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert2(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index2 = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
      bytes2 = utils.toArray(bytes2, enc);
      var len = this.p.byteLength();
      if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
        if (bytes2[0] === 6)
          assert2(bytes2[bytes2.length - 1] % 2 === 0);
        else if (bytes2[0] === 7)
          assert2(bytes2[bytes2.length - 1] % 2 === 1);
        var res = this.point(
          bytes2.slice(1, 1 + len),
          bytes2.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
        return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode3(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn3();
    var inherits2 = require_inherits_browser2();
    var Base = require_base();
    var assert2 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate2(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split2 = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split2.k1.negative) {
          split2.k1.ineg();
          p = p.neg(true);
        }
        if (split2.k2.negative) {
          split2.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split2.k1;
        ncoeffs[i * 2 + 1] = split2.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point2(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point2, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point2(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point2.fromJSON(this, obj, red);
    };
    Point2.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point2.prototype.toJSON = function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point2.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point2.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point2.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point2.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point2.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point2.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow3) {
      if (pow3 === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow3)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow3; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow3; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow3)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f3 = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f3.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var inherits2 = require_inherits_browser2();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate2(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point2(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
      return this.point(utils.toArray(bytes2, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point2(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    Point2.prototype.precompute = function precompute() {
    };
    Point2.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point2.fromJSON = function fromJSON(curve, obj) {
      return new Point2(curve, obj[0], obj[1] || curve.one);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point2.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point2.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point2.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point2.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point2.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn3();
    var inherits2 = require_inherits_browser2();
    var Base = require_base();
    var assert2 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate2(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point2(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point2(this, x, y, z, t);
    };
    Point2.fromJSON = function fromJSON(curve, obj) {
      return new Point2(curve, obj[0], obj[1], obj[2]);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point2.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f3 = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f3 = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f3.redSub(this.curve.two));
          ny = f3.redMul(e.redSub(d));
          nz = f3.redSqr().redSub(f3).redSub(f3);
        } else {
          h = this.z.redSqr();
          j = f3.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f3.redMul(e.redSub(d));
          nz = f3.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point2.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f3 = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f3 = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f3).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f3.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f3).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point2.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point2.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point2.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point2.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point2.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac2() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate2() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert2(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert2(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert2(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert2(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert2 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert2(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes2 = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes2));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes2 = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes2);
      var nonce = msg.toArray("be", bytes2);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert2((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash2.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert2(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert2(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert2(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes5() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert2(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash3.update(arguments[i]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes2) {
      bytes2 = utils.parseBytes(bytes2);
      var lastIx = bytes2.length - 1;
      var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
      var xIsOdd = (bytes2[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
      return utils.intFromLE(bytes2);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/bitcore-lib/node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package2().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/bitcore-lib/lib/crypto/point.js
var require_point = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/point.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecPoint = ec.curve.point.bind(ec.curve);
    var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);
    var Point2 = function Point3(x, y, isRed) {
      try {
        var point = ecPoint(x, y, isRed);
      } catch (e) {
        throw new Error("Invalid Point");
      }
      point.validate();
      return point;
    };
    Point2.prototype = Object.getPrototypeOf(ec.curve.point());
    Point2.fromX = function fromX(odd, x) {
      try {
        var point = ecPointFromX(x, odd);
      } catch (e) {
        throw new Error("Invalid X");
      }
      point.validate();
      return point;
    };
    Point2.getG = function getG() {
      return ec.curve.g;
    };
    Point2.getN = function getN() {
      return new BN(ec.curve.n.toArray());
    };
    Point2.prototype._getX = Point2.prototype.getX;
    Point2.prototype.getX = function getX() {
      return new BN(this._getX().toArray());
    };
    Point2.prototype._getY = Point2.prototype.getY;
    Point2.prototype.getY = function getY() {
      return new BN(this._getY().toArray());
    };
    Point2.prototype.validate = function validate2() {
      if (this.isInfinity()) {
        throw new Error("Point cannot be equal to Infinity");
      }
      var p2;
      try {
        p2 = ecPointFromX(this.getX(), this.getY().isOdd());
      } catch (e) {
        throw new Error("Point does not lie on the curve");
      }
      if (p2.y.cmp(this.y) !== 0) {
        throw new Error("Invalid y value for curve.");
      }
      if (!this.mul(Point2.getN()).isInfinity()) {
        throw new Error("Point times N must be infinity");
      }
      return this;
    };
    Point2.pointToCompressed = function pointToCompressed(point) {
      var xbuf = point.getX().toBuffer({ size: 32 });
      var ybuf = point.getY().toBuffer({ size: 32 });
      var prefix;
      var odd = ybuf[ybuf.length - 1] % 2;
      if (odd) {
        prefix = Buffer.from([3]);
      } else {
        prefix = Buffer.from([2]);
      }
      return BufferUtil.concat([prefix, xbuf]);
    };
    module2.exports = Point2;
  }
});

// node_modules/bitcore-lib/lib/crypto/signature.js
var require_signature3 = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Signature = function Signature2(r, s) {
      if (!(this instanceof Signature2)) {
        return new Signature2(r, s);
      }
      if (r instanceof BN) {
        this.set({
          r,
          s
        });
      } else if (r) {
        var obj = r;
        this.set(obj);
      }
    };
    Signature.prototype.set = function(obj) {
      this.r = obj.r || this.r || void 0;
      this.s = obj.s || this.s || void 0;
      this.i = typeof obj.i !== "undefined" ? obj.i : this.i;
      this.compressed = typeof obj.compressed !== "undefined" ? obj.compressed : this.compressed;
      this.nhashtype = obj.nhashtype || this.nhashtype || void 0;
      return this;
    };
    Signature.fromCompact = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf), "Argument is expected to be a Buffer");
      var sig = new Signature();
      var compressed = true;
      var i = buf.slice(0, 1)[0] - 27 - 4;
      if (i < 0) {
        compressed = false;
        i = i + 4;
      }
      var b2 = buf.slice(1, 33);
      var b3 = buf.slice(33, 65);
      $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error("i must be 0, 1, 2, or 3"));
      $.checkArgument(b2.length === 32, new Error("r must be 32 bytes"));
      $.checkArgument(b3.length === 32, new Error("s must be 32 bytes"));
      sig.compressed = compressed;
      sig.i = i;
      sig.r = BN.fromBuffer(b2);
      sig.s = BN.fromBuffer(b3);
      return sig;
    };
    Signature.fromDER = Signature.fromBuffer = function(buf, strict) {
      var obj = Signature.parseDER(buf, strict);
      var sig = new Signature();
      sig.r = obj.r;
      sig.s = obj.s;
      return sig;
    };
    Signature.fromTxFormat = function(buf) {
      var nhashtype = buf.readUInt8(buf.length - 1);
      var derbuf = buf.slice(0, buf.length - 1);
      var sig = new Signature.fromDER(derbuf, false);
      sig.nhashtype = nhashtype;
      return sig;
    };
    Signature.fromString = function(str) {
      var buf = Buffer.from(str, "hex");
      return Signature.fromDER(buf);
    };
    Signature.parseDER = function(buf, strict) {
      $.checkArgument(BufferUtil.isBuffer(buf), new Error("DER formatted signature should be a buffer"));
      if (_.isUndefined(strict)) {
        strict = true;
      }
      var header = buf[0];
      $.checkArgument(header === 48, new Error("Header byte should be 0x30"));
      var length = buf[1];
      var buflength = buf.slice(2).length;
      $.checkArgument(!strict || length === buflength, new Error("Length byte should length of what follows"));
      length = length < buflength ? length : buflength;
      var rheader = buf[2 + 0];
      $.checkArgument(rheader === 2, new Error("Integer byte for r should be 0x02"));
      var rlength = buf[2 + 1];
      var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
      var r = BN.fromBuffer(rbuf);
      var rneg = buf[2 + 1 + 1] === 0 ? true : false;
      $.checkArgument(rlength === rbuf.length, new Error("Length of r incorrect"));
      var sheader = buf[2 + 2 + rlength + 0];
      $.checkArgument(sheader === 2, new Error("Integer byte for s should be 0x02"));
      var slength = buf[2 + 2 + rlength + 1];
      var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
      var s = BN.fromBuffer(sbuf);
      var sneg = buf[2 + 2 + rlength + 2 + 2] === 0 ? true : false;
      $.checkArgument(slength === sbuf.length, new Error("Length of s incorrect"));
      var sumlength = 2 + 2 + rlength + 2 + slength;
      $.checkArgument(length === sumlength - 2, new Error("Length of signature incorrect"));
      var obj = {
        header,
        length,
        rheader,
        rlength,
        rneg,
        rbuf,
        r,
        sheader,
        slength,
        sneg,
        sbuf,
        s
      };
      return obj;
    };
    Signature.prototype.toCompact = function(i, compressed) {
      i = typeof i === "number" ? i : this.i;
      compressed = typeof compressed === "boolean" ? compressed : this.compressed;
      if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
        throw new Error("i must be equal to 0, 1, 2, or 3");
      }
      var val = i + 27 + 4;
      if (compressed === false) {
        val = val - 4;
      }
      var b1 = Buffer.from([val]);
      var b2 = this.r.toBuffer({
        size: 32
      });
      var b3 = this.s.toBuffer({
        size: 32
      });
      return Buffer.concat([b1, b2, b3]);
    };
    Signature.prototype.toBuffer = Signature.prototype.toDER = function() {
      var rnbuf = this.r.toBuffer();
      var snbuf = this.s.toBuffer();
      var rneg = rnbuf[0] & 128 ? true : false;
      var sneg = snbuf[0] & 128 ? true : false;
      var rbuf = rneg ? Buffer.concat([Buffer.from([0]), rnbuf]) : rnbuf;
      var sbuf = sneg ? Buffer.concat([Buffer.from([0]), snbuf]) : snbuf;
      var rlength = rbuf.length;
      var slength = sbuf.length;
      var length = 2 + rlength + 2 + slength;
      var rheader = 2;
      var sheader = 2;
      var header = 48;
      var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);
      return der;
    };
    Signature.prototype.toString = function() {
      var buf = this.toDER();
      return buf.toString("hex");
    };
    Signature.isTxDER = function(buf) {
      if (buf.length < 9) {
        return false;
      }
      if (buf.length > 73) {
        return false;
      }
      if (buf[0] !== 48) {
        return false;
      }
      if (buf[1] !== buf.length - 3) {
        return false;
      }
      var nLenR = buf[3];
      if (5 + nLenR >= buf.length) {
        return false;
      }
      var nLenS = buf[5 + nLenR];
      if (nLenR + nLenS + 7 !== buf.length) {
        return false;
      }
      var R = buf.slice(4);
      if (buf[4 - 2] !== 2) {
        return false;
      }
      if (nLenR === 0) {
        return false;
      }
      if (R[0] & 128) {
        return false;
      }
      if (nLenR > 1 && R[0] === 0 && !(R[1] & 128)) {
        return false;
      }
      var S = buf.slice(6 + nLenR);
      if (buf[6 + nLenR - 2] !== 2) {
        return false;
      }
      if (nLenS === 0) {
        return false;
      }
      if (S[0] & 128) {
        return false;
      }
      if (nLenS > 1 && S[0] === 0 && !(S[1] & 128)) {
        return false;
      }
      return true;
    };
    Signature.prototype.hasLowS = function() {
      if (this.s.lt(new BN(1)) || this.s.gt(new BN("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) {
        return false;
      }
      return true;
    };
    Signature.prototype.hasDefinedHashtype = function() {
      if (!JSUtil.isNaturalNumber(this.nhashtype)) {
        return false;
      }
      var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;
      if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {
        return false;
      }
      return true;
    };
    Signature.prototype.toTxFormat = function() {
      var derbuf = this.toDER();
      var buf = Buffer.alloc(1);
      buf.writeUInt8(this.nhashtype, 0);
      return Buffer.concat([derbuf, buf]);
    };
    Signature.SIGHASH_ALL = 1;
    Signature.SIGHASH_NONE = 2;
    Signature.SIGHASH_SINGLE = 3;
    Signature.SIGHASH_ANYONECANPAY = 128;
    module2.exports = Signature;
  }
});

// node_modules/bitcore-lib/lib/crypto/hash.js
var require_hash2 = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/hash.js"(exports2, module2) {
    "use strict";
    var crypto4 = require_crypto();
    var BufferUtil = require_buffer3();
    var $ = require_preconditions();
    var Hash3 = module2.exports;
    Hash3.sha1 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto4.createHash("sha1").update(buf).digest();
    };
    Hash3.sha1.blocksize = 512;
    Hash3.sha256 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto4.createHash("sha256").update(buf).digest();
    };
    Hash3.sha256.blocksize = 512;
    Hash3.sha256sha256 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return Hash3.sha256(Hash3.sha256(buf));
    };
    Hash3.ripemd160 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto4.createHash("ripemd160").update(buf).digest();
    };
    Hash3.sha256ripemd160 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return Hash3.ripemd160(Hash3.sha256(buf));
    };
    Hash3.sha512 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto4.createHash("sha512").update(buf).digest();
    };
    Hash3.sha512.blocksize = 1024;
    Hash3.hmac = function(hashf, data, key) {
      $.checkArgument(BufferUtil.isBuffer(data));
      $.checkArgument(BufferUtil.isBuffer(key));
      $.checkArgument(hashf.blocksize);
      var blocksize = hashf.blocksize / 8;
      if (key.length > blocksize) {
        key = hashf(key);
      } else if (key < blocksize) {
        var fill = Buffer.alloc(blocksize);
        fill.fill(0);
        key.copy(fill);
        key = fill;
      }
      var o_key = Buffer.alloc(blocksize);
      o_key.fill(92);
      var i_key = Buffer.alloc(blocksize);
      i_key.fill(54);
      var o_key_pad = Buffer.alloc(blocksize);
      var i_key_pad = Buffer.alloc(blocksize);
      for (var i = 0; i < blocksize; i++) {
        o_key_pad[i] = o_key[i] ^ key[i];
        i_key_pad[i] = i_key[i] ^ key[i];
      }
      return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));
    };
    Hash3.sha256hmac = function(data, key) {
      return Hash3.hmac(Hash3.sha256, data, key);
    };
    Hash3.sha512hmac = function(data, key) {
      return Hash3.hmac(Hash3.sha512, data, key);
    };
  }
});

// node_modules/bitcore-lib/lib/networks.js
var require_networks = __commonJS({
  "node_modules/bitcore-lib/lib/networks.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var networks = [];
    var networkMaps = {};
    function Network() {
    }
    Network.prototype.toString = function toString3() {
      return this.name;
    };
    function get(arg, keys) {
      if (~networks.indexOf(arg)) {
        return arg;
      }
      if (keys) {
        if (!_.isArray(keys)) {
          keys = [keys];
        }
        var containsArg = function(key) {
          return networks[index2][key] === arg;
        };
        for (var index2 in networks) {
          if (_.some(keys, containsArg)) {
            return networks[index2];
          }
        }
        return void 0;
      }
      if (networkMaps[arg] && networkMaps[arg].length >= 1) {
        return networkMaps[arg][0];
      } else {
        return networkMaps[arg];
      }
    }
    function addNetwork(data) {
      var network = new Network();
      JSUtil.defineImmutable(network, {
        name: data.name,
        alias: data.alias,
        pubkeyhash: data.pubkeyhash,
        privatekey: data.privatekey,
        scripthash: data.scripthash,
        bech32prefix: data.bech32prefix,
        xpubkey: data.xpubkey,
        xprivkey: data.xprivkey
      });
      if (data.networkMagic) {
        JSUtil.defineImmutable(network, {
          networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)
        });
      }
      if (data.port) {
        JSUtil.defineImmutable(network, {
          port: data.port
        });
      }
      if (data.dnsSeeds) {
        JSUtil.defineImmutable(network, {
          dnsSeeds: data.dnsSeeds
        });
      }
      _.each(network, function(value) {
        if (!_.isUndefined(value) && !_.isObject(value)) {
          if (!networkMaps[value]) {
            networkMaps[value] = [];
          }
          networkMaps[value].push(network);
        }
      });
      networks.push(network);
      return network;
    }
    function removeNetwork(network) {
      if (typeof network !== "object") {
        network = get(network);
      }
      for (var i = 0; i < networks.length; i++) {
        if (networks[i] === network) {
          networks.splice(i, 1);
        }
      }
      for (var key in networkMaps) {
        if (networkMaps[key].length) {
          const index2 = networkMaps[key].indexOf(network);
          if (index2 >= 0) {
            networkMaps[key].splice(index2, 1);
          }
          if (networkMaps[key].length === 0) {
            delete networkMaps[key];
          }
        } else if (networkMaps[key] === network) {
          delete networkMaps[key];
        }
      }
    }
    addNetwork({
      name: "livenet",
      alias: "mainnet",
      pubkeyhash: 0,
      privatekey: 128,
      scripthash: 5,
      bech32prefix: "bc",
      xpubkey: 76067358,
      xprivkey: 76066276,
      networkMagic: 4190024921,
      port: 8333,
      dnsSeeds: [
        "seed.bitcoin.sipa.be",
        "dnsseed.bluematt.me",
        "dnsseed.bitcoin.dashjr.org",
        "seed.bitcoinstats.com",
        "seed.bitnodes.io",
        "bitseed.xf2.org"
      ]
    });
    var livenet = get("livenet");
    addNetwork({
      name: "testnet",
      alias: "test",
      pubkeyhash: 111,
      privatekey: 239,
      scripthash: 196,
      bech32prefix: "tb",
      xpubkey: 70617039,
      xprivkey: 70615956,
      networkMagic: 185665799,
      port: 18333,
      dnsSeeds: [
        "testnet-seed.bitcoin.petertodd.org",
        "testnet-seed.bluematt.me",
        "testnet-seed.alexykot.me",
        "testnet-seed.bitcoin.schildbach.de"
      ]
    });
    var testnet = get("testnet");
    addNetwork({
      name: "regtest",
      alias: "dev",
      pubkeyhash: 111,
      privatekey: 239,
      scripthash: 196,
      bech32prefix: "bcrt",
      xpubkey: 70617039,
      xprivkey: 70615956,
      networkMagic: 4206867930,
      port: 18444,
      dnsSeeds: []
    });
    var regtest = get("regtest");
    function enableRegtest() {
      testnet.regtestEnabled = true;
    }
    function disableRegtest() {
      testnet.regtestEnabled = false;
    }
    module2.exports = {
      add: addNetwork,
      remove: removeNetwork,
      defaultNetwork: livenet,
      livenet,
      mainnet: livenet,
      testnet,
      regtest,
      get,
      enableRegtest,
      disableRegtest
    };
  }
});

// node_modules/bitcore-lib/lib/encoding/base58.js
var require_base58 = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/base58.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var bs58 = require_bs58();
    var buffer2 = require_buffer();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
    var Base58 = function Base582(obj) {
      if (!(this instanceof Base582)) {
        return new Base582(obj);
      }
      if (Buffer.isBuffer(obj)) {
        var buf = obj;
        this.fromBuffer(buf);
      } else if (typeof obj === "string") {
        var str = obj;
        this.fromString(str);
      } else if (obj) {
        this.set(obj);
      }
    };
    Base58.validCharacters = function validCharacters(chars) {
      if (buffer2.Buffer.isBuffer(chars)) {
        chars = chars.toString();
      }
      return _.every(_.map(chars, function(char) {
        return _.includes(ALPHABET2, char);
      }));
    };
    Base58.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      return this;
    };
    Base58.encode = function(buf) {
      if (!buffer2.Buffer.isBuffer(buf)) {
        throw new Error("Input should be a buffer");
      }
      return bs58.encode(buf);
    };
    Base58.decode = function(str) {
      if (typeof str !== "string") {
        throw new Error("Input should be a string");
      }
      return Buffer.from(bs58.decode(str));
    };
    Base58.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Base58.prototype.fromString = function(str) {
      var buf = Base58.decode(str);
      this.buf = buf;
      return this;
    };
    Base58.prototype.toBuffer = function() {
      return this.buf;
    };
    Base58.prototype.toString = function() {
      return Base58.encode(this.buf);
    };
    module2.exports = Base58;
  }
});

// node_modules/bitcore-lib/lib/encoding/base58check.js
var require_base58check = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/base58check.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var Base58 = require_base58();
    var buffer2 = require_buffer();
    var sha256sha256 = require_hash2().sha256sha256;
    var Base58Check = function Base58Check2(obj) {
      if (!(this instanceof Base58Check2))
        return new Base58Check2(obj);
      if (Buffer.isBuffer(obj)) {
        var buf = obj;
        this.fromBuffer(buf);
      } else if (typeof obj === "string") {
        var str = obj;
        this.fromString(str);
      } else if (obj) {
        this.set(obj);
      }
    };
    Base58Check.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      return this;
    };
    Base58Check.validChecksum = function validChecksum(data, checksum) {
      if (_.isString(data)) {
        data = Buffer.from(Base58.decode(data));
      }
      if (_.isString(checksum)) {
        checksum = Buffer.from(Base58.decode(checksum));
      }
      if (!checksum) {
        checksum = data.slice(-4);
        data = data.slice(0, -4);
      }
      return Base58Check.checksum(data).toString("hex") === checksum.toString("hex");
    };
    Base58Check.decode = function(s) {
      if (typeof s !== "string")
        throw new Error("Input must be a string");
      var buf = Buffer.from(Base58.decode(s));
      if (buf.length < 4)
        throw new Error("Input string too short");
      var data = buf.slice(0, -4);
      var csum = buf.slice(-4);
      var hash2 = sha256sha256(data);
      var hash4 = hash2.slice(0, 4);
      if (csum.toString("hex") !== hash4.toString("hex"))
        throw new Error("Checksum mismatch");
      return data;
    };
    Base58Check.checksum = function(buffer3) {
      return sha256sha256(buffer3).slice(0, 4);
    };
    Base58Check.encode = function(buf) {
      if (!Buffer.isBuffer(buf))
        throw new Error("Input must be a buffer");
      var checkedBuf = Buffer.alloc(buf.length + 4);
      var hash2 = Base58Check.checksum(buf);
      buf.copy(checkedBuf);
      hash2.copy(checkedBuf, buf.length);
      return Base58.encode(checkedBuf);
    };
    Base58Check.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Base58Check.prototype.fromString = function(str) {
      var buf = Base58Check.decode(str);
      this.buf = buf;
      return this;
    };
    Base58Check.prototype.toBuffer = function() {
      return this.buf;
    };
    Base58Check.prototype.toString = function() {
      return Base58Check.encode(this.buf);
    };
    module2.exports = Base58Check;
  }
});

// node_modules/bitcore-lib/node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bitcore-lib/node_modules/bech32/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bech32m = exports2.bech32 = void 0;
    var ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET2.length; z++) {
      const x = ALPHABET2.charAt(z);
      ALPHABET_MAP[x] = z;
    }
    function polymodStep(pre) {
      const b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad2) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes2) {
      return convert(bytes2, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode3(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i = 0; i < words.length; ++i) {
          const x = words[i];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET2.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
          const v = chk >> (5 - i) * 5 & 31;
          result += ALPHABET2.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split2);
        const wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
          const c = wordChars.charAt(i);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i + 6 >= wordChars.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode: encode3,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports2.bech32 = getLibraryFromEncoding("bech32");
    exports2.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/bitcore-lib/lib/encoding/bech32.js
var require_bech32 = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/bech32.js"(exports2, module2) {
    "use strict";
    var bech32 = require_dist();
    var decode = function(str) {
      if (typeof str !== "string") {
        throw new Error("Input should be a string");
      }
      var decoded;
      let fromWords = bech32.bech32.fromWords;
      let encoding = encodings.BECH32;
      try {
        decoded = bech32.bech32.decode(str);
      } catch (e) {
        if (e.message.indexOf("Invalid checksum") > -1) {
          decoded = bech32.bech32m.decode(str);
          encoding = encodings.BECH32M;
          fromWords = bech32.bech32m.fromWords;
        } else {
          throw e;
        }
      }
      const version = decoded.words[0];
      if (version >= 1 && encoding !== encodings.BECH32M) {
        throw new Error("Version 1+ witness address must use Bech32m checksum");
      }
      return {
        prefix: decoded.prefix,
        data: Buffer.from(fromWords(decoded.words.slice(1))),
        version
      };
    };
    var encode3 = function(prefix, version, data, encoding) {
      if (typeof prefix !== "string") {
        throw new Error("Prefix should be a string");
      }
      if (typeof version !== "number") {
        throw new Error("version should be a number");
      }
      if (encoding && typeof encoding == "string") {
        encoding = encodings[encoding.toUpperCase()] || -1;
      }
      if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {
        throw new Error("Invalid encoding specified");
      }
      let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;
      let words = b32Variety.toWords(data);
      words.unshift(version);
      return b32Variety.encode(prefix, words);
    };
    var encodings = {
      BECH32: 1,
      BECH32M: 2
    };
    module2.exports = { decode, encode: encode3, encodings };
  }
});

// node_modules/bitcore-lib/lib/encoding/bufferreader.js
var require_bufferreader = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/bufferreader.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var BN = require_bn2();
    var BufferReader = function BufferReader2(buf) {
      if (!(this instanceof BufferReader2)) {
        return new BufferReader2(buf);
      }
      if (_.isUndefined(buf)) {
        return;
      }
      if (Buffer.isBuffer(buf)) {
        this.set({
          buf
        });
      } else if (_.isString(buf)) {
        this.set({
          buf: Buffer.from(buf, "hex")
        });
      } else if (_.isObject(buf)) {
        var obj = buf;
        this.set(obj);
      } else {
        throw new TypeError("Unrecognized argument for BufferReader");
      }
    };
    BufferReader.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      this.pos = obj.pos || this.pos || 0;
      return this;
    };
    BufferReader.prototype.eof = function() {
      if (this.buf) {
        return this.pos >= this.buf.length;
      } else {
        return true;
      }
    };
    BufferReader.prototype.finished = BufferReader.prototype.eof;
    BufferReader.prototype.read = function(len) {
      $.checkArgument(!_.isUndefined(len), "Must specify a length");
      var buf = this.buf.slice(this.pos, this.pos + len);
      this.pos = this.pos + len;
      return buf;
    };
    BufferReader.prototype.readAll = function() {
      var buf = this.buf.slice(this.pos, this.buf.length);
      this.pos = this.buf.length;
      return buf;
    };
    BufferReader.prototype.readUInt8 = function() {
      var val = this.buf.readUInt8(this.pos);
      this.pos = this.pos + 1;
      return val;
    };
    BufferReader.prototype.readUInt16BE = function() {
      var val = this.buf.readUInt16BE(this.pos);
      this.pos = this.pos + 2;
      return val;
    };
    BufferReader.prototype.readUInt16LE = function() {
      var val = this.buf.readUInt16LE(this.pos);
      this.pos = this.pos + 2;
      return val;
    };
    BufferReader.prototype.readUInt32BE = function() {
      var val = this.buf.readUInt32BE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readUInt32LE = function() {
      var val = this.buf.readUInt32LE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readInt32LE = function() {
      var val = this.buf.readInt32LE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readUInt64BEBN = function() {
      var buf = this.buf.slice(this.pos, this.pos + 8);
      var bn = BN.fromBuffer(buf);
      this.pos = this.pos + 8;
      return bn;
    };
    BufferReader.prototype.readUInt64LEBN = function() {
      var second = this.buf.readUInt32LE(this.pos);
      var first = this.buf.readUInt32LE(this.pos + 4);
      var combined = first * 4294967296 + second;
      var bn;
      if (combined <= 9007199254740991) {
        bn = new BN(combined);
      } else {
        var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
        bn = new BN(data, 10, "le");
      }
      this.pos = this.pos + 8;
      return bn;
    };
    BufferReader.prototype.readVarintNum = function() {
      var first = this.readUInt8();
      switch (first) {
        case 253:
          return this.readUInt16LE();
        case 254:
          return this.readUInt32LE();
        case 255:
          var bn = this.readUInt64LEBN();
          var n = bn.toNumber();
          if (n <= Math.pow(2, 53)) {
            return n;
          } else {
            throw new Error("number too large to retain precision - use readVarintBN");
          }
          break;
        default:
          return first;
      }
    };
    BufferReader.prototype.readVarLengthBuffer = function() {
      var len = this.readVarintNum();
      var buf = this.read(len);
      $.checkState(buf.length === len, "Invalid length while reading varlength buffer. Expected to read: " + len + " and read " + buf.length);
      return buf;
    };
    BufferReader.prototype.readVarintBuf = function() {
      var first = this.buf.readUInt8(this.pos);
      switch (first) {
        case 253:
          return this.read(1 + 2);
        case 254:
          return this.read(1 + 4);
        case 255:
          return this.read(1 + 8);
        default:
          return this.read(1);
      }
    };
    BufferReader.prototype.readVarintBN = function() {
      var first = this.readUInt8();
      switch (first) {
        case 253:
          return new BN(this.readUInt16LE());
        case 254:
          return new BN(this.readUInt32LE());
        case 255:
          return this.readUInt64LEBN();
        default:
          return new BN(first);
      }
    };
    BufferReader.prototype.reverse = function() {
      var buf = Buffer.alloc(this.buf.length);
      for (var i = 0; i < buf.length; i++) {
        buf[i] = this.buf[this.buf.length - 1 - i];
      }
      this.buf = buf;
      return this;
    };
    BufferReader.prototype.readReverse = function(len) {
      if (_.isUndefined(len)) {
        len = this.buf.length;
      }
      var buf = this.buf.slice(this.pos, this.pos + len);
      this.pos = this.pos + len;
      return BufferUtil.reverse(buf);
    };
    module2.exports = BufferReader;
  }
});

// node_modules/bitcore-lib/lib/encoding/bufferwriter.js
var require_bufferwriter = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/bufferwriter.js"(exports2, module2) {
    "use strict";
    var bufferUtil = require_buffer3();
    var assert2 = require_assert();
    var BufferWriter = function BufferWriter2(obj) {
      if (!(this instanceof BufferWriter2))
        return new BufferWriter2(obj);
      this.bufLen = 0;
      if (obj)
        this.set(obj);
      else
        this.bufs = [];
    };
    BufferWriter.prototype.set = function(obj) {
      this.bufs = obj.bufs || this.bufs || [];
      this.bufLen = this.bufs.reduce(function(prev, buf) {
        return prev + buf.length;
      }, 0);
      return this;
    };
    BufferWriter.prototype.toBuffer = function() {
      return this.concat();
    };
    BufferWriter.prototype.concat = function() {
      return Buffer.concat(this.bufs, this.bufLen);
    };
    BufferWriter.prototype.write = function(buf) {
      assert2(bufferUtil.isBuffer(buf));
      this.bufs.push(buf);
      this.bufLen += buf.length;
      return this;
    };
    BufferWriter.prototype.writeReverse = function(buf) {
      assert2(bufferUtil.isBuffer(buf));
      this.bufs.push(bufferUtil.reverse(buf));
      this.bufLen += buf.length;
      return this;
    };
    BufferWriter.prototype.writeUInt8 = function(n) {
      var buf = Buffer.alloc(1);
      buf.writeUInt8(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt16BE = function(n) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16BE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt16LE = function(n) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt32BE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32BE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeInt32LE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeInt32LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt32LE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt64BEBN = function(bn) {
      var buf = bn.toBuffer({ size: 8 });
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt64LEBN = function(bn) {
      var buf = bn.toBuffer({ size: 8 });
      this.writeReverse(buf);
      return this;
    };
    BufferWriter.prototype.writeVarintNum = function(n) {
      var buf = BufferWriter.varintBufNum(n);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeVarintBN = function(bn) {
      var buf = BufferWriter.varintBufBN(bn);
      this.write(buf);
      return this;
    };
    BufferWriter.varintBufNum = function(n) {
      var buf = void 0;
      if (n < 253) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(n, 0);
      } else if (n < 65536) {
        buf = Buffer.alloc(1 + 2);
        buf.writeUInt8(253, 0);
        buf.writeUInt16LE(n, 1);
      } else if (n < 4294967296) {
        buf = Buffer.alloc(1 + 4);
        buf.writeUInt8(254, 0);
        buf.writeUInt32LE(n, 1);
      } else {
        buf = Buffer.alloc(1 + 8);
        buf.writeUInt8(255, 0);
        buf.writeInt32LE(n & -1, 1);
        buf.writeUInt32LE(Math.floor(n / 4294967296), 5);
      }
      return buf;
    };
    BufferWriter.varintBufBN = function(bn) {
      var buf = void 0;
      var n = bn.toNumber();
      if (n < 253) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(n, 0);
      } else if (n < 65536) {
        buf = Buffer.alloc(1 + 2);
        buf.writeUInt8(253, 0);
        buf.writeUInt16LE(n, 1);
      } else if (n < 4294967296) {
        buf = Buffer.alloc(1 + 4);
        buf.writeUInt8(254, 0);
        buf.writeUInt32LE(n, 1);
      } else {
        var bw = new BufferWriter();
        bw.writeUInt8(255);
        bw.writeUInt64LEBN(bn);
        var buf = bw.concat();
      }
      return buf;
    };
    module2.exports = BufferWriter;
  }
});

// node_modules/bitcore-lib/lib/opcode.js
var require_opcode = __commonJS({
  "node_modules/bitcore-lib/lib/opcode.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    function Opcode(num) {
      if (!(this instanceof Opcode)) {
        return new Opcode(num);
      }
      var value;
      if (_.isNumber(num)) {
        value = num;
      } else if (_.isString(num)) {
        value = Opcode.map[num];
      } else {
        throw new TypeError('Unrecognized num type: "' + typeof num + '" for Opcode');
      }
      JSUtil.defineImmutable(this, {
        num: value
      });
      return this;
    }
    Opcode.fromBuffer = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return new Opcode(Number("0x" + buf.toString("hex")));
    };
    Opcode.fromNumber = function(num) {
      $.checkArgument(_.isNumber(num));
      return new Opcode(num);
    };
    Opcode.fromString = function(str) {
      $.checkArgument(_.isString(str));
      var value = Opcode.map[str];
      if (typeof value === "undefined") {
        throw new TypeError("Invalid opcodestr");
      }
      return new Opcode(value);
    };
    Opcode.prototype.toHex = function() {
      return this.num.toString(16);
    };
    Opcode.prototype.toBuffer = function() {
      return Buffer.from(this.toHex(), "hex");
    };
    Opcode.prototype.toNumber = function() {
      return this.num;
    };
    Opcode.prototype.toString = function() {
      var str = Opcode.reverseMap[this.num];
      if (typeof str === "undefined") {
        throw new Error("Opcode does not have a string representation");
      }
      return str;
    };
    Opcode.smallInt = function(n) {
      $.checkArgument(_.isNumber(n), "Invalid Argument: n should be number");
      $.checkArgument(n >= 0 && n <= 16, "Invalid Argument: n must be between 0 and 16");
      if (n === 0) {
        return Opcode("OP_0");
      }
      return new Opcode(Opcode.map.OP_1 + n - 1);
    };
    Opcode.map = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_NOP3: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    Opcode.reverseMap = [];
    for (k in Opcode.map) {
      Opcode.reverseMap[Opcode.map[k]] = k;
    }
    var k;
    _.extend(Opcode, Opcode.map);
    Opcode.isSmallIntOp = function(opcode) {
      if (opcode instanceof Opcode) {
        opcode = opcode.toNumber();
      }
      return opcode === Opcode.map.OP_0 || opcode >= Opcode.map.OP_1 && opcode <= Opcode.map.OP_16;
    };
    Opcode.prototype.inspect = function() {
      return "<Opcode: " + this.toString() + ", hex: " + this.toHex() + ", decimal: " + this.num + ">";
    };
    module2.exports = Opcode;
  }
});

// node_modules/bitcore-lib/lib/script/script.js
var require_script = __commonJS({
  "node_modules/bitcore-lib/lib/script/script.js"(exports2, module2) {
    "use strict";
    var Address2 = require_address();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash3 = require_hash2();
    var Opcode = require_opcode();
    var PublicKey = require_publickey2();
    var Signature = require_signature3();
    var Networks = require_networks();
    var $ = require_preconditions();
    var _ = require_lodash();
    var errors = require_errors();
    var buffer2 = require_buffer();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Script = function Script2(from) {
      if (!(this instanceof Script2)) {
        return new Script2(from);
      }
      this.chunks = [];
      if (BufferUtil.isBuffer(from)) {
        return Script2.fromBuffer(from);
      } else if (from instanceof Address2) {
        return Script2.fromAddress(from);
      } else if (from instanceof Script2) {
        return Script2.fromBuffer(from.toBuffer());
      } else if (typeof from === "string") {
        return Script2.fromString(from);
      } else if (_.isObject(from) && Array.isArray(from.chunks)) {
        this.set(from);
      }
    };
    Script.VERIFY_TAPROOT = 1 << 17;
    Script.prototype.set = function(obj) {
      $.checkArgument(_.isObject(obj));
      $.checkArgument(Array.isArray(obj.chunks));
      this.chunks = obj.chunks;
      return this;
    };
    Script.fromBuffer = function(buffer3) {
      var script = new Script();
      script.chunks = [];
      var br = new BufferReader(buffer3);
      while (!br.finished()) {
        try {
          var opcodenum = br.readUInt8();
          var len, buf;
          if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
            len = opcodenum;
            script.chunks.push({
              buf: br.read(len),
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA1) {
            len = br.readUInt8();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA2) {
            len = br.readUInt16LE();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA4) {
            len = br.readUInt32LE();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else {
            script.chunks.push({
              opcodenum
            });
          }
        } catch (e) {
          if (e instanceof RangeError) {
            throw new errors.Script.InvalidBuffer(buffer3.toString("hex"));
          }
          throw e;
        }
      }
      return script;
    };
    Script.prototype.toBuffer = function() {
      var bw = new BufferWriter();
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        var opcodenum = chunk.opcodenum;
        bw.writeUInt8(chunk.opcodenum);
        if (chunk.buf) {
          if (opcodenum < Opcode.OP_PUSHDATA1) {
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA1) {
            bw.writeUInt8(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA2) {
            bw.writeUInt16LE(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA4) {
            bw.writeUInt32LE(chunk.len);
            bw.write(chunk.buf);
          }
        }
      }
      return bw.concat();
    };
    Script.fromASM = function(str) {
      var script = new Script();
      script.chunks = [];
      var tokens = str.split(" ");
      var i = 0;
      while (i < tokens.length) {
        var token = tokens[i];
        var opcode = Opcode(token);
        var opcodenum = opcode.toNumber();
        if (opcodenum == null) {
          var buf = Buffer.from(tokens[i], "hex");
          script.chunks.push({
            buf,
            len: buf.length,
            opcodenum: buf.length
          });
          i = i + 1;
        } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {
          script.chunks.push({
            buf: Buffer.from(tokens[i + 2], "hex"),
            len: parseInt(tokens[i + 1]),
            opcodenum
          });
          i = i + 3;
        } else {
          script.chunks.push({
            opcodenum
          });
          i = i + 1;
        }
      }
      return script;
    };
    Script.fromHex = function(str) {
      return new Script(Buffer.from(str, "hex"));
    };
    Script.fromString = function(str) {
      if (JSUtil.isHexa(str) || str.length === 0) {
        return new Script(Buffer.from(str, "hex"));
      }
      var script = new Script();
      script.chunks = [];
      var tokens = str.split(" ");
      var i = 0;
      while (i < tokens.length) {
        var token = tokens[i];
        var opcode = Opcode(token);
        var opcodenum = opcode.toNumber();
        if (opcodenum == null) {
          opcodenum = parseInt(token);
          if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
            script.chunks.push({
              buf: Buffer.from(tokens[i + 1].slice(2), "hex"),
              len: opcodenum,
              opcodenum
            });
            i = i + 2;
          } else {
            throw new Error("Invalid script: " + JSON.stringify(str));
          }
        } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {
          if (tokens[i + 2].slice(0, 2) !== "0x") {
            throw new Error("Pushdata data must start with 0x");
          }
          script.chunks.push({
            buf: Buffer.from(tokens[i + 2].slice(2), "hex"),
            len: parseInt(tokens[i + 1]),
            opcodenum
          });
          i = i + 3;
        } else {
          script.chunks.push({
            opcodenum
          });
          i = i + 1;
        }
      }
      return script;
    };
    Script.prototype._chunkToString = function(chunk, type) {
      var opcodenum = chunk.opcodenum;
      var asm = type === "asm";
      var str = "";
      if (!chunk.buf) {
        if (typeof Opcode.reverseMap[opcodenum] !== "undefined") {
          if (asm) {
            if (opcodenum === 0) {
              str = str + " 0";
            } else if (opcodenum === 79) {
              str = str + " -1";
            } else {
              str = str + " " + Opcode(opcodenum).toString();
            }
          } else {
            str = str + " " + Opcode(opcodenum).toString();
          }
        } else {
          var numstr = opcodenum.toString(16);
          if (numstr.length % 2 !== 0) {
            numstr = "0" + numstr;
          }
          if (asm) {
            str = str + " " + numstr;
          } else {
            str = str + " 0x" + numstr;
          }
        }
      } else {
        if (!asm && opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {
          str = str + " " + Opcode(opcodenum).toString();
        }
        if (chunk.len > 0) {
          if (asm) {
            str = str + " " + chunk.buf.toString("hex");
          } else {
            str = str + " " + chunk.len + " 0x" + chunk.buf.toString("hex");
          }
        }
      }
      return str;
    };
    Script.prototype.toASM = function() {
      var str = "";
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        str += this._chunkToString(chunk, "asm");
      }
      return str.substr(1);
    };
    Script.prototype.toString = function() {
      var str = "";
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        str += this._chunkToString(chunk);
      }
      return str.substr(1);
    };
    Script.prototype.toHex = function() {
      return this.toBuffer().toString("hex");
    };
    Script.prototype.inspect = function() {
      return "<Script: " + this.toString() + ">";
    };
    Script.prototype.isPublicKeyHashOut = function() {
      return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);
    };
    Script.prototype.isPublicKeyHashIn = function() {
      if (this.chunks.length === 2) {
        var signatureBuf = this.chunks[0].buf;
        var pubkeyBuf = this.chunks[1].buf;
        if (signatureBuf && signatureBuf.length && signatureBuf[0] === 48 && pubkeyBuf && pubkeyBuf.length) {
          var version = pubkeyBuf[0];
          if ((version === 4 || version === 6 || version === 7) && pubkeyBuf.length === 65) {
            return true;
          } else if ((version === 3 || version === 2) && pubkeyBuf.length === 33) {
            return true;
          }
        }
      }
      return false;
    };
    Script.prototype.getPublicKey = function() {
      $.checkState(this.isPublicKeyOut(), "Can't retrieve PublicKey from a non-PK output");
      return this.chunks[0].buf;
    };
    Script.prototype.getPublicKeyHash = function() {
      if (this.isPublicKeyHashOut()) {
        return this.chunks[2].buf;
      } else if (this.isWitnessPublicKeyHashOut()) {
        return this.chunks[1].buf;
      } else {
        throw new Error("Can't retrieve PublicKeyHash from a non-PKH output");
      }
    };
    Script.prototype.isPublicKeyOut = function() {
      if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {
        var pubkeyBuf = this.chunks[0].buf;
        var version = pubkeyBuf[0];
        var isVersion = false;
        if ((version === 4 || version === 6 || version === 7) && pubkeyBuf.length === 65) {
          isVersion = true;
        } else if ((version === 3 || version === 2) && pubkeyBuf.length === 33) {
          isVersion = true;
        }
        if (isVersion) {
          return PublicKey.isValid(pubkeyBuf);
        }
      }
      return false;
    };
    Script.prototype.isPublicKeyIn = function() {
      if (this.chunks.length === 1) {
        var signatureBuf = this.chunks[0].buf;
        if (signatureBuf && signatureBuf.length && signatureBuf[0] === 48) {
          return true;
        }
      }
      return false;
    };
    Script.prototype.isScriptHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 20 && buf[buf.length - 1] === Opcode.OP_EQUAL;
    };
    Script.prototype.isWitnessScriptHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32;
    };
    Script.prototype.isWitnessPublicKeyHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20;
    };
    Script.prototype.isTaproot = function() {
      var buf = this.toBuffer();
      return buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32;
    };
    Script.prototype.isWitnessProgram = function(values) {
      if (!values) {
        values = {};
      }
      var buf = this.toBuffer();
      if (buf.length < 4 || buf.length > 42) {
        return false;
      }
      if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {
        return false;
      }
      if (buf.length === buf[1] + 2) {
        values.version = buf[0];
        values.program = buf.slice(2, buf.length);
        return true;
      }
      return false;
    };
    Script.prototype.isScriptHashIn = function() {
      if (this.chunks.length <= 1) {
        return false;
      }
      var redeemChunk = this.chunks[this.chunks.length - 1];
      var redeemBuf = redeemChunk.buf;
      if (!redeemBuf) {
        return false;
      }
      var redeemScript;
      try {
        redeemScript = Script.fromBuffer(redeemBuf);
      } catch (e) {
        if (e instanceof errors.Script.InvalidBuffer) {
          return false;
        }
        throw e;
      }
      var type = redeemScript.classify();
      return type !== Script.types.UNKNOWN;
    };
    Script.prototype.isMultisigOut = function() {
      return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
        return obj.buf && BufferUtil.isBuffer(obj.buf);
      }) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;
    };
    Script.prototype.isMultisigIn = function() {
      return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function(obj) {
        return obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf);
      });
    };
    Script.prototype.isDataOut = function() {
      return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);
    };
    Script.prototype.getData = function() {
      if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {
        if (this.chunks[1] == null) {
          return Buffer.alloc(0);
        } else {
          return Buffer.from(this.chunks[1].buf);
        }
      }
      if (this.isPublicKeyHashOut()) {
        return Buffer.from(this.chunks[2].buf);
      }
      throw new Error("Unrecognized script type to get data from");
    };
    Script.prototype.isPushOnly = function() {
      return this.chunks.every(function(chunk) {
        return chunk.opcodenum <= Opcode.OP_16;
      });
    };
    Script.types = {};
    Script.types.UNKNOWN = "Unknown";
    Script.types.PUBKEY_OUT = "Pay to public key";
    Script.types.PUBKEY_IN = "Spend from public key";
    Script.types.PUBKEYHASH_OUT = "Pay to public key hash";
    Script.types.PUBKEYHASH_IN = "Spend from public key hash";
    Script.types.SCRIPTHASH_OUT = "Pay to script hash";
    Script.types.SCRIPTHASH_IN = "Spend from script hash";
    Script.types.MULTISIG_OUT = "Pay to multisig";
    Script.types.MULTISIG_IN = "Spend from multisig";
    Script.types.DATA_OUT = "Data push";
    Script.OP_RETURN_STANDARD_SIZE = 80;
    Script.prototype.classify = function() {
      if (this._isInput) {
        return this.classifyInput();
      } else if (this._isOutput) {
        return this.classifyOutput();
      } else {
        var outputType = this.classifyOutput();
        return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();
      }
    };
    Script.outputIdentifiers = {};
    Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
    Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
    Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
    Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
    Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;
    Script.prototype.classifyOutput = function() {
      for (var type in Script.outputIdentifiers) {
        if (Script.outputIdentifiers[type].bind(this)()) {
          return Script.types[type];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.inputIdentifiers = {};
    Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
    Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
    Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
    Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;
    Script.prototype.classifyInput = function() {
      for (var type in Script.inputIdentifiers) {
        if (Script.inputIdentifiers[type].bind(this)()) {
          return Script.types[type];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.prototype.isStandard = function() {
      return this.classify() !== Script.types.UNKNOWN;
    };
    Script.prototype.prepend = function(obj) {
      this._addByType(obj, true);
      return this;
    };
    Script.prototype.equals = function(script) {
      $.checkState(script instanceof Script, "Must provide another script");
      if (this.chunks.length !== script.chunks.length) {
        return false;
      }
      var i;
      for (i = 0; i < this.chunks.length; i++) {
        if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {
          return false;
        }
        if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {
          return false;
        } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {
          return false;
        }
      }
      return true;
    };
    Script.prototype.add = function(obj) {
      this._addByType(obj, false);
      return this;
    };
    Script.prototype._addByType = function(obj, prepend) {
      if (typeof obj === "string") {
        this._addOpcode(obj, prepend);
      } else if (typeof obj === "number") {
        this._addOpcode(obj, prepend);
      } else if (obj instanceof Opcode) {
        this._addOpcode(obj, prepend);
      } else if (BufferUtil.isBuffer(obj)) {
        this._addBuffer(obj, prepend);
      } else if (obj instanceof Script) {
        this.chunks = this.chunks.concat(obj.chunks);
      } else if (typeof obj === "object") {
        this._insertAtPosition(obj, prepend);
      } else {
        throw new Error("Invalid script chunk");
      }
    };
    Script.prototype._insertAtPosition = function(op, prepend) {
      if (prepend) {
        this.chunks.unshift(op);
      } else {
        this.chunks.push(op);
      }
    };
    Script.prototype._addOpcode = function(opcode, prepend) {
      var op;
      if (typeof opcode === "number") {
        op = opcode;
      } else if (opcode instanceof Opcode) {
        op = opcode.toNumber();
      } else {
        op = Opcode(opcode).toNumber();
      }
      this._insertAtPosition({
        opcodenum: op
      }, prepend);
      return this;
    };
    Script.prototype._addBuffer = function(buf, prepend) {
      var opcodenum;
      var len = buf.length;
      if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
        opcodenum = len;
      } else if (len < Math.pow(2, 8)) {
        opcodenum = Opcode.OP_PUSHDATA1;
      } else if (len < Math.pow(2, 16)) {
        opcodenum = Opcode.OP_PUSHDATA2;
      } else if (len < Math.pow(2, 32)) {
        opcodenum = Opcode.OP_PUSHDATA4;
      } else {
        throw new Error("You can't push that much data");
      }
      this._insertAtPosition({
        buf,
        len,
        opcodenum
      }, prepend);
      return this;
    };
    Script.prototype.hasCodeseparators = function() {
      for (var i = 0; i < this.chunks.length; i++) {
        if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {
          return true;
        }
      }
      return false;
    };
    Script.prototype.removeCodeseparators = function() {
      var chunks = [];
      for (var i = 0; i < this.chunks.length; i++) {
        if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
          chunks.push(this.chunks[i]);
        }
      }
      this.chunks = chunks;
      return this;
    };
    Script.buildMultisigOut = function(publicKeys, threshold, opts) {
      $.checkArgument(
        threshold <= publicKeys.length,
        "Number of required signatures must be less than or equal to the number of public keys"
      );
      opts = opts || {};
      var script = new Script();
      script.add(Opcode.smallInt(threshold));
      publicKeys = publicKeys.map(PublicKey);
      var sorted = publicKeys;
      if (!opts.noSorting) {
        sorted = _.sortBy(publicKeys, function(publicKey2) {
          return publicKey2.toString("hex");
        });
      }
      for (var i = 0; i < sorted.length; i++) {
        var publicKey = sorted[i];
        script.add(publicKey.toBuffer());
      }
      script.add(Opcode.smallInt(publicKeys.length));
      script.add(Opcode.OP_CHECKMULTISIG);
      return script;
    };
    Script.buildWitnessMultisigOutFromScript = function(script) {
      if (script instanceof Script) {
        var s = new Script();
        s.add(Opcode.OP_0);
        s.add(Hash3.sha256(script.toBuffer()));
        return s;
      } else {
        throw new TypeError("First argument is expected to be a p2sh script");
      }
    };
    Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $.checkArgument(Array.isArray(pubkeys));
      $.checkArgument(!isNaN(threshold));
      $.checkArgument(Array.isArray(signatures));
      opts = opts || {};
      var s = new Script();
      s.add(Opcode.OP_0);
      for (const signature of signatures) {
        $.checkArgument(BufferUtil.isBuffer(signature), "Signatures must be an array of Buffers");
        s.add(signature);
      }
      return s;
    };
    Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $.checkArgument(Array.isArray(pubkeys));
      $.checkArgument(!isNaN(threshold));
      $.checkArgument(Array.isArray(signatures));
      opts = opts || {};
      var s = new Script();
      s.add(Opcode.OP_0);
      for (const signature of signatures) {
        $.checkArgument(BufferUtil.isBuffer(signature), "Signatures must be an array of Buffers");
        s.add(signature);
      }
      s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
      return s;
    };
    Script.buildPublicKeyHashOut = function(to) {
      $.checkArgument(to != null);
      $.checkArgument(to instanceof PublicKey || to instanceof Address2 || typeof to === "string");
      if (to instanceof PublicKey) {
        to = to.toAddress();
      } else if (typeof to === "string") {
        to = new Address2(to);
      }
      var s = new Script();
      s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);
      s._network = to.network;
      return s;
    };
    Script.buildWitnessV0Out = function(to) {
      $.checkArgument(to != null);
      $.checkArgument(to instanceof PublicKey || to instanceof Address2 || typeof to === "string");
      if (to instanceof PublicKey) {
        to = to.toAddress(null, Address2.PayToWitnessPublicKeyHash);
      } else if (typeof to === "string") {
        to = new Address2(to);
      }
      var s = new Script();
      s.add(Opcode.OP_0).add(to.hashBuffer);
      s._network = to.network;
      return s;
    };
    Script.buildPublicKeyOut = function(pubkey) {
      $.checkArgument(pubkey instanceof PublicKey);
      var s = new Script();
      s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);
      return s;
    };
    Script.buildDataOut = function(data, encoding) {
      $.checkArgument(data == null || typeof data === "string" || BufferUtil.isBuffer(data));
      if (typeof data === "string") {
        data = Buffer.from(data, encoding);
      }
      var s = new Script();
      s.add(Opcode.OP_RETURN);
      if (data != null) {
        s.add(data);
      }
      return s;
    };
    Script.buildScriptHashOut = function(script) {
      $.checkArgument(script instanceof Script || script instanceof Address2 && script.isPayToScriptHash());
      var s = new Script();
      s.add(Opcode.OP_HASH160).add(script instanceof Address2 ? script.hashBuffer : Hash3.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);
      s._network = script._network || script.network;
      return s;
    };
    Script.buildPublicKeyIn = function(signature, sigtype) {
      $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
      $.checkArgument(sigtype == null || !isNaN(sigtype));
      if (signature instanceof Signature) {
        signature = signature.toBuffer();
      }
      var script = new Script();
      script.add(BufferUtil.concat([
        signature,
        BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
      ]));
      return script;
    };
    Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {
      $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
      $.checkArgument(sigtype == null || !isNaN(sigtype));
      if (signature instanceof Signature) {
        signature = signature.toBuffer();
      }
      var script = new Script().add(BufferUtil.concat([
        signature,
        BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
      ])).add(new PublicKey(publicKey).toBuffer());
      return script;
    };
    Script.empty = function() {
      return new Script();
    };
    Script.prototype.toScriptHashOut = function() {
      return Script.buildScriptHashOut(this);
    };
    Script.fromAddress = function(address) {
      address = Address2(address);
      if (address.isPayToScriptHash()) {
        return Script.buildScriptHashOut(address);
      } else if (address.isPayToPublicKeyHash()) {
        return Script.buildPublicKeyHashOut(address);
      } else if (address.isPayToWitnessPublicKeyHash()) {
        return Script.buildWitnessV0Out(address);
      } else if (address.isPayToWitnessScriptHash()) {
        return Script.buildWitnessV0Out(address);
      }
      throw new errors.Script.UnrecognizedAddress(address);
    };
    Script.prototype.getAddressInfo = function(opts) {
      if (this._isInput) {
        return this._getInputAddressInfo();
      } else if (this._isOutput) {
        return this._getOutputAddressInfo();
      } else {
        var info = this._getOutputAddressInfo();
        if (!info) {
          return this._getInputAddressInfo();
        }
        return info;
      }
    };
    Script.prototype._getOutputAddressInfo = function() {
      var info = {};
      if (this.isScriptHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToScriptHash;
      } else if (this.isPublicKeyHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToPublicKeyHash;
      } else if (this.isWitnessScriptHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToWitnessScriptHash;
      } else if (this.isWitnessPublicKeyHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToWitnessPublicKeyHash;
      } else if (this.isTaproot()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToTaproot;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype._getInputAddressInfo = function() {
      var info = {};
      if (this.isPublicKeyHashIn()) {
        info.hashBuffer = Hash3.sha256ripemd160(this.chunks[1].buf);
        info.type = Address2.PayToPublicKeyHash;
      } else if (this.isScriptHashIn()) {
        info.hashBuffer = Hash3.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
        info.type = Address2.PayToScriptHash;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype.toAddress = function(network) {
      var info = this.getAddressInfo();
      if (!info) {
        return false;
      }
      info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
      return new Address2(info);
    };
    Script.prototype.findAndDelete = function(script) {
      var buf = script.toBuffer();
      var hex = buf.toString("hex");
      for (var i = 0; i < this.chunks.length; i++) {
        var script2 = Script({
          chunks: [this.chunks[i]]
        });
        var buf2 = script2.toBuffer();
        var hex2 = buf2.toString("hex");
        if (hex === hex2) {
          this.chunks.splice(i, 1);
        }
      }
      return this;
    };
    Script.prototype.checkMinimalPush = function(i) {
      var chunk = this.chunks[i];
      var buf = chunk.buf;
      var opcodenum = chunk.opcodenum;
      if (!buf) {
        return true;
      }
      if (buf.length === 0) {
        return opcodenum === Opcode.OP_0;
      } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
        return opcodenum === Opcode.OP_1 + (buf[0] - 1);
      } else if (buf.length === 1 && buf[0] === 129) {
        return opcodenum === Opcode.OP_1NEGATE;
      } else if (buf.length <= 75) {
        return opcodenum === buf.length;
      } else if (buf.length <= 255) {
        return opcodenum === Opcode.OP_PUSHDATA1;
      } else if (buf.length <= 65535) {
        return opcodenum === Opcode.OP_PUSHDATA2;
      }
      return true;
    };
    Script.prototype._decodeOP_N = function(opcode) {
      if (opcode === Opcode.OP_0) {
        return 0;
      } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {
        return opcode - (Opcode.OP_1 - 1);
      } else {
        throw new Error("Invalid opcode: " + JSON.stringify(opcode));
      }
    };
    Script.prototype.getSignatureOperationsCount = function(accurate) {
      accurate = accurate == null ? true : accurate;
      var n = 0;
      var lastOpcode = Opcode.OP_INVALIDOPCODE;
      for (const chunk of this.chunks) {
        var opcode = chunk.opcodenum;
        if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {
          n++;
        } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {
          if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {
            n += this._decodeOP_N(lastOpcode);
          } else {
            n += 20;
          }
        }
        lastOpcode = opcode;
      }
      return n;
    };
    module2.exports = Script;
  }
});

// node_modules/buffer-compare/index.js
var require_buffer_compare = __commonJS({
  "node_modules/buffer-compare/index.js"(exports2, module2) {
    module2.exports = function(a, b) {
      if (typeof a.compare === "function")
        return a.compare(b);
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      var i = 0;
      var len = Math.min(x, y);
      while (i < len) {
        if (a[i] !== b[i])
          break;
        ++i;
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
  }
});

// node_modules/bitcore-lib/lib/transaction/output.js
var require_output = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/output.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var BN = require_bn2();
    var buffer2 = require_buffer();
    var bufferUtil = require_buffer3();
    var JSUtil = require_js();
    var BufferWriter = require_bufferwriter();
    var Script = require_script2();
    var $ = require_preconditions();
    var errors = require_errors();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function Output(args) {
      if (!(this instanceof Output)) {
        return new Output(args);
      }
      if (_.isObject(args)) {
        this.satoshis = args.satoshis;
        if (bufferUtil.isBuffer(args.script)) {
          this._scriptBuffer = args.script;
        } else {
          var script;
          if (_.isString(args.script) && JSUtil.isHexa(args.script)) {
            script = Buffer.from(args.script, "hex");
          } else {
            script = args.script;
          }
          this.setScript(script);
        }
      } else {
        throw new TypeError("Unrecognized argument for Output");
      }
    }
    Object.defineProperty(Output.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this._script) {
          return this._script;
        } else {
          this.setScriptFromBuffer(this._scriptBuffer);
          return this._script;
        }
      }
    });
    Object.defineProperty(Output.prototype, "satoshis", {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._satoshis;
      },
      set: function(num) {
        if (num instanceof BN) {
          this._satoshisBN = num;
          this._satoshis = num.toNumber();
        } else if (_.isString(num)) {
          this._satoshis = parseInt(num);
          this._satoshisBN = BN.fromNumber(this._satoshis);
        } else {
          $.checkArgument(
            JSUtil.isNaturalNumber(num),
            "Output satoshis is not a natural number"
          );
          this._satoshisBN = BN.fromNumber(num);
          this._satoshis = num;
        }
        $.checkState(
          JSUtil.isNaturalNumber(this._satoshis),
          "Output satoshis is not a natural number"
        );
      }
    });
    Output.prototype.invalidSatoshis = function() {
      if (this._satoshis > MAX_SAFE_INTEGER) {
        return "transaction txout satoshis greater than max safe integer";
      }
      if (this._satoshis !== this._satoshisBN.toNumber()) {
        return "transaction txout satoshis has corrupted value";
      }
      if (this._satoshis < 0) {
        return "transaction txout negative";
      }
      return false;
    };
    Output.prototype.toObject = Output.prototype.toJSON = function toObject() {
      var obj = {
        satoshis: this.satoshis
      };
      obj.script = this._scriptBuffer.toString("hex");
      return obj;
    };
    Output.fromObject = function(data) {
      return new Output(data);
    };
    Output.prototype.setScriptFromBuffer = function(buffer3) {
      this._scriptBuffer = buffer3;
      try {
        this._script = Script.fromBuffer(this._scriptBuffer);
        this._script._isOutput = true;
      } catch (e) {
        if (e instanceof errors.Script.InvalidBuffer) {
          this._script = null;
        } else {
          throw e;
        }
      }
    };
    Output.prototype.setScript = function(script) {
      if (script instanceof Script) {
        this._scriptBuffer = script.toBuffer();
        this._script = script;
        this._script._isOutput = true;
      } else if (_.isString(script)) {
        this._script = Script.fromString(script);
        this._scriptBuffer = this._script.toBuffer();
        this._script._isOutput = true;
      } else if (bufferUtil.isBuffer(script)) {
        this.setScriptFromBuffer(script);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      return this;
    };
    Output.prototype.inspect = function() {
      var scriptStr;
      if (this.script) {
        scriptStr = this.script.inspect();
      } else {
        scriptStr = this._scriptBuffer.toString("hex");
      }
      return "<Output (" + this.satoshis + " sats) " + scriptStr + ">";
    };
    Output.fromBufferReader = function(br) {
      var obj = {};
      obj.satoshis = br.readUInt64LEBN();
      var size3 = br.readVarintNum();
      if (size3 !== 0) {
        obj.script = br.read(size3);
      } else {
        obj.script = Buffer.from([]);
      }
      return new Output(obj);
    };
    Output.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter();
      }
      writer.writeUInt64LEBN(this._satoshisBN);
      var script = this._scriptBuffer;
      writer.writeVarintNum(script.length);
      writer.write(script);
      return writer;
    };
    Output.prototype.calculateSize = function() {
      let result = 8;
      result += BufferWriter.varintBufNum(this._scriptBuffer.length).length;
      result += this._scriptBuffer.length;
      return result;
    };
    module2.exports = Output;
  }
});

// node_modules/bigi/package.json
var require_package3 = __commonJS({
  "node_modules/bigi/package.json"(exports2, module2) {
    module2.exports = {
      name: "bigi",
      version: "1.4.2",
      description: "Big integers.",
      keywords: [
        "cryptography",
        "math",
        "bitcoin",
        "arbitrary",
        "precision",
        "arithmetic",
        "big",
        "integer",
        "int",
        "number",
        "biginteger",
        "bigint",
        "bignumber",
        "decimal",
        "float"
      ],
      devDependencies: {
        coveralls: "^2.11.2",
        istanbul: "^0.3.5",
        jshint: "^2.5.1",
        mocha: "^2.1.0",
        mochify: "^2.1.0"
      },
      repository: {
        url: "https://github.com/cryptocoinjs/bigi",
        type: "git"
      },
      main: "./lib/index.js",
      scripts: {
        "browser-test": "./node_modules/.bin/mochify --wd -R spec",
        test: "./node_modules/.bin/_mocha -- test/*.js",
        jshint: "./node_modules/.bin/jshint --config jshint.json lib/*.js ; true",
        unit: "./node_modules/.bin/mocha",
        coverage: "./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
        coveralls: "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info"
      },
      dependencies: {},
      testling: {
        files: "test/*.js",
        harness: "mocha",
        browsers: [
          "ie/9..latest",
          "firefox/latest",
          "chrome/latest",
          "safari/6.0..latest",
          "iphone/6.0..latest",
          "android-browser/4.2..latest"
        ]
      }
    };
  }
});

// node_modules/bigi/lib/bigi.js
var require_bigi = __commonJS({
  "node_modules/bigi/lib/bigi.js"(exports2, module2) {
    function BigInteger(a, b, c) {
      if (!(this instanceof BigInteger))
        return new BigInteger(a, b, c);
      if (a != null) {
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
      }
    }
    var proto = BigInteger.prototype;
    proto.__bigi = require_package3().version;
    BigInteger.isBigInteger = function(obj, check_ver) {
      return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi);
    };
    var dbits;
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    BigInteger.prototype.am = am1;
    dbits = 26;
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    var DV = BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = new BigInteger();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var self2 = this;
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        self2.fromRadix(s, b);
        return;
      }
      self2.t = 0;
      self2.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          self2[self2.t++] = x;
        else if (sh + k > self2.DB) {
          self2[self2.t - 1] |= (x & (1 << self2.DB - sh) - 1) << sh;
          self2[self2.t++] = x >> self2.DB - sh;
        } else
          self2[self2.t - 1] |= x << sh;
        sh += k;
        if (sh >= self2.DB)
          sh -= self2.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        self2.s = -1;
        if (sh > 0)
          self2[self2.t - 1] |= (1 << self2.DB - sh) - 1 << sh;
      }
      self2.clamp();
      if (mi)
        BigInteger.ZERO.subTo(self2, self2);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      var self2 = this;
      if (self2.s < 0)
        return "-" + self2.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return self2.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = self2.t;
      var p = self2.DB - i * self2.DB % k;
      if (i-- > 0) {
        if (p < self2.DB && (d = self2[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (self2[i] & (1 << p) - 1) << k - p;
            d |= self2[--i] >> (p += self2.DB - k);
          } else {
            d = self2[i] >> (p -= k) & km;
            if (p <= 0) {
              p += self2.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = new BigInteger();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnByteLength() {
      return this.bitLength() >> 3;
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var self2 = this;
      var bs = n % self2.DB;
      var cbs = self2.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / self2.DB), c = self2.s << bs & self2.DM, i;
      for (i = self2.t - 1; i >= 0; --i) {
        r[i + ds + 1] = self2[i] >> cbs | c;
        c = (self2[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = self2.t + ds + 1;
      r.s = self2.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      var self2 = this;
      r.s = self2.s;
      var ds = Math.floor(n / self2.DB);
      if (ds >= self2.t) {
        r.t = 0;
        return;
      }
      var bs = n % self2.DB;
      var cbs = self2.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = self2[ds] >> bs;
      for (var i = ds + 1; i < self2.t; ++i) {
        r[i - ds - 1] |= (self2[i] & bm) << cbs;
        r[i - ds] = self2[i] >> bs;
      }
      if (bs > 0)
        r[self2.t - ds - 1] |= (self2.s & bm) << cbs;
      r.t = self2.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var self2 = this;
      var i = 0, c = 0, m = Math.min(a.t, self2.t);
      while (i < m) {
        c += self2[i] - a[i];
        r[i++] = c & self2.DM;
        c >>= self2.DB;
      }
      if (a.t < self2.t) {
        c -= a.s;
        while (i < self2.t) {
          c += self2[i];
          r[i++] = c & self2.DM;
          c >>= self2.DB;
        }
        c += self2.s;
      } else {
        c += self2.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & self2.DM;
          c >>= self2.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = self2.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var self2 = this;
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = self2.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          self2.copyTo(r);
        return;
      }
      if (r == null)
        r = new BigInteger();
      var y = new BigInteger(), ts = self2.s, ms = m.s;
      var nsh = self2.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << self2.F1) + (ys > 1 ? y[ys - 2] >> self2.F2 : 0);
      var d1 = self2.FV / yt, d2 = (1 << self2.F1) / yt, e = 1 << self2.F2;
      var i = r.t, j = i - ys, t = q == null ? new BigInteger() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? self2.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = new BigInteger();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = new BigInteger();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = new BigInteger();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = new BigInteger(), r2 = new BigInteger(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    proto.copyTo = bnpCopyTo;
    proto.fromInt = bnpFromInt;
    proto.fromString = bnpFromString;
    proto.clamp = bnpClamp;
    proto.dlShiftTo = bnpDLShiftTo;
    proto.drShiftTo = bnpDRShiftTo;
    proto.lShiftTo = bnpLShiftTo;
    proto.rShiftTo = bnpRShiftTo;
    proto.subTo = bnpSubTo;
    proto.multiplyTo = bnpMultiplyTo;
    proto.squareTo = bnpSquareTo;
    proto.divRemTo = bnpDivRemTo;
    proto.invDigit = bnpInvDigit;
    proto.isEven = bnpIsEven;
    proto.exp = bnpExp;
    proto.toString = bnToString;
    proto.negate = bnNegate;
    proto.abs = bnAbs;
    proto.compareTo = bnCompareTo;
    proto.bitLength = bnBitLength;
    proto.byteLength = bnByteLength;
    proto.mod = bnMod;
    proto.modPowInt = bnModPowInt;
    function bnClone() {
      var r = new BigInteger();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = new BigInteger(), z = new BigInteger(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      var self2 = this;
      self2.fromInt(0);
      if (b == null)
        b = 10;
      var cs = self2.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && self2.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          self2.dMultiply(d);
          self2.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        self2.dMultiply(Math.pow(b, j));
        self2.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(self2, self2);
    }
    function bnpFromNumber(a, b, c) {
      var self2 = this;
      if ("number" == typeof b) {
        if (a < 2)
          self2.fromInt(1);
        else {
          self2.fromNumber(a, c);
          if (!self2.testBit(a - 1))
            self2.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self2);
          if (self2.isEven())
            self2.dAddOffset(1, 0);
          while (!self2.isProbablePrime(b)) {
            self2.dAddOffset(2, 0);
            if (self2.bitLength() > a)
              self2.subTo(BigInteger.ONE.shiftLeft(a - 1), self2);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        self2.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var self2 = this;
      var i = self2.t, r = new Array();
      r[0] = self2.s;
      var p = self2.DB - i * self2.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < self2.DB && (d = self2[i] >> p) != (self2.s & self2.DM) >> p)
          r[k++] = d | self2.s << self2.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (self2[i] & (1 << p) - 1) << 8 - p;
            d |= self2[--i] >> (p += self2.DB - 8);
          } else {
            d = self2[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += self2.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k === 0 && (self2.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != self2.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var self2 = this;
      var i, f3, m = Math.min(a.t, self2.t);
      for (i = 0; i < m; ++i)
        r[i] = op(self2[i], a[i]);
      if (a.t < self2.t) {
        f3 = a.s & self2.DM;
        for (i = m; i < self2.t; ++i)
          r[i] = op(self2[i], f3);
        r.t = self2.t;
      } else {
        f3 = self2.s & self2.DM;
        for (i = m; i < a.t; ++i)
          r[i] = op(f3, a[i]);
        r.t = a.t;
      }
      r.s = op(self2.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = new BigInteger();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = new BigInteger();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = new BigInteger();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = new BigInteger();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = new BigInteger();
      for (var i = 0; i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = new BigInteger();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = new BigInteger();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var self2 = this;
      var i = 0, c = 0, m = Math.min(a.t, self2.t);
      while (i < m) {
        c += self2[i] + a[i];
        r[i++] = c & self2.DM;
        c >>= self2.DB;
      }
      if (a.t < self2.t) {
        c += a.s;
        while (i < self2.t) {
          c += self2[i];
          r[i++] = c & self2.DM;
          c >>= self2.DB;
        }
        c += self2.s;
      } else {
        c += self2.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & self2.DM;
          c >>= self2.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = self2.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = new BigInteger();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = new BigInteger();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = new BigInteger();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = new BigInteger();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = new BigInteger();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = new BigInteger();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = new BigInteger(), r = new BigInteger();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = new BigInteger();
      this.q3 = new BigInteger();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = new BigInteger();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      var self2 = this;
      x.drShiftTo(self2.m.t - 1, self2.r2);
      if (x.t > self2.m.t + 1) {
        x.t = self2.m.t + 1;
        x.clamp();
      }
      self2.mu.multiplyUpperTo(self2.r2, self2.m.t + 1, self2.q3);
      self2.m.multiplyLowerTo(self2.q3, self2.m.t + 1, self2.r2);
      while (x.compareTo(self2.r2) < 0)
        x.dAddOffset(1, self2.m.t + 1);
      x.subTo(self2.r2, x);
      while (x.compareTo(self2.m) >= 0)
        x.subTo(self2.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = new BigInteger();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = new BigInteger();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = new BigInteger(), t;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.signum() === 0)
        throw new Error("division by zero");
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      while (d.compareTo(m) >= 0)
        d.subTo(m, d);
      while (d.signum() < 0)
        d.addTo(m, d);
      return d;
    }
    var lowprimes = [
      2,
      3,
      5,
      7,
      11,
      13,
      17,
      19,
      23,
      29,
      31,
      37,
      41,
      43,
      47,
      53,
      59,
      61,
      67,
      71,
      73,
      79,
      83,
      89,
      97,
      101,
      103,
      107,
      109,
      113,
      127,
      131,
      137,
      139,
      149,
      151,
      157,
      163,
      167,
      173,
      179,
      181,
      191,
      193,
      197,
      199,
      211,
      223,
      227,
      229,
      233,
      239,
      241,
      251,
      257,
      263,
      269,
      271,
      277,
      281,
      283,
      293,
      307,
      311,
      313,
      317,
      331,
      337,
      347,
      349,
      353,
      359,
      367,
      373,
      379,
      383,
      389,
      397,
      401,
      409,
      419,
      421,
      431,
      433,
      439,
      443,
      449,
      457,
      461,
      463,
      467,
      479,
      487,
      491,
      499,
      503,
      509,
      521,
      523,
      541,
      547,
      557,
      563,
      569,
      571,
      577,
      587,
      593,
      599,
      601,
      607,
      613,
      617,
      619,
      631,
      641,
      643,
      647,
      653,
      659,
      661,
      673,
      677,
      683,
      691,
      701,
      709,
      719,
      727,
      733,
      739,
      743,
      751,
      757,
      761,
      769,
      773,
      787,
      797,
      809,
      811,
      821,
      823,
      827,
      829,
      839,
      853,
      857,
      859,
      863,
      877,
      881,
      883,
      887,
      907,
      911,
      919,
      929,
      937,
      941,
      947,
      953,
      967,
      971,
      977,
      983,
      991,
      997
    ];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t = t + 1 >> 1;
      if (t > lowprimes.length)
        t = lowprimes.length;
      var a = new BigInteger(null);
      var j, bases = [];
      for (var i = 0; i < t; ++i) {
        for (; ; ) {
          j = lowprimes[Math.floor(Math.random() * lowprimes.length)];
          if (bases.indexOf(j) == -1)
            break;
        }
        bases.push(j);
        a.fromInt(j);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    proto.chunkSize = bnpChunkSize;
    proto.toRadix = bnpToRadix;
    proto.fromRadix = bnpFromRadix;
    proto.fromNumber = bnpFromNumber;
    proto.bitwiseTo = bnpBitwiseTo;
    proto.changeBit = bnpChangeBit;
    proto.addTo = bnpAddTo;
    proto.dMultiply = bnpDMultiply;
    proto.dAddOffset = bnpDAddOffset;
    proto.multiplyLowerTo = bnpMultiplyLowerTo;
    proto.multiplyUpperTo = bnpMultiplyUpperTo;
    proto.modInt = bnpModInt;
    proto.millerRabin = bnpMillerRabin;
    proto.clone = bnClone;
    proto.intValue = bnIntValue;
    proto.byteValue = bnByteValue;
    proto.shortValue = bnShortValue;
    proto.signum = bnSigNum;
    proto.toByteArray = bnToByteArray;
    proto.equals = bnEquals;
    proto.min = bnMin;
    proto.max = bnMax;
    proto.and = bnAnd;
    proto.or = bnOr;
    proto.xor = bnXor;
    proto.andNot = bnAndNot;
    proto.not = bnNot;
    proto.shiftLeft = bnShiftLeft;
    proto.shiftRight = bnShiftRight;
    proto.getLowestSetBit = bnGetLowestSetBit;
    proto.bitCount = bnBitCount;
    proto.testBit = bnTestBit;
    proto.setBit = bnSetBit;
    proto.clearBit = bnClearBit;
    proto.flipBit = bnFlipBit;
    proto.add = bnAdd;
    proto.subtract = bnSubtract;
    proto.multiply = bnMultiply;
    proto.divide = bnDivide;
    proto.remainder = bnRemainder;
    proto.divideAndRemainder = bnDivideAndRemainder;
    proto.modPow = bnModPow;
    proto.modInverse = bnModInverse;
    proto.pow = bnPow;
    proto.gcd = bnGCD;
    proto.isProbablePrime = bnIsProbablePrime;
    proto.square = bnSquare;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    BigInteger.valueOf = nbv;
    module2.exports = BigInteger;
  }
});

// node_modules/bigi/lib/convert.js
var require_convert = __commonJS({
  "node_modules/bigi/lib/convert.js"() {
    var assert2 = require_assert();
    var BigInteger = require_bigi();
    BigInteger.fromByteArrayUnsigned = function(byteArray) {
      if (byteArray[0] & 128) {
        return new BigInteger([0].concat(byteArray));
      }
      return new BigInteger(byteArray);
    };
    BigInteger.prototype.toByteArrayUnsigned = function() {
      var byteArray = this.toByteArray();
      return byteArray[0] === 0 ? byteArray.slice(1) : byteArray;
    };
    BigInteger.fromDERInteger = function(byteArray) {
      return new BigInteger(byteArray);
    };
    BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray;
    BigInteger.fromBuffer = function(buffer2) {
      if (buffer2[0] & 128) {
        var byteArray = Array.prototype.slice.call(buffer2);
        return new BigInteger([0].concat(byteArray));
      }
      return new BigInteger(buffer2);
    };
    BigInteger.fromHex = function(hex) {
      if (hex === "")
        return BigInteger.ZERO;
      assert2.equal(hex, hex.match(/^[A-Fa-f0-9]+/), "Invalid hex string");
      assert2.equal(hex.length % 2, 0, "Incomplete hex");
      return new BigInteger(hex, 16);
    };
    BigInteger.prototype.toBuffer = function(size3) {
      var byteArray = this.toByteArrayUnsigned();
      var zeros2 = [];
      var padding = size3 - byteArray.length;
      while (zeros2.length < padding)
        zeros2.push(0);
      return new Buffer(zeros2.concat(byteArray));
    };
    BigInteger.prototype.toHex = function(size3) {
      return this.toBuffer(size3).toString("hex");
    };
  }
});

// node_modules/bigi/lib/index.js
var require_lib = __commonJS({
  "node_modules/bigi/lib/index.js"(exports2, module2) {
    var BigInteger = require_bigi();
    require_convert();
    module2.exports = BigInteger;
  }
});

// node_modules/ecurve/lib/point.js
var require_point2 = __commonJS({
  "node_modules/ecurve/lib/point.js"(exports2, module2) {
    var assert2 = require_assert();
    var Buffer2 = require_safe_buffer().Buffer;
    var BigInteger = require_lib();
    var THREE = BigInteger.valueOf(3);
    function Point2(curve, x, y, z) {
      assert2.notStrictEqual(z, void 0, "Missing Z coordinate");
      this.curve = curve;
      this.x = x;
      this.y = y;
      this.z = z;
      this._zInv = null;
      this.compressed = true;
    }
    Object.defineProperty(Point2.prototype, "zInv", {
      get: function() {
        if (this._zInv === null) {
          this._zInv = this.z.modInverse(this.curve.p);
        }
        return this._zInv;
      }
    });
    Object.defineProperty(Point2.prototype, "affineX", {
      get: function() {
        return this.x.multiply(this.zInv).mod(this.curve.p);
      }
    });
    Object.defineProperty(Point2.prototype, "affineY", {
      get: function() {
        return this.y.multiply(this.zInv).mod(this.curve.p);
      }
    });
    Point2.fromAffine = function(curve, x, y) {
      return new Point2(curve, x, y, BigInteger.ONE);
    };
    Point2.prototype.equals = function(other) {
      if (other === this)
        return true;
      if (this.curve.isInfinity(this))
        return this.curve.isInfinity(other);
      if (this.curve.isInfinity(other))
        return this.curve.isInfinity(this);
      var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p);
      if (u.signum() !== 0)
        return false;
      var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p);
      return v.signum() === 0;
    };
    Point2.prototype.negate = function() {
      var y = this.curve.p.subtract(this.y);
      return new Point2(this.curve, this.x, y, this.z);
    };
    Point2.prototype.add = function(b) {
      if (this.curve.isInfinity(this))
        return b;
      if (this.curve.isInfinity(b))
        return this;
      var x1 = this.x;
      var y1 = this.y;
      var x2 = b.x;
      var y2 = b.y;
      var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p);
      var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p);
      if (v.signum() === 0) {
        if (u.signum() === 0) {
          return this.twice();
        }
        return this.curve.infinity;
      }
      var v2 = v.square();
      var v32 = v2.multiply(v);
      var x1v2 = x1.multiply(v2);
      var zu2 = u.square().multiply(this.z);
      var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v32).multiply(v).mod(this.curve.p);
      var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v32)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v32)).mod(this.curve.p);
      var z3 = v32.multiply(this.z).multiply(b.z).mod(this.curve.p);
      return new Point2(this.curve, x3, y3, z3);
    };
    Point2.prototype.twice = function() {
      if (this.curve.isInfinity(this))
        return this;
      if (this.y.signum() === 0)
        return this.curve.infinity;
      var x1 = this.x;
      var y1 = this.y;
      var y1z1 = y1.multiply(this.z).mod(this.curve.p);
      var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);
      var a = this.curve.a;
      var w = x1.square().multiply(THREE);
      if (a.signum() !== 0) {
        w = w.add(this.z.square().multiply(a));
      }
      w = w.mod(this.curve.p);
      var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);
      var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p);
      var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p);
      return new Point2(this.curve, x3, y3, z3);
    };
    Point2.prototype.multiply = function(k) {
      if (this.curve.isInfinity(this))
        return this;
      if (k.signum() === 0)
        return this.curve.infinity;
      var e = k;
      var h = e.multiply(THREE);
      var neg = this.negate();
      var R = this;
      for (var i = h.bitLength() - 2; i > 0; --i) {
        var hBit = h.testBit(i);
        var eBit = e.testBit(i);
        R = R.twice();
        if (hBit !== eBit) {
          R = R.add(hBit ? this : neg);
        }
      }
      return R;
    };
    Point2.prototype.multiplyTwo = function(j, x, k) {
      var i = Math.max(j.bitLength(), k.bitLength()) - 1;
      var R = this.curve.infinity;
      var both = this.add(x);
      while (i >= 0) {
        var jBit = j.testBit(i);
        var kBit = k.testBit(i);
        R = R.twice();
        if (jBit) {
          if (kBit) {
            R = R.add(both);
          } else {
            R = R.add(this);
          }
        } else if (kBit) {
          R = R.add(x);
        }
        --i;
      }
      return R;
    };
    Point2.prototype.getEncoded = function(compressed) {
      if (compressed == null)
        compressed = this.compressed;
      if (this.curve.isInfinity(this))
        return Buffer2.alloc(1, 0);
      var x = this.affineX;
      var y = this.affineY;
      var byteLength = this.curve.pLength;
      var buffer2;
      if (compressed) {
        buffer2 = Buffer2.allocUnsafe(1 + byteLength);
        buffer2.writeUInt8(y.isEven() ? 2 : 3, 0);
      } else {
        buffer2 = Buffer2.allocUnsafe(1 + byteLength + byteLength);
        buffer2.writeUInt8(4, 0);
        y.toBuffer(byteLength).copy(buffer2, 1 + byteLength);
      }
      x.toBuffer(byteLength).copy(buffer2, 1);
      return buffer2;
    };
    Point2.decodeFrom = function(curve, buffer2) {
      var type = buffer2.readUInt8(0);
      var compressed = type !== 4;
      var byteLength = Math.floor((curve.p.bitLength() + 7) / 8);
      var x = BigInteger.fromBuffer(buffer2.slice(1, 1 + byteLength));
      var Q;
      if (compressed) {
        assert2.equal(buffer2.length, byteLength + 1, "Invalid sequence length");
        assert2(type === 2 || type === 3, "Invalid sequence tag");
        var isOdd = type === 3;
        Q = curve.pointFromX(isOdd, x);
      } else {
        assert2.equal(buffer2.length, 1 + byteLength + byteLength, "Invalid sequence length");
        var y = BigInteger.fromBuffer(buffer2.slice(1 + byteLength));
        Q = Point2.fromAffine(curve, x, y);
      }
      Q.compressed = compressed;
      return Q;
    };
    Point2.prototype.toString = function() {
      if (this.curve.isInfinity(this))
        return "(INFINITY)";
      return "(" + this.affineX.toString() + "," + this.affineY.toString() + ")";
    };
    module2.exports = Point2;
  }
});

// node_modules/ecurve/lib/curve.js
var require_curve2 = __commonJS({
  "node_modules/ecurve/lib/curve.js"(exports2, module2) {
    var assert2 = require_assert();
    var BigInteger = require_lib();
    var Point2 = require_point2();
    function Curve(p, a, b, Gx, Gy, n, h) {
      this.p = p;
      this.a = a;
      this.b = b;
      this.G = Point2.fromAffine(this, Gx, Gy);
      this.n = n;
      this.h = h;
      this.infinity = new Point2(this, null, null, BigInteger.ZERO);
      this.pOverFour = p.add(BigInteger.ONE).shiftRight(2);
      this.pLength = Math.floor((this.p.bitLength() + 7) / 8);
    }
    Curve.prototype.pointFromX = function(isOdd, x) {
      var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p);
      var beta = alpha.modPow(this.pOverFour, this.p);
      var y = beta;
      if (beta.isEven() ^ !isOdd) {
        y = this.p.subtract(y);
      }
      return Point2.fromAffine(this, x, y);
    };
    Curve.prototype.isInfinity = function(Q) {
      if (Q === this.infinity)
        return true;
      return Q.z.signum() === 0 && Q.y.signum() !== 0;
    };
    Curve.prototype.isOnCurve = function(Q) {
      if (this.isInfinity(Q))
        return true;
      var x = Q.affineX;
      var y = Q.affineY;
      var a = this.a;
      var b = this.b;
      var p = this.p;
      if (x.signum() < 0 || x.compareTo(p) >= 0)
        return false;
      if (y.signum() < 0 || y.compareTo(p) >= 0)
        return false;
      var lhs = y.square().mod(p);
      var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p);
      return lhs.equals(rhs);
    };
    Curve.prototype.validate = function(Q) {
      assert2(!this.isInfinity(Q), "Point is at infinity");
      assert2(this.isOnCurve(Q), "Point is not on the curve");
      var nQ = Q.multiply(this.n);
      assert2(this.isInfinity(nQ), "Point is not a scalar multiple of G");
      return true;
    };
    module2.exports = Curve;
  }
});

// node_modules/ecurve/lib/curves.json
var require_curves2 = __commonJS({
  "node_modules/ecurve/lib/curves.json"(exports2, module2) {
    module2.exports = {
      secp128r1: {
        p: "fffffffdffffffffffffffffffffffff",
        a: "fffffffdfffffffffffffffffffffffc",
        b: "e87579c11079f43dd824993c2cee5ed3",
        n: "fffffffe0000000075a30d1b9038a115",
        h: "01",
        Gx: "161ff7528b899b2d0c28607ca52c5b86",
        Gy: "cf5ac8395bafeb13c02da292dded7a83"
      },
      secp160k1: {
        p: "fffffffffffffffffffffffffffffffeffffac73",
        a: "00",
        b: "07",
        n: "0100000000000000000001b8fa16dfab9aca16b6b3",
        h: "01",
        Gx: "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
        Gy: "938cf935318fdced6bc28286531733c3f03c4fee"
      },
      secp160r1: {
        p: "ffffffffffffffffffffffffffffffff7fffffff",
        a: "ffffffffffffffffffffffffffffffff7ffffffc",
        b: "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
        n: "0100000000000000000001f4c8f927aed3ca752257",
        h: "01",
        Gx: "4a96b5688ef573284664698968c38bb913cbfc82",
        Gy: "23a628553168947d59dcc912042351377ac5fb32"
      },
      secp192k1: {
        p: "fffffffffffffffffffffffffffffffffffffffeffffee37",
        a: "00",
        b: "03",
        n: "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
        h: "01",
        Gx: "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
        Gy: "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
      },
      secp192r1: {
        p: "fffffffffffffffffffffffffffffffeffffffffffffffff",
        a: "fffffffffffffffffffffffffffffffefffffffffffffffc",
        b: "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
        n: "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
        h: "01",
        Gx: "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
        Gy: "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
      },
      secp256k1: {
        p: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
        a: "00",
        b: "07",
        n: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
        h: "01",
        Gx: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        Gy: "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      },
      secp256r1: {
        p: "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
        a: "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
        b: "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
        n: "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
        h: "01",
        Gx: "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
        Gy: "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
      }
    };
  }
});

// node_modules/ecurve/lib/names.js
var require_names = __commonJS({
  "node_modules/ecurve/lib/names.js"(exports2, module2) {
    var BigInteger = require_lib();
    var curves = require_curves2();
    var Curve = require_curve2();
    function getCurveByName(name) {
      var curve = curves[name];
      if (!curve)
        return null;
      var p = new BigInteger(curve.p, 16);
      var a = new BigInteger(curve.a, 16);
      var b = new BigInteger(curve.b, 16);
      var n = new BigInteger(curve.n, 16);
      var h = new BigInteger(curve.h, 16);
      var Gx = new BigInteger(curve.Gx, 16);
      var Gy = new BigInteger(curve.Gy, 16);
      return new Curve(p, a, b, Gx, Gy, n, h);
    }
    module2.exports = getCurveByName;
  }
});

// node_modules/ecurve/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ecurve/lib/index.js"(exports2, module2) {
    var Point2 = require_point2();
    var Curve = require_curve2();
    var getCurveByName = require_names();
    module2.exports = {
      Curve,
      Point: Point2,
      getCurveByName
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto4 = globalThis.crypto || globalThis.msCrypto;
    if (crypto4 && crypto4.getRandomValues) {
      module2.exports = randomBytes2;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes2(size3, cb) {
      if (size3 > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes2 = Buffer2.allocUnsafe(size3);
      if (size3 > 0) {
        if (size3 > MAX_BYTES) {
          for (var generated = 0; generated < size3; generated += MAX_BYTES) {
            crypto4.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto4.getRandomValues(bytes2);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes2);
        });
      }
      return bytes2;
    }
  }
});

// node_modules/bip-schnorr/src/check.js
var require_check = __commonJS({
  "node_modules/bip-schnorr/src/check.js"(exports2, module2) {
    var BigInteger = require_lib();
    var Buffer2 = require_safe_buffer().Buffer;
    var ecurve = require_lib2();
    var curve = ecurve.getCurveByName("secp256k1");
    var one = BigInteger.ONE;
    var n = curve.n;
    var p = curve.p;
    function checkBuffer(name, buf, len, idx) {
      const idxStr = idx !== void 0 ? "[" + idx + "]" : "";
      if (!Buffer2.isBuffer(buf)) {
        throw new Error(name + idxStr + " must be a Buffer");
      }
      if (buf.length !== len) {
        throw new Error(name + idxStr + " must be " + len + " bytes long");
      }
    }
    function checkArray(name, arr) {
      if (!arr || !arr.length) {
        throw new Error(name + " must be an array with one or more elements");
      }
    }
    function checkPubKeyArr(pubKeys) {
      checkArray("pubKeys", pubKeys);
      for (let i = 0; i < pubKeys.length; i++) {
        checkBuffer("pubKey", pubKeys[i], 32, i);
      }
    }
    function checkMessageArr(messages) {
      checkArray("messages", messages);
      for (let i = 0; i < messages.length; i++) {
        checkBuffer("message", messages[i], 32, i);
      }
    }
    function checkSignatureArr(signatures) {
      checkArray("signatures", signatures);
      for (let i = 0; i < signatures.length; i++) {
        checkBuffer("signature", signatures[i], 64, i);
      }
    }
    function checkNonceArr(nonces) {
      checkArray("nonces", nonces);
      for (let i = 0; i < nonces.length; i++) {
        checkBuffer("nonce", nonces[i], 32, i);
      }
    }
    function checkPrivateKey(privateKey, idx) {
      const idxStr = idx !== void 0 ? "[" + idx + "]" : "";
      if (!BigInteger.isBigInteger(privateKey) && !(typeof privateKey == "string")) {
        throw new Error("privateKey" + idxStr + " must be a BigInteger or valid hex string");
      }
      if (typeof privateKey == "string") {
        if (privateKey.match(/[^a-f^A-F^0-9]+/)) {
          throw new Error("privateKey must be a BigInteger or valid hex string");
        }
        checkRange("privateKey", BigInteger.fromHex(privateKey));
        return;
      }
      checkRange("privateKey", privateKey);
    }
    function checkSignParams(privateKey, message) {
      checkPrivateKey(privateKey);
      checkBuffer("message", message, 32);
    }
    function checkVerifyParams(pubKey, message, signature) {
      checkBuffer("pubKey", pubKey, 32);
      checkBuffer("message", message, 32);
      checkBuffer("signature", signature, 64);
    }
    function checkBatchVerifyParams(pubKeys, messages, signatures) {
      checkPubKeyArr(pubKeys);
      checkMessageArr(messages);
      checkSignatureArr(signatures);
      if (pubKeys.length !== messages.length || messages.length !== signatures.length) {
        throw new Error("all parameters must be an array with the same length");
      }
    }
    function checkSessionParams(sessionId, privateKey, message, pubKeyCombined, ell) {
      checkSignParams(privateKey, message);
      checkBuffer("sessionId", sessionId, 32);
      checkBuffer("pubKeyCombined", pubKeyCombined, 32);
      checkBuffer("ell", ell, 32);
    }
    function checkRange(name, scalar) {
      if (scalar.compareTo(one) < 0 || scalar.compareTo(n.subtract(one)) > 0) {
        throw new Error(name + " must be an integer in the range 1..n-1");
      }
    }
    function checkSignatureInput(r, s) {
      if (r.compareTo(p) >= 0) {
        throw new Error("r is larger than or equal to field size");
      }
      if (s.compareTo(n) >= 0) {
        throw new Error("s is larger than or equal to curve order");
      }
    }
    function checkPointExists(pubKeyEven, P) {
      if (P.curve.isInfinity(P)) {
        throw new Error("point is at infinity");
      }
      const pEven = P.affineY.isEven();
      if (pubKeyEven !== pEven) {
        throw new Error("point does not exist");
      }
    }
    function checkAux(aux) {
      if (aux.length !== 32) {
        throw new Error("aux must be 32 bytes");
      }
    }
    module2.exports = {
      checkSessionParams,
      checkSignParams,
      checkVerifyParams,
      checkBatchVerifyParams,
      checkRange,
      checkSignatureInput,
      checkPointExists,
      checkPubKeyArr,
      checkArray,
      checkNonceArr,
      checkAux
    };
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key, message) {
          return new HmacSha256(key, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index2 = 0, i, length = message.length, blocks2 = this.blocks;
        while (index2 < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index2 < length && i < 64; ++index2) {
              blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index2 < length && i < 64; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f3 = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f3 ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f3;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f3 + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f3 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f3 & g ^ ~f3 & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f3 << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer2);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer2;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i, type = typeof key;
        if (type === "string") {
          var bytes2 = [], length = key.length, index2 = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes2[index2++] = code;
            } else if (code < 2048) {
              bytes2[index2++] = 192 | code >> 6;
              bytes2[index2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes2[index2++] = 224 | code >> 12;
              bytes2[index2++] = 128 | code >> 6 & 63;
              bytes2[index2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes2[index2++] = 240 | code >> 18;
              bytes2[index2++] = 128 | code >> 12 & 63;
              bytes2[index2++] = 128 | code >> 6 & 63;
              bytes2[index2++] = 128 | code & 63;
            }
          }
          key = bytes2;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/bip-schnorr/src/convert.js
var require_convert2 = __commonJS({
  "node_modules/bip-schnorr/src/convert.js"(exports2, module2) {
    var BigInteger = require_lib();
    var Buffer2 = require_safe_buffer().Buffer;
    var sha2566 = require_sha2562();
    function bufferToInt(buffer2) {
      return BigInteger.fromBuffer(buffer2);
    }
    function intToBuffer(bigInteger) {
      return bigInteger.toBuffer(32);
    }
    function hash2(buffer2) {
      return Buffer2.from(sha2566.create().update(buffer2).array());
    }
    module2.exports = {
      bufferToInt,
      intToBuffer,
      hash: hash2
    };
  }
});

// node_modules/bip-schnorr/src/math.js
var require_math = __commonJS({
  "node_modules/bip-schnorr/src/math.js"(exports2, module2) {
    var BigInteger = require_lib();
    var Buffer2 = require_safe_buffer().Buffer;
    var ecurve = require_lib2();
    var randomBytes2 = require_browser();
    var curve = ecurve.getCurveByName("secp256k1");
    var check = require_check();
    var convert = require_convert2();
    var concat2 = Buffer2.concat;
    var G = curve.G;
    var p = curve.p;
    var n = curve.n;
    var zero = BigInteger.ZERO;
    var one = BigInteger.ONE;
    var two = BigInteger.valueOf(2);
    var three = BigInteger.valueOf(3);
    var four = BigInteger.valueOf(4);
    var seven = BigInteger.valueOf(7);
    function deterministicGetK0(privateKey, publicKey, message) {
      check.checkSignParams(privateKey, message);
      const h = taggedHash2("BIP0340/nonce", concat2([convert.intToBuffer(privateKey), publicKey, message]));
      const i = convert.bufferToInt(h);
      return i.mod(n);
    }
    function isEven(pubKey) {
      return pubKey.affineY.mod(two).equals(zero);
    }
    function getEvenKey(pubKey, privateKey) {
      if (isEven(pubKey)) {
        return privateKey.clone();
      }
      return n.subtract(privateKey);
    }
    function getE(Rx, Px, m) {
      const hash2 = taggedHash2("BIP0340/challenge", concat2([Rx, Px, m]));
      return convert.bufferToInt(hash2).mod(n);
    }
    function getR(s, e, P) {
      const sG = G.multiply(s);
      const eP = P.multiply(e);
      return sG.add(eP.negate());
    }
    function taggedHash2(tag, msg) {
      const tagHash = convert.hash(tag);
      return convert.hash(concat2([tagHash, tagHash, Buffer2.from(msg)]));
    }
    function liftX(Px) {
      const x = convert.bufferToInt(Px);
      const c = x.pow(three).add(seven).mod(p);
      const y = c.modPow(p.add(one).divide(four), p);
      if (c.compareTo(y.modPow(two, p)) !== 0) {
        throw new Error("c is not equal to y^2");
      }
      let P = ecurve.Point.fromAffine(curve, x, y);
      if (!isEven(P)) {
        P = ecurve.Point.fromAffine(curve, x, p.subtract(y));
      }
      check.checkPointExists(true, P);
      return P;
    }
    function randomA() {
      let a = null;
      for (; ; ) {
        a = convert.bufferToInt(Buffer2.from(randomBytes2(32)));
        try {
          check.checkRange("a", a);
          return a;
        } catch (e) {
        }
      }
    }
    module2.exports = {
      deterministicGetK0,
      isEven,
      getEvenKey,
      getE,
      getR,
      taggedHash: taggedHash2,
      liftX,
      randomA
    };
  }
});

// node_modules/bip-schnorr/src/schnorr.js
var require_schnorr = __commonJS({
  "node_modules/bip-schnorr/src/schnorr.js"(exports2, module2) {
    var BigInteger = require_lib();
    var Buffer2 = require_safe_buffer().Buffer;
    var ecurve = require_lib2();
    var curve = ecurve.getCurveByName("secp256k1");
    var math = require_math();
    var check = require_check();
    var convert = require_convert2();
    var concat2 = Buffer2.concat;
    var G = curve.G;
    var p = curve.p;
    var n = curve.n;
    var zero = BigInteger.ZERO;
    function sign(privateKey, message, aux) {
      check.checkSignParams(privateKey, message);
      privateKey = typeof privateKey == "string" ? BigInteger.fromHex(privateKey) : privateKey;
      const P = G.multiply(privateKey);
      const Px = convert.intToBuffer(P.affineX);
      const d = math.getEvenKey(P, privateKey);
      let kPrime;
      if (aux) {
        check.checkAux(aux);
        const t = convert.intToBuffer(d.xor(convert.bufferToInt(math.taggedHash("BIP0340/aux", aux))));
        const rand = math.taggedHash("BIP0340/nonce", concat2([t, Px, message]));
        kPrime = convert.bufferToInt(rand).mod(n);
      } else {
        kPrime = math.deterministicGetK0(d, Px, message);
      }
      if (kPrime.signum() === 0) {
        throw new Error("kPrime is zero");
      }
      const R = G.multiply(kPrime);
      const k = math.getEvenKey(R, kPrime);
      const Rx = convert.intToBuffer(R.affineX);
      const e = math.getE(Rx, Px, message);
      return concat2([Rx, convert.intToBuffer(k.add(e.multiply(d)).mod(n))]);
    }
    function verify(pubKey, message, signature) {
      check.checkVerifyParams(pubKey, message, signature);
      const P = math.liftX(pubKey);
      const Px = convert.intToBuffer(P.affineX);
      const r = convert.bufferToInt(signature.slice(0, 32));
      const s = convert.bufferToInt(signature.slice(32, 64));
      check.checkSignatureInput(r, s);
      const e = math.getE(convert.intToBuffer(r), Px, message);
      const R = math.getR(s, e, P);
      if (R.curve.isInfinity(R) || !math.isEven(R) || !R.affineX.equals(r)) {
        throw new Error("signature verification failed");
      }
    }
    function batchVerify(pubKeys, messages, signatures) {
      check.checkBatchVerifyParams(pubKeys, messages, signatures);
      let leftSide = zero;
      let rightSide = null;
      for (let i = 0; i < pubKeys.length; i++) {
        const P = math.liftX(pubKeys[i]);
        const Px = convert.intToBuffer(P.affineX);
        const r = convert.bufferToInt(signatures[i].slice(0, 32));
        const s = convert.bufferToInt(signatures[i].slice(32, 64));
        check.checkSignatureInput(r, s);
        const e = math.getE(convert.intToBuffer(r), Px, messages[i]);
        const R = math.liftX(signatures[i].slice(0, 32));
        if (i === 0) {
          leftSide = leftSide.add(s);
          rightSide = R;
          rightSide = rightSide.add(P.multiply(e));
        } else {
          const a = math.randomA();
          leftSide = leftSide.add(a.multiply(s));
          rightSide = rightSide.add(R.multiply(a));
          rightSide = rightSide.add(P.multiply(a.multiply(e)));
        }
      }
      if (!G.multiply(leftSide).equals(rightSide)) {
        throw new Error("signature verification failed");
      }
    }
    module2.exports = {
      sign,
      verify,
      batchVerify
    };
  }
});

// node_modules/bip-schnorr/src/mu-sig.js
var require_mu_sig = __commonJS({
  "node_modules/bip-schnorr/src/mu-sig.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var ecurve = require_lib2();
    var curve = ecurve.getCurveByName("secp256k1");
    var math = require_math();
    var check = require_check();
    var convert = require_convert2();
    var concat2 = Buffer2.concat;
    var G = curve.G;
    var n = curve.n;
    var MUSIG_TAG = convert.hash(Buffer2.from("MuSig coefficient"));
    function computeEll(pubKeys) {
      check.checkPubKeyArr(pubKeys);
      return convert.hash(concat2(pubKeys));
    }
    function computeCoefficient(ell, idx) {
      const idxBuf = Buffer2.alloc(4);
      idxBuf.writeUInt32LE(idx);
      const data = concat2([MUSIG_TAG, MUSIG_TAG, ell, idxBuf]);
      return convert.bufferToInt(convert.hash(data)).mod(n);
    }
    function pubKeyCombine(pubKeys, pubKeyHash) {
      const ell = pubKeyHash || computeEll(pubKeys);
      let X = null;
      for (let i = 0; i < pubKeys.length; i++) {
        const Xi = math.liftX(pubKeys[i]);
        const coefficient = computeCoefficient(ell, i);
        const summand = Xi.multiply(coefficient);
        if (X === null) {
          X = summand;
        } else {
          X = X.add(summand);
        }
      }
      return X;
    }
    function sessionInitialize(sessionId, privateKey, message, pubKeyCombined, pkParity, ell, idx) {
      check.checkSessionParams(sessionId, privateKey, message, pubKeyCombined, ell);
      const session = {
        sessionId,
        message,
        pubKeyCombined,
        pkParity,
        ell,
        idx
      };
      const coefficient = computeCoefficient(ell, idx);
      session.secretKey = privateKey.multiply(coefficient).mod(n);
      session.ownKeyParity = math.isEven(G.multiply(privateKey));
      if (session.pkParity !== session.ownKeyParity) {
        session.secretKey = n.subtract(session.secretKey);
      }
      const nonceData = concat2([sessionId, message, session.pubKeyCombined, convert.intToBuffer(privateKey)]);
      session.secretNonce = convert.bufferToInt(convert.hash(nonceData));
      check.checkRange("secretNonce", session.secretNonce);
      const R = G.multiply(session.secretNonce);
      session.nonce = convert.intToBuffer(R.affineX);
      session.nonceParity = math.isEven(R);
      session.commitment = convert.hash(session.nonce);
      return session;
    }
    function sessionNonceCombine(session, nonces) {
      check.checkNonceArr(nonces);
      let R = math.liftX(nonces[0]);
      for (let i = 1; i < nonces.length; i++) {
        R = R.add(math.liftX(nonces[i]));
      }
      session.combinedNonceParity = math.isEven(R);
      return convert.intToBuffer(R.affineX);
    }
    function partialSign(session, message, nonceCombined, pubKeyCombined) {
      const e = math.getE(nonceCombined, pubKeyCombined, message);
      const sk = session.secretKey;
      let k = session.secretNonce;
      if (session.nonceParity !== session.combinedNonceParity) {
        k = n.subtract(k);
      }
      return sk.multiply(e).add(k).mod(n);
    }
    function partialSigVerify(session, partialSig, nonceCombined, idx, pubKey, nonce) {
      let e = math.getE(nonceCombined, session.pubKeyCombined, session.message);
      const coefficient = computeCoefficient(session.ell, idx);
      const Pj = math.liftX(pubKey);
      const Ri = math.liftX(nonce);
      if (!session.pkParity) {
        e = n.subtract(e);
      }
      let RP = math.getR(partialSig, e.multiply(coefficient).mod(n), Pj);
      if (session.combinedNonceParity) {
        RP = RP.negate();
      }
      const sum = RP.add(Ri);
      if (!sum.curve.isInfinity(sum)) {
        throw new Error("partial signature verification failed");
      }
    }
    function partialSigCombine(nonceCombined, partialSigs) {
      const R = math.liftX(nonceCombined);
      check.checkArray("partialSigs", partialSigs);
      const Rx = convert.intToBuffer(R.affineX);
      let s = partialSigs[0];
      for (let i = 1; i < partialSigs.length; i++) {
        s = s.add(partialSigs[i]).mod(n);
      }
      return concat2([Rx, convert.intToBuffer(s)]);
    }
    module2.exports = {
      computeEll,
      computeCoefficient,
      pubKeyCombine,
      sessionInitialize,
      sessionNonceCombine,
      partialSign,
      partialSigVerify,
      partialSigCombine
    };
  }
});

// node_modules/bip-schnorr/src/taproot.js
var require_taproot = __commonJS({
  "node_modules/bip-schnorr/src/taproot.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var ecurve = require_lib2();
    var curve = ecurve.getCurveByName("secp256k1");
    var math = require_math();
    var convert = require_convert2();
    var concat2 = Buffer2.concat;
    var G = curve.G;
    function taprootConstruct(pubKey, scripts) {
      if (!scripts) {
        scripts = [];
      }
      const h = taprootTree(scripts);
      const Px = convert.intToBuffer(pubKey.affineX);
      const P = math.liftX(Px);
      const tweak = convert.bufferToInt(math.taggedHash("TapTweak", concat2([Px, h])));
      const Q = P.add(G.multiply(tweak));
      return convert.intToBuffer(Q.affineX);
    }
    function taprootTree(scripts) {
      let h = Buffer2.alloc(32, 0);
      if (!scripts || scripts.length === 0) {
        return new Buffer2(0);
      }
      return h;
    }
    module2.exports = {
      taprootConstruct
    };
  }
});

// node_modules/bip-schnorr/src/index.js
var require_src = __commonJS({
  "node_modules/bip-schnorr/src/index.js"(exports2, module2) {
    var schnorr2 = require_schnorr();
    schnorr2.check = require_check();
    schnorr2.convert = require_convert2();
    schnorr2.math = require_math();
    schnorr2.muSig = require_mu_sig();
    schnorr2.taproot = require_taproot();
    module2.exports = schnorr2;
  }
});

// node_modules/bitcore-lib/lib/transaction/input/input.js
var require_input = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/input.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var errors = require_errors();
    var BufferWriter = require_bufferwriter();
    var buffer2 = require_buffer();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Script = require_script2();
    var Sighash = require_sighash();
    var Output = require_output();
    var MAXINT = 4294967295;
    var DEFAULT_SEQNUMBER = MAXINT;
    var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;
    var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
    var SEQUENCE_LOCKTIME_DISABLE_FLAG2 = Math.pow(2, 31);
    var SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22);
    var SEQUENCE_LOCKTIME_MASK = 65535;
    var SEQUENCE_LOCKTIME_GRANULARITY = 512;
    var SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1;
    function Input(params) {
      if (!(this instanceof Input)) {
        return new Input(params);
      }
      if (params) {
        return this._fromObject(params);
      }
    }
    Input.MAXINT = MAXINT;
    Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
    Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
    Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
    Input.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;
    Object.defineProperty(Input.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this.isNull()) {
          return null;
        }
        if (!this._script) {
          this._script = new Script(this._scriptBuffer);
          this._script._isInput = true;
        }
        return this._script;
      }
    });
    Input.fromObject = function(obj) {
      $.checkArgument(_.isObject(obj));
      var input = new Input();
      return input._fromObject(obj);
    };
    Input.prototype._fromObject = function(params) {
      var prevTxId;
      if (typeof params.prevTxId === "string" && JSUtil.isHexa(params.prevTxId)) {
        prevTxId = Buffer.from(params.prevTxId, "hex");
      } else {
        prevTxId = params.prevTxId;
      }
      this.witnesses = [];
      this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : void 0;
      this.prevTxId = prevTxId || params.txidbuf;
      this.outputIndex = params.outputIndex == null ? params.txoutnum : params.outputIndex;
      this.sequenceNumber = params.sequenceNumber == null ? params.seqnum == null ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;
      if (params.script === void 0 && params.scriptBuffer === void 0) {
        throw new errors.Transaction.Input.MissingScript();
      }
      this.setScript(params.scriptBuffer || params.script);
      return this;
    };
    Input.prototype.toObject = Input.prototype.toJSON = function toObject() {
      var obj = {
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        sequenceNumber: this.sequenceNumber,
        script: this._scriptBuffer.toString("hex")
      };
      if (this.script) {
        obj.scriptString = this.script.toString();
      }
      if (this.output) {
        obj.output = this.output.toObject();
      }
      return obj;
    };
    Input.fromBufferReader = function(br) {
      var input = new Input();
      input.prevTxId = br.readReverse(32);
      input.outputIndex = br.readUInt32LE();
      input._scriptBuffer = br.readVarLengthBuffer();
      input.sequenceNumber = br.readUInt32LE();
      return input;
    };
    Input.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter();
      }
      writer.writeReverse(this.prevTxId);
      writer.writeUInt32LE(this.outputIndex);
      var script = this._scriptBuffer;
      writer.writeVarintNum(script.length);
      writer.write(script);
      writer.writeUInt32LE(this.sequenceNumber);
      return writer;
    };
    Input.prototype.setScript = function(script) {
      this._script = null;
      if (script instanceof Script) {
        this._script = script;
        this._script._isInput = true;
        this._scriptBuffer = script.toBuffer();
      } else if (JSUtil.isHexa(script)) {
        this._scriptBuffer = Buffer.from(script, "hex");
      } else if (_.isString(script)) {
        this._script = new Script(script);
        this._script._isInput = true;
        this._scriptBuffer = this._script.toBuffer();
      } else if (BufferUtil.isBuffer(script)) {
        this._scriptBuffer = Buffer.from(script);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      return this;
    };
    Input.prototype.getSignatures = function() {
      throw new errors.AbstractMethodInvoked(
        "Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported) for input: " + JSON.stringify(this)
      );
    };
    Input.prototype.getSatoshisBuffer = function() {
      $.checkState(this.output instanceof Output);
      $.checkState(this.output._satoshisBN);
      return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();
    };
    Input.prototype.isFullySigned = function() {
      throw new errors.AbstractMethodInvoked("Input#isFullySigned");
    };
    Input.prototype.isFinal = function() {
      return this.sequenceNumber !== Input.MAXINT;
    };
    Input.prototype.addSignature = function() {
      throw new errors.AbstractMethodInvoked("Input#addSignature");
    };
    Input.prototype.clearSignatures = function() {
      throw new errors.AbstractMethodInvoked("Input#clearSignatures");
    };
    Input.prototype.hasWitnesses = function() {
      if (this.witnesses && this.witnesses.length > 0) {
        return true;
      }
      return false;
    };
    Input.prototype.getWitnesses = function() {
      return this.witnesses;
    };
    Input.prototype.setWitnesses = function(witnesses) {
      this.witnesses = witnesses;
    };
    Input.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.output.script,
        signingMethod
      );
    };
    Input.prototype.isNull = function() {
      return this.prevTxId.toString("hex") === "0000000000000000000000000000000000000000000000000000000000000000" && this.outputIndex === 4294967295;
    };
    Input.prototype._estimateSize = function() {
      return this.toBufferWriter().toBuffer().length;
    };
    Input.prototype._getBaseSize = function() {
      return 32 + 4 + 4;
    };
    Input.prototype.lockForSeconds = function(seconds) {
      $.checkArgument(_.isNumber(seconds));
      if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {
        throw new errors.Transaction.Input.LockTimeRange();
      }
      seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));
      this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;
      return this;
    };
    Input.prototype.lockUntilBlockHeight = function(heightDiff) {
      $.checkArgument(_.isNumber(heightDiff));
      if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {
        throw new errors.Transaction.Input.BlockHeightOutOfRange();
      }
      this.sequenceNumber = heightDiff;
      return this;
    };
    Input.prototype.getLockTime = function() {
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG2) {
        return null;
      }
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {
        var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);
        return seconds;
      } else {
        var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;
        return blockHeight;
      }
    };
    module2.exports = Input;
  }
});

// node_modules/bitcore-lib/node_modules/inherits/inherits_browser.js
var require_inherits_browser3 = __commonJS({
  "node_modules/bitcore-lib/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }
});

// node_modules/bitcore-lib/lib/transaction/signature.js
var require_signature4 = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/signature.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var inherits2 = require_inherits_browser3();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var PublicKey = require_publickey2();
    var errors = require_errors();
    var Signature = require_signature3();
    function TransactionSignature(arg) {
      if (!(this instanceof TransactionSignature)) {
        return new TransactionSignature(arg);
      }
      if (arg instanceof TransactionSignature) {
        return arg;
      }
      if (_.isObject(arg)) {
        return this._fromObject(arg);
      }
      throw new errors.InvalidArgument("TransactionSignatures must be instantiated from an object");
    }
    inherits2(TransactionSignature, Signature);
    TransactionSignature.prototype._fromObject = function(arg) {
      this._checkObjectArgs(arg);
      this.publicKey = new PublicKey(arg.publicKey);
      this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, "hex");
      this.outputIndex = arg.outputIndex;
      this.inputIndex = arg.inputIndex;
      this.signature = arg.signature instanceof Signature ? arg.signature : BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) : Signature.fromString(arg.signature);
      this.sigtype = arg.sigtype;
      return this;
    };
    TransactionSignature.prototype._checkObjectArgs = function(arg) {
      $.checkArgument(PublicKey(arg.publicKey), "publicKey");
      $.checkArgument(!_.isUndefined(arg.inputIndex), "inputIndex");
      $.checkArgument(!_.isUndefined(arg.outputIndex), "outputIndex");
      $.checkState(_.isNumber(arg.inputIndex), "inputIndex must be a number");
      $.checkState(_.isNumber(arg.outputIndex), "outputIndex must be a number");
      $.checkArgument(arg.signature, "signature");
      $.checkArgument(arg.prevTxId, "prevTxId");
      $.checkState(arg.signature instanceof Signature || BufferUtil.isBuffer(arg.signature) || JSUtil.isHexa(arg.signature), "signature must be a buffer or hexa value");
      $.checkState(BufferUtil.isBuffer(arg.prevTxId) || JSUtil.isHexa(arg.prevTxId), "prevTxId must be a buffer or hexa value");
      $.checkArgument(arg.sigtype, "sigtype");
      $.checkState(_.isNumber(arg.sigtype), "sigtype must be a number");
    };
    TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {
      return {
        publicKey: this.publicKey.toString(),
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        inputIndex: this.inputIndex,
        signature: this.signature.toString(),
        sigtype: this.sigtype
      };
    };
    TransactionSignature.fromObject = function(object) {
      $.checkArgument(object);
      return new TransactionSignature(object);
    };
    module2.exports = TransactionSignature;
  }
});

// node_modules/bitcore-lib/lib/transaction/input/publickey.js
var require_publickey = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/publickey.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser3();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var Input = require_input();
    var Output = require_output();
    var Sighash = require_sighash();
    var Script = require_script2();
    var Signature = require_signature3();
    var TransactionSignature = require_signature4();
    function PublicKeyInput() {
      Input.apply(this, arguments);
    }
    inherits2(PublicKeyInput, Input);
    PublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index2, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL;
      var publicKey = privateKey.toPublicKey();
      if (publicKey.toString() === this.output.script.getPublicKey().toString("hex")) {
        return [new TransactionSignature({
          publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index2,
          signature: Sighash.sign(transaction, privateKey, sigtype, index2, this.output.script, signingMethod),
          sigtype
        })];
      }
      return [];
    };
    PublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Signature is invalid");
      this.setScript(Script.buildPublicKeyIn(
        signature.signature.toDER(),
        signature.sigtype
      ));
      return this;
    };
    PublicKeyInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      return this;
    };
    PublicKeyInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyIn();
    };
    PublicKeyInput.SCRIPT_MAX_SIZE = 73;
    PublicKeyInput.prototype._estimateSize = function() {
      return this._getBaseSize() + PublicKeyInput.SCRIPT_MAX_SIZE;
    };
    module2.exports = PublicKeyInput;
  }
});

// node_modules/bitcore-lib/lib/transaction/sighashwitness.js
var require_sighashwitness = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/sighashwitness.js"(exports2, module2) {
    "use strict";
    var Signature = require_signature3();
    var Script = require_script2();
    var Output = require_output();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var BN = require_bn2();
    var Hash3 = require_hash2();
    var ECDSA = require_ecdsa();
    var $ = require_preconditions();
    var _ = require_lodash();
    var sighash = function sighash2(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {
      var hashPrevouts;
      var hashSequence;
      var hashOutputs;
      if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
        var buffers = [];
        for (var n = 0; n < transaction.inputs.length; n++) {
          var input = transaction.inputs[n];
          var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();
          buffers.push(prevTxIdBuffer);
          var outputIndexBuffer = Buffer.alloc(4);
          outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);
          buffers.push(outputIndexBuffer);
        }
        hashPrevouts = Hash3.sha256sha256(Buffer.concat(buffers));
      }
      if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {
        var sequenceBuffers = [];
        for (var m = 0; m < transaction.inputs.length; m++) {
          var sequenceBuffer = Buffer.alloc(4);
          sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);
          sequenceBuffers.push(sequenceBuffer);
        }
        hashSequence = Hash3.sha256sha256(Buffer.concat(sequenceBuffers));
      }
      var outputWriter = new BufferWriter();
      if ((sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {
        for (var p = 0; p < transaction.outputs.length; p++) {
          transaction.outputs[p].toBufferWriter(outputWriter);
        }
        hashOutputs = Hash3.sha256sha256(outputWriter.toBuffer());
      } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
        transaction.outputs[inputNumber].toBufferWriter(outputWriter);
        hashOutputs = Hash3.sha256sha256(outputWriter.toBuffer());
      }
      var writer = new BufferWriter();
      writer.writeUInt32LE(transaction.version);
      writer.write(hashPrevouts);
      writer.write(hashSequence);
      var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();
      writer.write(outpointId);
      writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);
      writer.write(scriptCode);
      writer.write(satoshisBuffer);
      writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);
      writer.write(hashOutputs);
      writer.writeUInt32LE(transaction.nLockTime);
      writer.writeInt32LE(sighashType);
      return Hash3.sha256sha256(writer.toBuffer());
    };
    function sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      var sig;
      if (signingMethod === "ecdsa") {
        let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);
        sig = ECDSA.sign(hashbuf, privateKey).set({
          nhashtype: sighashType
        });
        return sig;
      }
      throw new Error("signingMethod not supported ", signingMethod);
    }
    function verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
      $.checkArgument(!_.isUndefined(transaction));
      $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
      signingMethod = signingMethod || "ecdsa";
      if (signingMethod === "ecdsa") {
        let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);
        return ECDSA.verify(hashbuf, signature, publicKey);
      }
      throw new Error("signingMethod not supported ", signingMethod);
    }
    module2.exports = {
      sighash,
      sign,
      verify
    };
  }
});

// node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js
var require_publickeyhash = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser3();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var Address2 = require_address();
    var Hash3 = require_hash2();
    var Input = require_input();
    var Output = require_output();
    var Sighash = require_sighash();
    var SighashWitness = require_sighashwitness();
    var BufferWriter = require_bufferwriter();
    var BufferUtil = require_buffer3();
    var Script = require_script2();
    var Signature = require_signature3();
    var TransactionSignature = require_signature4();
    function PublicKeyHashInput() {
      Input.apply(this, arguments);
    }
    inherits2(PublicKeyHashInput, Input);
    PublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {
      if (!this.redeemScript) {
        var redeemScript = Script.buildWitnessV0Out(publicKey);
        if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {
          var scriptSig = new Script();
          scriptSig.add(redeemScript.toBuffer());
          this.setScript(scriptSig);
          this.redeemScript = redeemScript;
        }
      }
      return this.redeemScript;
    };
    PublicKeyHashInput.prototype.getScriptCode = function(publicKey) {
      var writer = new BufferWriter();
      var script;
      if (this.output.script.isScriptHashOut()) {
        script = this.getRedeemScript(publicKey);
      } else {
        script = this.output.script;
      }
      var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();
      writer.writeVarintNum(scriptBuffer.length);
      writer.write(scriptBuffer);
      return writer.toBuffer();
    };
    PublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index2, sigtype) {
      var scriptCode = this.getScriptCode(privateKey);
      var satoshisBuffer = this.getSatoshisBuffer();
      return SighashWitness.sighash(transaction, sigtype, index2, scriptCode, satoshisBuffer);
    };
    PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index2, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      hashData = hashData || Hash3.sha256ripemd160(privateKey.publicKey.toBuffer());
      sigtype = sigtype || Signature.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      var script;
      if (this.output.script.isScriptHashOut()) {
        script = this.getRedeemScript(privateKey.publicKey);
      } else {
        script = this.output.script;
      }
      if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {
        var signature;
        if (script.isWitnessPublicKeyHashOut()) {
          var satoshisBuffer = this.getSatoshisBuffer();
          var scriptCode = this.getScriptCode(privateKey.publicKey);
          signature = SighashWitness.sign(transaction, privateKey, sigtype, index2, scriptCode, satoshisBuffer, signingMethod);
        } else {
          signature = Sighash.sign(transaction, privateKey, sigtype, index2, this.output.script, signingMethod);
        }
        return [new TransactionSignature({
          publicKey: privateKey.publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index2,
          signature,
          sigtype
        })];
      }
      return [];
    };
    PublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Signature is invalid");
      if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
        this.setWitnesses([
          BufferUtil.concat([
            signature.signature.toDER(),
            BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
          ]),
          signature.publicKey.toBuffer()
        ]);
      } else {
        this.setScript(Script.buildPublicKeyHashIn(
          signature.publicKey,
          signature.signature.toDER(),
          signature.sigtype
        ));
      }
      return this;
    };
    PublicKeyHashInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      this.setWitnesses([]);
      return this;
    };
    PublicKeyHashInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyHashIn() || this.hasWitnesses();
    };
    PublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signature.signature.nhashtype = signature.sigtype;
      if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
        var scriptCode = this.getScriptCode();
        var satoshisBuffer = this.getSatoshisBuffer();
        return SighashWitness.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          scriptCode,
          satoshisBuffer,
          signingMethod
        );
      } else {
        return Sighash.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          this.output.script,
          signingMethod
        );
      }
    };
    PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34;
    PublicKeyHashInput.REDEEM_SCRIPT_SIZE = 1 + 22;
    PublicKeyHashInput.prototype._estimateSize = function() {
      let result = this._getBaseSize();
      result += 1;
      const WITNESS_DISCOUNT = 4;
      const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;
      if (this.output.script.isWitnessPublicKeyHashOut()) {
        result += witnessSize;
      } else if (this.output.script.isScriptHashOut()) {
        result += witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;
      } else {
        result += PublicKeyHashInput.SCRIPT_MAX_SIZE;
      }
      return result;
    };
    module2.exports = PublicKeyHashInput;
  }
});

// node_modules/bitcore-lib/lib/transaction/input/multisig.js
var require_multisig = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/multisig.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var inherits2 = require_inherits_browser3();
    var Transaction = require_transaction();
    var Input = require_input();
    var Output = require_output();
    var $ = require_preconditions();
    var Script = require_script2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var PublicKey = require_publickey2();
    var BufferUtil = require_buffer3();
    var TransactionSignature = require_signature4();
    function MultiSigInput(input, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      var self2 = this;
      pubkeys = pubkeys || input.publicKeys;
      threshold = threshold || input.threshold;
      signatures = signatures || input.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      $.checkState(
        Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
        "Provided public keys don't match to the provided output script"
      );
      this.publicKeyIndex = {};
      _.each(this.publicKeys, function(publicKey, index2) {
        self2.publicKeyIndex[publicKey.toString()] = index2;
      });
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
    }
    inherits2(MultiSigInput, Input);
    MultiSigInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = _.map(this.publicKeys, function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigInput.prototype._deserializeSignatures = function(signatures) {
      return _.map(signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return new TransactionSignature(signature);
      });
    };
    MultiSigInput.prototype._serializeSignatures = function() {
      return _.map(this.signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return signature.toObject();
      });
    };
    MultiSigInput.prototype.getSignatures = function(transaction, privateKey, index2, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      var self2 = this;
      var results = [];
      _.each(this.publicKeys, function(publicKey) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: self2.prevTxId,
            outputIndex: self2.outputIndex,
            inputIndex: index2,
            signature: Sighash.sign(transaction, privateKey, sigtype, index2, self2.output.script, signingMethod),
            sigtype
          }));
        }
      });
      return results;
    };
    MultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $.checkArgument(
        !_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], "Signature Undefined"),
        "Signature has no matching public key"
      );
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature");
      this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
      this._updateScript();
      return this;
    };
    MultiSigInput.prototype._updateScript = function() {
      this.setScript(Script.buildMultisigIn(
        this.publicKeys,
        this.threshold,
        this._createSignatures()
      ));
      return this;
    };
    MultiSigInput.prototype._createSignatures = function() {
      return _.map(
        _.filter(this.signatures, function(signature) {
          return !_.isUndefined(signature);
        }),
        function(signature) {
          return BufferUtil.concat([
            signature.signature.toDER(),
            BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
          ]);
        }
      );
    };
    MultiSigInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigInput.prototype.countSignatures = function() {
      return _.reduce(this.signatures, function(sum, signature) {
        return sum + !!signature;
      }, 0);
    };
    MultiSigInput.prototype.publicKeysWithoutSignature = function() {
      var self2 = this;
      return _.filter(this.publicKeys, function(publicKey) {
        return !self2.signatures[self2.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.output.script,
        signingMethod
      );
    };
    MultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {
      return publicKeys.map(function(pubKey) {
        var signatureMatch = null;
        signatures = signatures.filter(function(signatureBuffer) {
          if (signatureMatch) {
            return true;
          }
          var signature = new TransactionSignature({
            signature: Signature.fromTxFormat(signatureBuffer),
            publicKey: pubKey,
            prevTxId: input.prevTxId,
            outputIndex: input.outputIndex,
            inputIndex,
            sigtype: Signature.SIGHASH_ALL
          });
          signature.signature.nhashtype = signature.sigtype;
          var isMatch = Sighash.verify(
            transaction,
            signature.signature,
            signature.publicKey,
            signature.inputIndex,
            input.output.script,
            signingMethod
          );
          if (isMatch) {
            signatureMatch = signature;
            return false;
          }
          return true;
        });
        return signatureMatch ? signatureMatch : null;
      });
    };
    MultiSigInput.OPCODES_SIZE = 1;
    MultiSigInput.SIGNATURE_SIZE = 73;
    MultiSigInput.prototype._estimateSize = function() {
      return this._getBaseSize() + MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;
    };
    module2.exports = MultiSigInput;
  }
});

// node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js
var require_multisigscripthash = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var inherits2 = require_inherits_browser3();
    var Input = require_input();
    var Output = require_output();
    var $ = require_preconditions();
    var Address2 = require_address();
    var Script = require_script2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var SighashWitness = require_sighashwitness();
    var BufferWriter = require_bufferwriter();
    var BufferUtil = require_buffer3();
    var TransactionSignature = require_signature4();
    function MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      pubkeys = pubkeys || input.publicKeys;
      threshold = threshold || input.threshold;
      signatures = signatures || input.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);
      var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);
      if (nested.equals(this.output.script)) {
        this.nestedWitness = false;
        this.type = Address2.PayToWitnessScriptHash;
      } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {
        this.nestedWitness = true;
        this.type = Address2.PayToScriptHash;
      } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {
        this.nestedWitness = false;
        this.type = Address2.PayToScriptHash;
      } else {
        throw new Error("Provided public keys don't hash to the provided output");
      }
      if (this.nestedWitness) {
        var scriptSig = new Script();
        scriptSig.add(nested.toBuffer());
        this.setScript(scriptSig);
      }
      this.publicKeyIndex = {};
      for (let index2 = 0; index2 < this.publicKeys.length; index2++) {
        const publicKey = this.publicKeys[index2];
        this.publicKeyIndex[publicKey.toString()] = index2;
      }
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
    }
    inherits2(MultiSigScriptHashInput, Input);
    MultiSigScriptHashInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = this.publicKeys.map(function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
      return signatures.map(function(signature) {
        if (!signature) {
          return void 0;
        }
        return new TransactionSignature(signature);
      });
    };
    MultiSigScriptHashInput.prototype._serializeSignatures = function() {
      return this.signatures.map(function(signature) {
        if (!signature) {
          return void 0;
        }
        return signature.toObject();
      });
    };
    MultiSigScriptHashInput.prototype.getScriptCode = function() {
      var writer = new BufferWriter();
      if (!this.redeemScript.hasCodeseparators()) {
        var redeemScriptBuffer = this.redeemScript.toBuffer();
        writer.writeVarintNum(redeemScriptBuffer.length);
        writer.write(redeemScriptBuffer);
      } else {
        throw new Error("@TODO");
      }
      return writer.toBuffer();
    };
    MultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index2, sigtype) {
      var hash2;
      if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
        var scriptCode = this.getScriptCode();
        var satoshisBuffer = this.getSatoshisBuffer();
        hash2 = SighashWitness.sighash(transaction, sigtype, index2, scriptCode, satoshisBuffer);
      } else {
        hash2 = Sighash.sighash(transaction, sigtype, index2, this.redeemScript);
      }
      return hash2;
    };
    MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index2, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      const results = [];
      for (const publicKey of this.publicKeys) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          var signature;
          if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
            var scriptCode = this.getScriptCode();
            var satoshisBuffer = this.getSatoshisBuffer();
            signature = SighashWitness.sign(transaction, privateKey, sigtype, index2, scriptCode, satoshisBuffer, signingMethod);
          } else {
            signature = Sighash.sign(transaction, privateKey, sigtype, index2, this.redeemScript, signingMethod);
          }
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: this.prevTxId,
            outputIndex: this.outputIndex,
            inputIndex: index2,
            signature,
            sigtype
          }));
        }
      }
      return results;
    };
    MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $.checkArgument(
        this.publicKeyIndex[signature.publicKey.toString()] != null,
        "Signature has no matching public key"
      );
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature!");
      this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
      this._updateScript();
      return this;
    };
    MultiSigScriptHashInput.prototype._updateScript = function() {
      if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
        var stack = [
          Buffer.alloc(0)
        ];
        var signatures = this._createSignatures();
        for (var i = 0; i < signatures.length; i++) {
          stack.push(signatures[i]);
        }
        stack.push(this.redeemScript.toBuffer());
        this.setWitnesses(stack);
      } else {
        var scriptSig = Script.buildP2SHMultisigIn(
          this.publicKeys,
          this.threshold,
          this._createSignatures(),
          { cachedMultisig: this.redeemScript }
        );
        this.setScript(scriptSig);
      }
      return this;
    };
    MultiSigScriptHashInput.prototype._createSignatures = function() {
      return this.signatures.filter(function(signature) {
        return signature != null;
      }).map(function(signature) {
        return BufferUtil.concat([
          signature.signature.toDER(),
          BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
        ]);
      });
    };
    MultiSigScriptHashInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigScriptHashInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigScriptHashInput.prototype.countSignatures = function() {
      return this.signatures.reduce(function(sum, signature) {
        return sum + !!signature;
      }, 0);
    };
    MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
      return this.publicKeys.filter((publicKey) => {
        return !this.signatures[this.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
        signature.signature.nhashtype = signature.sigtype;
        var scriptCode = this.getScriptCode();
        var satoshisBuffer = this.getSatoshisBuffer();
        return SighashWitness.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          scriptCode,
          satoshisBuffer,
          signingMethod
        );
      } else {
        signature.signature.nhashtype = signature.sigtype;
        return Sighash.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          this.redeemScript,
          signingMethod
        );
      }
    };
    MultiSigScriptHashInput.MAX_OPCODES_SIZE = 8;
    MultiSigScriptHashInput.MAX_SIGNATURE_SIZE = 74;
    MultiSigScriptHashInput.MAX_PUBKEY_SIZE = 34;
    MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34;
    MultiSigScriptHashInput.prototype._estimateSize = function() {
      let result = this._getBaseSize();
      const WITNESS_DISCOUNT = 4;
      const witnessSize = MultiSigScriptHashInput.MAX_OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.MAX_SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.MAX_PUBKEY_SIZE;
      if (this.type === Address2.PayToWitnessScriptHash) {
        result += witnessSize / WITNESS_DISCOUNT;
      } else if (this.nestedWitness) {
        result += witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;
      } else {
        result += witnessSize;
      }
      return result;
    };
    module2.exports = MultiSigScriptHashInput;
  }
});

// node_modules/bitcore-lib/lib/transaction/input/index.js
var require_input2 = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/input/index.js"(exports2, module2) {
    module2.exports = require_input();
    module2.exports.PublicKey = require_publickey();
    module2.exports.PublicKeyHash = require_publickeyhash();
    module2.exports.MultiSig = require_multisig();
    module2.exports.MultiSigScriptHash = require_multisigscripthash();
  }
});

// node_modules/bitcore-lib/lib/transaction/sighash.js
var require_sighash = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/sighash.js"(exports2, module2) {
    "use strict";
    var Signature = require_signature3();
    var Script = require_script2();
    var Output = require_output();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var BN = require_bn2();
    var Hash3 = require_hash2();
    var ECDSA = require_ecdsa();
    var $ = require_preconditions();
    var _ = require_lodash();
    var schnorr2 = require_src();
    var SIGHASH_SINGLE_BUG = "0000000000000000000000000000000000000000000000000000000000000001";
    var BITS_64_ON = "ffffffffffffffff";
    var sighash = function sighash2(transaction, sighashType, inputNumber, subscript) {
      var Transaction = require_transaction();
      var Input = require_input2();
      var i;
      var txcopy = Transaction.shallowCopy(transaction);
      subscript = new Script(subscript);
      subscript.removeCodeseparators();
      for (i = 0; i < txcopy.inputs.length; i++) {
        txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
      }
      txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);
      if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {
        for (i = 0; i < txcopy.inputs.length; i++) {
          if (i !== inputNumber) {
            txcopy.inputs[i].sequenceNumber = 0;
          }
        }
      }
      if ((sighashType & 31) === Signature.SIGHASH_NONE) {
        txcopy.outputs = [];
      } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
        if (inputNumber >= txcopy.outputs.length) {
          return Buffer.from(SIGHASH_SINGLE_BUG, "hex");
        }
        txcopy.outputs.length = inputNumber + 1;
        for (i = 0; i < inputNumber; i++) {
          txcopy.outputs[i] = new Output({
            satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, "hex")),
            script: Script.empty()
          });
        }
      }
      if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
        txcopy.inputs = [txcopy.inputs[inputNumber]];
      }
      var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();
      var ret = Hash3.sha256sha256(buf);
      ret = new BufferReader(ret).readReverse();
      return ret;
    };
    function sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);
      let sig;
      switch (signingMethod) {
        case "ecdsa":
          sig = ECDSA.sign(hashbuf, privateKey, "little").set({ nhashtype: sighashType });
          break;
        case "schnorr":
          sig = schnorr2.sign(privateKey.toString(), hashbuf);
          break;
        default:
          throw new Error("signingMethod not supported ", signingMethod);
      }
      return sig;
    }
    function verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {
      $.checkArgument(!_.isUndefined(transaction), "Transaction Undefined");
      $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), "Signature Undefined");
      signingMethod = signingMethod || "ecdsa";
      let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);
      let verified = false;
      switch (signingMethod) {
        case "ecdsa":
          verified = ECDSA.verify(hashbuf, signature, publicKey, "little");
          break;
        case "schnorr":
          verified = schnorr2.verify(publicKey, hashbuf, signature);
          break;
        default:
          throw new Error("signingMethod not supported ", signingMethod);
      }
      return verified;
    }
    module2.exports = {
      sighash,
      sign,
      verify
    };
  }
});

// node_modules/bitcore-lib/lib/unit.js
var require_unit = __commonJS({
  "node_modules/bitcore-lib/lib/unit.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var errors = require_errors();
    var $ = require_preconditions();
    var UNITS = {
      "BTC": [1e8, 8],
      "mBTC": [1e5, 5],
      "uBTC": [100, 2],
      "bits": [100, 2],
      "satoshis": [1, 0]
    };
    function Unit(amount, code) {
      if (!(this instanceof Unit)) {
        return new Unit(amount, code);
      }
      if (_.isNumber(code)) {
        if (code <= 0) {
          throw new errors.Unit.InvalidRate(code);
        }
        amount = amount / code;
        code = Unit.BTC;
      }
      this._value = this._from(amount, code);
      var self2 = this;
      var defineAccesor = function(key) {
        Object.defineProperty(self2, key, {
          get: function() {
            return self2.to(key);
          },
          enumerable: true
        });
      };
      Object.keys(UNITS).forEach(defineAccesor);
    }
    Object.keys(UNITS).forEach(function(key) {
      Unit[key] = key;
    });
    Unit.fromObject = function fromObject(data) {
      $.checkArgument(_.isObject(data), "Argument is expected to be an object");
      return new Unit(data.amount, data.code);
    };
    Unit.fromBTC = function(amount) {
      return new Unit(amount, Unit.BTC);
    };
    Unit.fromMillis = Unit.fromMilis = function(amount) {
      return new Unit(amount, Unit.mBTC);
    };
    Unit.fromMicros = Unit.fromBits = function(amount) {
      return new Unit(amount, Unit.bits);
    };
    Unit.fromSatoshis = function(amount) {
      return new Unit(amount, Unit.satoshis);
    };
    Unit.fromFiat = function(amount, rate) {
      return new Unit(amount, rate);
    };
    Unit.prototype._from = function(amount, code) {
      if (!UNITS[code]) {
        throw new errors.Unit.UnknownCode(code);
      }
      return parseInt((amount * UNITS[code][0]).toFixed());
    };
    Unit.prototype.to = function(code) {
      if (_.isNumber(code)) {
        if (code <= 0) {
          throw new errors.Unit.InvalidRate(code);
        }
        return parseFloat((this.BTC * code).toFixed(2));
      }
      if (!UNITS[code]) {
        throw new errors.Unit.UnknownCode(code);
      }
      var value = this._value / UNITS[code][0];
      return parseFloat(value.toFixed(UNITS[code][1]));
    };
    Unit.prototype.toBTC = function() {
      return this.to(Unit.BTC);
    };
    Unit.prototype.toMillis = Unit.prototype.toMilis = function() {
      return this.to(Unit.mBTC);
    };
    Unit.prototype.toMicros = Unit.prototype.toBits = function() {
      return this.to(Unit.bits);
    };
    Unit.prototype.toSatoshis = function() {
      return this.to(Unit.satoshis);
    };
    Unit.prototype.atRate = function(rate) {
      return this.to(rate);
    };
    Unit.prototype.toString = function() {
      return this.satoshis + " satoshis";
    };
    Unit.prototype.toObject = Unit.prototype.toJSON = function toObject() {
      return {
        amount: this.BTC,
        code: Unit.BTC
      };
    };
    Unit.prototype.inspect = function() {
      return "<Unit: " + this.toString() + ">";
    };
    module2.exports = Unit;
  }
});

// node_modules/bitcore-lib/lib/transaction/unspentoutput.js
var require_unspentoutput = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/unspentoutput.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var JSUtil = require_js();
    var Script = require_script2();
    var Address2 = require_address();
    var Unit = require_unit();
    function UnspentOutput(data) {
      if (!(this instanceof UnspentOutput)) {
        return new UnspentOutput(data);
      }
      $.checkArgument(_.isObject(data), "Must provide an object from where to extract data");
      var address = data.address ? new Address2(data.address) : void 0;
      var txId = data.txid ? data.txid : data.txId;
      if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
        throw new Error("Invalid TXID in object", data);
      }
      var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
      if (!_.isNumber(outputIndex)) {
        throw new Error("Invalid outputIndex, received " + outputIndex);
      }
      $.checkArgument(
        !_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),
        "Must provide the scriptPubKey for that output!"
      );
      var script = new Script(data.scriptPubKey || data.script);
      $.checkArgument(
        !_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),
        "Must provide an amount for the output"
      );
      var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;
      $.checkArgument(_.isNumber(amount), "Amount must be a number");
      JSUtil.defineImmutable(this, {
        address,
        txId,
        outputIndex,
        script,
        satoshis: amount
      });
    }
    UnspentOutput.prototype.inspect = function() {
      return "<UnspentOutput: " + this.txId + ":" + this.outputIndex + ", satoshis: " + this.satoshis + ", address: " + this.address + ">";
    };
    UnspentOutput.prototype.toString = function() {
      return this.txId + ":" + this.outputIndex;
    };
    UnspentOutput.fromObject = function(data) {
      return new UnspentOutput(data);
    };
    UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {
      return {
        address: this.address ? this.address.toString() : void 0,
        txid: this.txId,
        vout: this.outputIndex,
        scriptPubKey: this.script.toBuffer().toString("hex"),
        amount: Unit.fromSatoshis(this.satoshis).toBTC()
      };
    };
    module2.exports = UnspentOutput;
  }
});

// node_modules/bitcore-lib/lib/transaction/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/transaction.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var buffer2 = require_buffer();
    var compare = Buffer.compare || require_buffer_compare();
    var errors = require_errors();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash3 = require_hash2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var SighashWitness = require_sighashwitness();
    var Address2 = require_address();
    var UnspentOutput = require_unspentoutput();
    var Input = require_input2();
    var PublicKeyHashInput = Input.PublicKeyHash;
    var PublicKeyInput = Input.PublicKey;
    var MultiSigScriptHashInput = Input.MultiSigScriptHash;
    var MultiSigInput = Input.MultiSig;
    var Output = require_output();
    var Script = require_script2();
    var PrivateKey = require_privatekey();
    var BN = require_bn2();
    function Transaction(serialized, opts) {
      if (!(this instanceof Transaction)) {
        return new Transaction(serialized);
      }
      this.inputs = [];
      this.outputs = [];
      this._inputAmount = void 0;
      this._outputAmount = void 0;
      if (serialized) {
        if (serialized instanceof Transaction) {
          return Transaction.shallowCopy(serialized);
        } else if (JSUtil.isHexa(serialized)) {
          this.fromString(serialized);
        } else if (BufferUtil.isBuffer(serialized)) {
          this.fromBuffer(serialized);
        } else if (_.isObject(serialized)) {
          this.fromObject(serialized, opts);
        } else {
          throw new errors.InvalidArgument("Must provide an object or string to deserialize a transaction");
        }
      } else {
        this._newTransaction();
      }
    }
    var CURRENT_VERSION = 2;
    var DEFAULT_NLOCKTIME = 0;
    var MAX_BLOCK_SIZE = 1e6;
    Transaction.DUST_AMOUNT = 546;
    Transaction.FEE_SECURITY_MARGIN = 150;
    Transaction.MAX_MONEY = 21e6 * 1e8;
    Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;
    Transaction.NLOCKTIME_MAX_VALUE = 4294967295;
    Transaction.FEE_PER_KB = 1e5;
    Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;
    Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;
    Transaction.shallowCopy = function(transaction) {
      var copy = new Transaction(transaction.toBuffer());
      return copy;
    };
    var hashProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        this._hash = new BufferReader(this._getHash()).readReverse().toString("hex");
        return this._hash;
      }
    };
    var witnessHashProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        return new BufferReader(this._getWitnessHash()).readReverse().toString("hex");
      }
    };
    Object.defineProperty(Transaction.prototype, "witnessHash", witnessHashProperty);
    Object.defineProperty(Transaction.prototype, "hash", hashProperty);
    Object.defineProperty(Transaction.prototype, "id", hashProperty);
    var ioProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._getInputAmount();
      }
    };
    Object.defineProperty(Transaction.prototype, "inputAmount", ioProperty);
    ioProperty.get = function() {
      return this._getOutputAmount();
    };
    Object.defineProperty(Transaction.prototype, "outputAmount", ioProperty);
    Object.defineProperty(Transaction.prototype, "size", {
      configurable: false,
      enumerable: false,
      get: function() {
        return this._calculateSize();
      }
    });
    Object.defineProperty(Transaction.prototype, "vsize", {
      configurable: false,
      enumerable: false,
      get: function() {
        return this._calculateVSize();
      }
    });
    Object.defineProperty(Transaction.prototype, "weight", {
      configurable: false,
      enumerable: false,
      get: function() {
        return this._calculateWeight();
      }
    });
    Transaction.prototype._getHash = function() {
      return Hash3.sha256sha256(this.toBuffer(true));
    };
    Transaction.prototype._getWitnessHash = function() {
      return Hash3.sha256sha256(this.toBuffer(false));
    };
    Transaction.prototype.serialize = function(unsafe) {
      if (true === unsafe || unsafe && unsafe.disableAll) {
        return this.uncheckedSerialize();
      } else {
        return this.checkedSerialize(unsafe);
      }
    };
    Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    Transaction.prototype.checkedSerialize = function(opts) {
      var serializationError = this.getSerializationError(opts);
      if (serializationError) {
        serializationError.message += " - For more information please see: https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks";
        throw serializationError;
      }
      return this.uncheckedSerialize();
    };
    Transaction.prototype.invalidSatoshis = function() {
      var invalid = false;
      for (var i = 0; i < this.outputs.length; i++) {
        if (this.outputs[i].invalidSatoshis()) {
          invalid = true;
        }
      }
      return invalid;
    };
    Transaction.prototype.getSerializationError = function(opts) {
      opts = opts || {};
      if (this.invalidSatoshis()) {
        return new errors.Transaction.InvalidSatoshis();
      }
      var unspent = this._getUnspentValue();
      var unspentError;
      if (unspent < 0) {
        if (!opts.disableMoreOutputThanInput) {
          unspentError = new errors.Transaction.InvalidOutputAmountSum();
        }
      } else {
        unspentError = this._hasFeeError(opts, unspent);
      }
      return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts);
    };
    Transaction.prototype._hasFeeError = function(opts, unspent) {
      if (this._fee != null && this._fee !== unspent) {
        return new errors.Transaction.FeeError.Different(
          "Unspent value is " + unspent + " but specified fee is " + this._fee
        );
      }
      if (!opts.disableLargeFees) {
        var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
        if (unspent > maximumFee) {
          if (this._missingChange()) {
            return new errors.Transaction.ChangeAddressMissing(
              "Fee is too large and no change address was provided"
            );
          }
          return new errors.Transaction.FeeError.TooLarge(
            "expected less than " + maximumFee + " but got " + unspent
          );
        }
      }
      if (!opts.disableSmallFees) {
        var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);
        if (unspent < minimumFee) {
          return new errors.Transaction.FeeError.TooSmall(
            "expected more than " + minimumFee + " but got " + unspent
          );
        }
      }
    };
    Transaction.prototype._missingChange = function() {
      return !this._changeScript;
    };
    Transaction.prototype._hasDustOutputs = function(opts) {
      if (opts.disableDustOutputs) {
        return;
      }
      var index2, output3;
      for (index2 in this.outputs) {
        output3 = this.outputs[index2];
        if (output3.satoshis < Transaction.DUST_AMOUNT && !output3.script.isDataOut()) {
          return new errors.Transaction.DustOutputs();
        }
      }
    };
    Transaction.prototype._isMissingSignatures = function(opts) {
      if (opts.disableIsFullySigned) {
        return;
      }
      if (!this.isFullySigned()) {
        return new errors.Transaction.MissingSignatures();
      }
    };
    Transaction.prototype.inspect = function() {
      return "<Transaction: " + this.uncheckedSerialize() + ">";
    };
    Transaction.prototype.toBuffer = function(noWitness) {
      var writer = new BufferWriter();
      return this.toBufferWriter(writer, noWitness).toBuffer();
    };
    Transaction.prototype.hasWitnesses = function() {
      for (var i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].hasWitnesses()) {
          return true;
        }
      }
      return false;
    };
    Transaction.prototype.toBufferWriter = function(writer, noWitness) {
      writer.writeInt32LE(this.version);
      const hasWitnesses = this.hasWitnesses();
      if (hasWitnesses && !noWitness) {
        writer.write(Buffer.from("0001", "hex"));
      }
      writer.writeVarintNum(this.inputs ? this.inputs.length : 0);
      for (const input of this.inputs || []) {
        input.toBufferWriter(writer);
      }
      writer.writeVarintNum(this.outputs ? this.outputs.length : 0);
      for (const output3 of this.outputs || []) {
        output3.toBufferWriter(writer);
      }
      if (hasWitnesses && !noWitness) {
        for (const input of this.inputs) {
          const witnesses = input.getWitnesses();
          writer.writeVarintNum(witnesses.length);
          for (let j = 0; j < witnesses.length; j++) {
            writer.writeVarintNum(witnesses[j].length);
            writer.write(witnesses[j]);
          }
        }
      }
      writer.writeUInt32LE(this.nLockTime);
      return writer;
    };
    Transaction.prototype.fromBuffer = function(buffer3) {
      var reader = new BufferReader(buffer3);
      return this.fromBufferReader(reader);
    };
    Transaction.prototype.fromBufferReader = function(reader) {
      $.checkArgument(!reader.finished(), "No transaction data received");
      this.version = reader.readInt32LE();
      var sizeTxIns = reader.readVarintNum();
      var hasWitnesses = false;
      if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {
        reader.pos += 1;
        hasWitnesses = true;
        sizeTxIns = reader.readVarintNum();
      }
      for (var i = 0; i < sizeTxIns; i++) {
        var input = Input.fromBufferReader(reader);
        this.inputs.push(input);
      }
      var sizeTxOuts = reader.readVarintNum();
      for (var j = 0; j < sizeTxOuts; j++) {
        this.outputs.push(Output.fromBufferReader(reader));
      }
      if (hasWitnesses) {
        for (var k = 0; k < sizeTxIns; k++) {
          var itemCount = reader.readVarintNum();
          var witnesses = [];
          for (var l = 0; l < itemCount; l++) {
            var size3 = reader.readVarintNum();
            var item = reader.read(size3);
            witnesses.push(item);
          }
          this.inputs[k].setWitnesses(witnesses);
        }
      }
      this.nLockTime = reader.readUInt32LE();
      return this;
    };
    Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {
      var inputs = [];
      this.inputs.forEach(function(input) {
        inputs.push(input.toObject());
      });
      var outputs = [];
      this.outputs.forEach(function(output3) {
        outputs.push(output3.toObject());
      });
      var obj = {
        hash: this.hash,
        version: this.version,
        inputs,
        outputs,
        nLockTime: this.nLockTime
      };
      if (this._changeScript) {
        obj.changeScript = this._changeScript.toString();
      }
      if (this._changeIndex != null) {
        obj.changeIndex = this._changeIndex;
      }
      if (this._fee != null) {
        obj.fee = this._fee;
      }
      return obj;
    };
    Transaction.prototype.fromObject = function fromObject(arg, opts) {
      $.checkArgument(_.isObject(arg) || arg instanceof Transaction);
      var transaction;
      if (arg instanceof Transaction) {
        transaction = arg.toObject();
      } else {
        transaction = arg;
      }
      for (const input of transaction.inputs || []) {
        if (!input.output || !input.output.script) {
          this.uncheckedAddInput(new Input(input));
          continue;
        }
        var script = new Script(input.output.script);
        var txin;
        if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {
          txin = new Input.MultiSigScriptHash(
            input,
            input.publicKeys,
            input.threshold,
            input.signatures,
            opts
          );
        } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {
          txin = new Input.PublicKeyHash(input);
        } else if (script.isPublicKeyOut()) {
          txin = new Input.PublicKey(input);
        } else {
          throw new errors.Transaction.Input.UnsupportedScript(input.output.script);
        }
        this.addInput(txin);
      }
      for (const output3 of transaction.outputs || []) {
        this.addOutput(new Output(output3));
      }
      if (transaction.changeIndex) {
        this._changeIndex = transaction.changeIndex;
      }
      if (transaction.changeScript) {
        this._changeScript = new Script(transaction.changeScript);
      }
      if (transaction.fee) {
        this._fee = transaction.fee;
      }
      this.nLockTime = transaction.nLockTime;
      this.version = transaction.version;
      this._checkConsistency(arg);
      return this;
    };
    Transaction.prototype._checkConsistency = function(arg) {
      if (this._changeIndex != null) {
        $.checkState(this._changeScript, "Change script is expected.");
        $.checkState(this.outputs[this._changeIndex], "Change index points to undefined output.");
        $.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), "Change output has an unexpected script.");
      }
      if (arg && arg.hash) {
        $.checkState(arg.hash === this.hash, "Hash in object does not match transaction hash.");
      }
    };
    Transaction.prototype.lockUntilDate = function(time) {
      $.checkArgument(time);
      if (!isNaN(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors.Transaction.LockTimeTooEarly();
      }
      if (_.isDate(time)) {
        time = time.getTime() / 1e3;
      }
      for (var i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = time;
      return this;
    };
    Transaction.prototype.lockUntilBlockHeight = function(height) {
      $.checkArgument(!isNaN(height));
      if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors.Transaction.BlockHeightTooHigh();
      }
      if (height < 0) {
        throw new errors.Transaction.NLockTimeOutOfRange();
      }
      for (var i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = height;
      return this;
    };
    Transaction.prototype.getLockTime = function() {
      if (!this.nLockTime) {
        return null;
      }
      if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        return this.nLockTime;
      }
      return new Date(1e3 * this.nLockTime);
    };
    Transaction.prototype.fromString = function(string) {
      this.fromBuffer(buffer2.Buffer.from(string, "hex"));
    };
    Transaction.prototype._newTransaction = function() {
      this.version = CURRENT_VERSION;
      this.nLockTime = DEFAULT_NLOCKTIME;
    };
    Transaction.prototype.from = function(utxo, pubkeys, threshold, opts) {
      if (Array.isArray(utxo)) {
        for (const u of utxo) {
          this.from(u, pubkeys, threshold, opts);
        }
        ;
        return this;
      }
      const exists3 = this.inputs.some(function(input) {
        return input.prevTxId.toString("hex") === utxo.txId && input.outputIndex === utxo.outputIndex;
      });
      if (exists3) {
        return this;
      }
      if (pubkeys && threshold) {
        this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);
      } else {
        this._fromNonP2SH(utxo);
      }
      return this;
    };
    Transaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts) {
      let indexes = [];
      for (let utxo of utxos) {
        const index2 = this.inputs.findIndex((i) => i.prevTxId.toString("hex") === utxo.txId && i.outputIndex === utxo.outputIndex);
        indexes.push(index2);
        if (index2 >= 0) {
          const sequenceNumber = this.inputs[index2].sequenceNumber;
          this.inputs[index2] = this._getInputFrom(utxo, pubkeys, threshold, opts);
          this.inputs[index2].sequenceNumber = sequenceNumber;
        }
      }
      return indexes;
    };
    Transaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {
      var clazz;
      utxo = new UnspentOutput(utxo);
      if (pubkeys && threshold) {
        if (utxo.script.isMultisigOut()) {
          clazz = MultiSigInput;
        } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {
          clazz = MultiSigScriptHashInput;
        }
      } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {
        clazz = PublicKeyHashInput;
      } else if (utxo.script.isPublicKeyOut()) {
        clazz = PublicKeyInput;
      } else {
        clazz = Input;
      }
      return clazz;
    };
    Transaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts) {
      utxo = new UnspentOutput(utxo);
      const InputClass = this._selectInputType(utxo, pubkeys, threshold);
      const input = {
        output: new Output({
          script: utxo.script,
          satoshis: utxo.satoshis
        }),
        prevTxId: utxo.txId,
        outputIndex: utxo.outputIndex,
        sequenceNumber: utxo.sequenceNumber,
        script: Script.empty()
      };
      let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : [];
      return new InputClass(input, ...args);
    };
    Transaction.prototype._fromNonP2SH = function(utxo) {
      const input = this._getInputFrom(utxo);
      this.addInput(input);
    };
    Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {
      $.checkArgument(
        threshold <= pubkeys.length,
        "Number of required signatures must be greater than the number of public keys"
      );
      const input = this._getInputFrom(utxo, pubkeys, threshold, opts);
      this.addInput(input);
    };
    Transaction.prototype.addInput = function(input, outputScript, satoshis) {
      $.checkArgumentType(input, Input, "input");
      if (!input.output && (outputScript == null || satoshis == null)) {
        throw new errors.Transaction.NeedMoreInfo("Need information about the UTXO script and satoshis");
      }
      if (!input.output && outputScript && satoshis != null) {
        outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
        $.checkArgumentType(satoshis, "number", "satoshis");
        input.output = new Output({
          script: outputScript,
          satoshis
        });
      }
      return this.uncheckedAddInput(input);
    };
    Transaction.prototype.uncheckedAddInput = function(input) {
      $.checkArgumentType(input, Input, "input");
      this.inputs.push(input);
      this._inputAmount = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.hasAllUtxoInfo = function() {
      return this.inputs.every(function(input) {
        return !!input.output;
      });
    };
    Transaction.prototype.fee = function(amount) {
      $.checkArgument(!isNaN(amount), "amount must be a number");
      this._fee = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.feePerKb = function(amount) {
      $.checkArgument(!isNaN(amount), "amount must be a number");
      this._feePerKb = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.feePerByte = function(amount) {
      $.checkArgument(!isNaN(amount), "amount must be a number");
      this._feePerByte = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.change = function(address) {
      $.checkArgument(address, "address is required");
      this._changeScript = Script.fromAddress(address);
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.getChangeOutput = function() {
      if (this._changeIndex != null) {
        return this.outputs[this._changeIndex];
      }
      return null;
    };
    Transaction.prototype.to = function(address, amount) {
      if (Array.isArray(address)) {
        for (const to of address) {
          this.to(to.address, to.satoshis);
        }
        return this;
      }
      $.checkArgument(
        JSUtil.isNaturalNumber(amount),
        "Amount is expected to be a positive integer"
      );
      this.addOutput(new Output({
        script: Script(new Address2(address)),
        satoshis: amount
      }));
      return this;
    };
    Transaction.prototype.addData = function(value) {
      this.addOutput(new Output({
        script: Script.buildDataOut(value),
        satoshis: 0
      }));
      return this;
    };
    Transaction.prototype.addOutput = function(output3) {
      $.checkArgumentType(output3, Output, "output");
      this._addOutput(output3);
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.clearOutputs = function() {
      this.outputs = [];
      this._clearSignatures();
      this._outputAmount = void 0;
      this._changeIndex = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype._addOutput = function(output3) {
      this.outputs.push(output3);
      this._outputAmount = void 0;
    };
    Transaction.prototype._getOutputAmount = function() {
      if (this._outputAmount == null) {
        var self2 = this;
        this._outputAmount = 0;
        for (const output3 of this.outputs || []) {
          self2._outputAmount += output3.satoshis;
        }
      }
      return this._outputAmount;
    };
    Transaction.prototype._getInputAmount = function() {
      if (this._inputAmount == null) {
        this._inputAmount = _.sumBy(this.inputs, function(input) {
          if (input.output == null) {
            throw new errors.Transaction.Input.MissingPreviousOutput();
          }
          return input.output.satoshis;
        });
      }
      return this._inputAmount;
    };
    Transaction.prototype._updateChangeOutput = function(noClearSigs) {
      if (!this._changeScript) {
        return;
      }
      if (!noClearSigs) {
        this._clearSignatures();
      }
      if (this._changeIndex != null) {
        this._removeOutput(this._changeIndex);
      }
      var available = this._getUnspentValue();
      var fee = this.getFee();
      var changeAmount = available - fee;
      if (changeAmount > Transaction.DUST_AMOUNT) {
        this._changeIndex = this.outputs.length;
        this._addOutput(new Output({
          script: this._changeScript,
          satoshis: changeAmount
        }));
      } else {
        this._changeIndex = void 0;
      }
    };
    Transaction.prototype.getFee = function() {
      if (this.isCoinbase()) {
        return 0;
      }
      if (this._fee != null) {
        return this._fee;
      }
      if (!this._changeScript) {
        return this._getUnspentValue();
      }
      return this._estimateFee();
    };
    Transaction.prototype._estimateFee = function() {
      const estimatedSize = this._estimateSize();
      const available = this._getUnspentValue();
      const feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1e3;
      function getFee(size3) {
        return size3 * feeRate;
      }
      const fee = Math.ceil(getFee(estimatedSize));
      const feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(this._estimateSizeOfChangeOutput()));
      if (!this._changeScript || available <= feeWithChange) {
        return fee;
      }
      return feeWithChange;
    };
    Transaction.prototype._estimateSizeOfChangeOutput = function() {
      if (!this._changeScript) {
        return 0;
      }
      const scriptLen = this._changeScript.toBuffer().length;
      return 8 + BufferWriter.varintBufNum(scriptLen).length + scriptLen;
    };
    Transaction.prototype._getUnspentValue = function() {
      return this._getInputAmount() - this._getOutputAmount();
    };
    Transaction.prototype._clearSignatures = function() {
      for (const input of this.inputs || []) {
        input.clearSignatures();
      }
    };
    Transaction.prototype._estimateSize = function() {
      let result = 4;
      if (this.hasWitnesses()) {
        result += 0.5;
      }
      result += BufferWriter.varintBufNum(this.inputs.length).length;
      for (const input of this.inputs || []) {
        result += input._estimateSize();
      }
      result += BufferWriter.varintBufNum(this.outputs.length).length;
      for (const output3 of this.outputs || []) {
        result += output3.calculateSize();
      }
      result += 4;
      return Math.ceil(result);
    };
    Transaction.prototype._calculateSize = function() {
      return this.toBuffer().length;
    };
    Transaction.prototype._calculateVSize = function(noRound) {
      const vsize = this._calculateWeight() / 4;
      return noRound ? vsize : Math.ceil(vsize);
    };
    Transaction.prototype._calculateWeight = function() {
      return this.toBuffer(true).length * 3 + this.toBuffer(false).length;
    };
    Transaction.prototype._removeOutput = function(index2) {
      var output3 = this.outputs[index2];
      this.outputs = _.without(this.outputs, output3);
      this._outputAmount = void 0;
    };
    Transaction.prototype.removeOutput = function(index2) {
      this._removeOutput(index2);
      this._updateChangeOutput();
    };
    Transaction.prototype.sort = function() {
      this.sortInputs(function(inputs) {
        var copy = Array.prototype.concat.apply([], inputs);
        let i = 0;
        copy.forEach((x) => {
          x.i = i++;
        });
        copy.sort(function(first, second) {
          return compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex || first.i - second.i;
        });
        return copy;
      });
      this.sortOutputs(function(outputs) {
        var copy = Array.prototype.concat.apply([], outputs);
        let i = 0;
        copy.forEach((x) => {
          x.i = i++;
        });
        copy.sort(function(first, second) {
          return first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()) || first.i - second.i;
        });
        return copy;
      });
      return this;
    };
    Transaction.prototype.shuffleOutputs = function() {
      return this.sortOutputs(_.shuffle);
    };
    Transaction.prototype.sortOutputs = function(sortingFunction) {
      var outs = sortingFunction(this.outputs);
      return this._newOutputOrder(outs);
    };
    Transaction.prototype.sortInputs = function(sortingFunction) {
      this.inputs = sortingFunction(this.inputs);
      this._clearSignatures();
      return this;
    };
    Transaction.prototype._newOutputOrder = function(newOutputs) {
      var isInvalidSorting = this.outputs.length !== newOutputs.length || _.difference(this.outputs, newOutputs).length !== 0;
      if (isInvalidSorting) {
        throw new errors.Transaction.InvalidSorting();
      }
      if (this._changeIndex != null) {
        var changeOutput = this.outputs[this._changeIndex];
        this._changeIndex = newOutputs.indexOf(changeOutput);
      }
      this.outputs = newOutputs;
      return this;
    };
    Transaction.prototype.removeInput = function(txId, outputIndex) {
      var index2;
      if (!outputIndex && !isNaN(txId)) {
        index2 = txId;
      } else {
        index2 = this.inputs.findIndex(function(input2) {
          return input2.prevTxId.toString("hex") === txId && input2.outputIndex === outputIndex;
        });
      }
      if (index2 < 0 || index2 >= this.inputs.length) {
        throw new errors.Transaction.InvalidIndex(index2, this.inputs.length);
      }
      var input = this.inputs[index2];
      this.inputs = _.without(this.inputs, input);
      this._inputAmount = void 0;
      this._updateChangeOutput();
    };
    Transaction.prototype.sign = function(privateKey, sigtype, signingMethod) {
      $.checkState(this.hasAllUtxoInfo(), "Not all utxo information is available to sign the transaction.");
      if (Array.isArray(privateKey)) {
        for (const pk of privateKey) {
          this.sign(pk, sigtype, signingMethod);
        }
        return this;
      }
      for (const signature of this.getSignatures(privateKey, sigtype, signingMethod)) {
        this.applySignature(signature, signingMethod);
      }
      return this;
    };
    Transaction.prototype.getSignatures = function(privKey, sigtype, signingMethod) {
      privKey = new PrivateKey(privKey);
      sigtype = sigtype || Signature.SIGHASH_ALL;
      var transaction = this;
      var results = [];
      var hashData = Hash3.sha256ripemd160(privKey.publicKey.toBuffer());
      for (let index2 = 0; index2 < this.inputs.length; index2++) {
        const input = this.inputs[index2];
        for (const signature of input.getSignatures(transaction, privKey, index2, sigtype, hashData, signingMethod)) {
          results.push(signature);
        }
      }
      return results;
    };
    Transaction.prototype.applySignature = function(signature, signingMethod) {
      this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);
      return this;
    };
    Transaction.prototype.isFullySigned = function() {
      for (const input of this.inputs || []) {
        if (input.isFullySigned === Input.prototype.isFullySigned) {
          throw new errors.Transaction.UnableToVerifySignature(
            "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
          );
        }
      }
      return this.inputs.every(function(input) {
        return input.isFullySigned();
      });
    };
    Transaction.prototype.isValidSignature = function(signature, signingMethod) {
      if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
        throw new errors.Transaction.UnableToVerifySignature(
          "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
        );
      }
      return this.inputs[signature.inputIndex].isValidSignature(this, signature, signingMethod);
    };
    Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, signingMethod) {
      if (sigversion == null) {
        sigversion = 0;
      }
      if (sigversion === 1) {
        var subscriptBuffer = subscript.toBuffer();
        var scriptCodeWriter = new BufferWriter();
        scriptCodeWriter.writeVarintNum(subscriptBuffer.length);
        scriptCodeWriter.write(subscriptBuffer);
        var satoshisBuffer;
        if (satoshis) {
          $.checkState(JSUtil.isNaturalNumber(satoshis));
          satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();
        } else {
          satoshisBuffer = this.inputs[nin].getSatoshisBuffer();
        }
        var verified = SighashWitness.verify(
          this,
          sig,
          pubkey,
          nin,
          scriptCodeWriter.toBuffer(),
          satoshisBuffer,
          signingMethod
        );
        return verified;
      }
      return Sighash.verify(this, sig, pubkey, nin, subscript, signingMethod);
    };
    Transaction.prototype.verify = function() {
      if (this.inputs.length === 0) {
        return "transaction txins empty";
      }
      if (this.outputs.length === 0) {
        return "transaction txouts empty";
      }
      var valueoutbn = new BN(0);
      for (var i = 0; i < this.outputs.length; i++) {
        var txout = this.outputs[i];
        if (txout.invalidSatoshis()) {
          return "transaction txout " + i + " satoshis is invalid";
        }
        if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {
          return "transaction txout " + i + " greater than MAX_MONEY";
        }
        valueoutbn = valueoutbn.add(txout._satoshisBN);
        if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {
          return "transaction txout " + i + " total output greater than MAX_MONEY";
        }
      }
      if (this.toBuffer().length > MAX_BLOCK_SIZE) {
        return "transaction over the maximum block size";
      }
      var txinmap = {};
      for (i = 0; i < this.inputs.length; i++) {
        var txin = this.inputs[i];
        var inputid = txin.prevTxId + ":" + txin.outputIndex;
        if (txinmap[inputid] != null) {
          return "transaction input " + i + " duplicate input";
        }
        txinmap[inputid] = true;
      }
      var isCoinbase = this.isCoinbase();
      if (isCoinbase) {
        var buf = this.inputs[0]._scriptBuffer;
        if (buf.length < 2 || buf.length > 100) {
          return "coinbase transaction script size invalid";
        }
      } else {
        for (i = 0; i < this.inputs.length; i++) {
          if (this.inputs[i].isNull()) {
            return "transaction input " + i + " has null input";
          }
        }
      }
      return true;
    };
    Transaction.prototype.isCoinbase = function() {
      return this.inputs.length === 1 && this.inputs[0].isNull();
    };
    Transaction.prototype.isRBF = function() {
      for (var i = 0; i < this.inputs.length; i++) {
        var input = this.inputs[i];
        if (input.sequenceNumber < Input.MAXINT - 1) {
          return true;
        }
      }
      return false;
    };
    Transaction.prototype.enableRBF = function() {
      for (var i = 0; i < this.inputs.length; i++) {
        var input = this.inputs[i];
        if (input.sequenceNumber >= Input.MAXINT - 1) {
          input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;
        }
      }
      return this;
    };
    Transaction.prototype.setVersion = function(version) {
      $.checkArgument(
        JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,
        "Wrong version number"
      );
      this.version = version;
      return this;
    };
    module2.exports = Transaction;
  }
});

// node_modules/bitcore-lib/lib/transaction/index.js
var require_transaction2 = __commonJS({
  "node_modules/bitcore-lib/lib/transaction/index.js"(exports2, module2) {
    module2.exports = require_transaction();
    module2.exports.Input = require_input2();
    module2.exports.Output = require_output();
    module2.exports.UnspentOutput = require_unspentoutput();
    module2.exports.Signature = require_signature4();
    module2.exports.Sighash = require_sighash();
    module2.exports.SighashWitness = require_sighashwitness();
  }
});

// node_modules/bitcore-lib/lib/script/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/bitcore-lib/lib/script/interpreter.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var Script = require_script();
    var Opcode = require_opcode();
    var BN = require_bn2();
    var Hash3 = require_hash2();
    var Signature = require_signature3();
    var PublicKey = require_publickey2();
    var Interpreter = function Interpreter2(obj) {
      if (!(this instanceof Interpreter2)) {
        return new Interpreter2(obj);
      }
      if (obj) {
        this.initialize();
        this.set(obj);
      } else {
        this.initialize();
      }
    };
    Interpreter.SIGVERSION_BASE = 0;
    Interpreter.SIGVERSION_WITNESS_V0 = 1;
    Interpreter.SIGVERSION_TAPROOT = 2;
    Interpreter.SIGVERSION_TAPSCRIPT = 3;
    Interpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags) {
      var scriptPubKey = new Script();
      var stack = [];
      if (version === 0) {
        if (program.length === 32) {
          if (witness.length === 0) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY";
            return false;
          }
          var scriptPubKeyBuffer = witness[witness.length - 1];
          scriptPubKey = new Script(scriptPubKeyBuffer);
          var hash2 = Hash3.sha256(scriptPubKeyBuffer);
          if (hash2.toString("hex") !== program.toString("hex")) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH";
            return false;
          }
          stack = witness.slice(0, -1);
        } else if (program.length === 20) {
          if (witness.length !== 2) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH";
            return false;
          }
          scriptPubKey.add(Opcode.OP_DUP);
          scriptPubKey.add(Opcode.OP_HASH160);
          scriptPubKey.add(program);
          scriptPubKey.add(Opcode.OP_EQUALVERIFY);
          scriptPubKey.add(Opcode.OP_CHECKSIG);
          stack = witness;
        } else {
          this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH";
          return false;
        }
      } else if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {
        this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM";
        return false;
      } else {
        return true;
      }
      this.initialize();
      this.set({
        script: scriptPubKey,
        stack,
        sigversion: Interpreter.SIGVERSION_WITNESS_V0,
        satoshis,
        flags
      });
      if (!this.evaluate()) {
        return false;
      }
      if (this.stack.length !== 1) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE";
        return false;
      }
      var buf = this.stack[this.stack.length - 1];
      if (!Interpreter.castToBool(buf)) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK";
        return false;
      }
      return true;
    };
    Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {
      var Transaction = require_transaction2();
      if (_.isUndefined(tx)) {
        tx = new Transaction();
      }
      if (_.isUndefined(nin)) {
        nin = 0;
      }
      if (_.isUndefined(flags)) {
        flags = 0;
      }
      if (_.isUndefined(witness)) {
        witness = null;
      }
      if (_.isUndefined(satoshis)) {
        satoshis = 0;
      }
      this.set({
        script: scriptSig,
        tx,
        nin,
        sigversion: Interpreter.SIGVERSION_BASE,
        satoshis: 0,
        flags
      });
      var stackCopy;
      if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
        this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
        return false;
      }
      if (!this.evaluate()) {
        return false;
      }
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
        stackCopy = this.stack.slice();
      }
      var stack = this.stack;
      this.initialize();
      this.set({
        script: scriptPubkey,
        stack,
        tx,
        nin,
        flags
      });
      if (!this.evaluate()) {
        return false;
      }
      if (this.stack.length === 0) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_RESULT";
        return false;
      }
      var buf = this.stack[this.stack.length - 1];
      if (!Interpreter.castToBool(buf)) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK";
        return false;
      }
      var hadWitness = false;
      if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
        var witnessValues = {};
        if (scriptPubkey.isWitnessProgram(witnessValues)) {
          hadWitness = true;
          if (scriptSig.toBuffer().length !== 0) {
            return false;
          }
          if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {
            return false;
          }
        }
      }
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {
        if (!scriptSig.isPushOnly()) {
          this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
          return false;
        }
        if (stackCopy.length === 0) {
          throw new Error("internal error - stack copy empty");
        }
        var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
        var redeemScript = Script.fromBuffer(redeemScriptSerialized);
        stackCopy.pop();
        this.initialize();
        this.set({
          script: redeemScript,
          stack: stackCopy,
          tx,
          nin,
          flags
        });
        if (!this.evaluate()) {
          return false;
        }
        if (stackCopy.length === 0) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK";
          return false;
        }
        if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK";
          return false;
        }
        if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
          var p2shWitnessValues = {};
          if (redeemScript.isWitnessProgram(p2shWitnessValues)) {
            hadWitness = true;
            var redeemScriptPush = new Script();
            redeemScriptPush.add(redeemScript.toBuffer());
            if (scriptSig.toHex() !== redeemScriptPush.toHex()) {
              this.errstr = "SCRIPT_ERR_WITNESS_MALLEATED_P2SH";
              return false;
            }
            if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {
              return false;
            }
            stack = [stack[0]];
          }
        }
      }
      if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {
        if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0)
          throw "flags & SCRIPT_VERIFY_P2SH";
        if (stackCopy.length != 1) {
          this.errstr = "SCRIPT_ERR_CLEANSTACK";
          return false;
        }
      }
      if (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
        if (!hadWitness && witness.length > 0) {
          this.errstr = "SCRIPT_ERR_WITNESS_UNEXPECTED";
          return false;
        }
      }
      return true;
    };
    module2.exports = Interpreter;
    Interpreter.prototype.initialize = function(obj) {
      this.stack = [];
      this.altstack = [];
      this.pc = 0;
      this.satoshis = 0;
      this.sigversion = Interpreter.SIGVERSION_BASE;
      this.pbegincodehash = 0;
      this.nOpCount = 0;
      this.vfExec = [];
      this.errstr = "";
      this.flags = 0;
    };
    Interpreter.prototype.set = function(obj) {
      this.script = obj.script || this.script;
      this.tx = obj.tx || this.tx;
      this.nin = typeof obj.nin !== "undefined" ? obj.nin : this.nin;
      this.stack = obj.stack || this.stack;
      this.altstack = obj.altack || this.altstack;
      this.pc = typeof obj.pc !== "undefined" ? obj.pc : this.pc;
      this.pbegincodehash = typeof obj.pbegincodehash !== "undefined" ? obj.pbegincodehash : this.pbegincodehash;
      this.sigversion = typeof obj.sigversion !== "undefined" ? obj.sigversion : this.sigversion;
      this.satoshis = typeof obj.satoshis !== "undefined" ? obj.satoshis : this.satoshis;
      this.nOpCount = typeof obj.nOpCount !== "undefined" ? obj.nOpCount : this.nOpCount;
      this.vfExec = obj.vfExec || this.vfExec;
      this.errstr = obj.errstr || this.errstr;
      this.flags = typeof obj.flags !== "undefined" ? obj.flags : this.flags;
    };
    Interpreter.true = Buffer.from([1]);
    Interpreter.false = Buffer.from([]);
    Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;
    Interpreter.LOCKTIME_THRESHOLD = 5e8;
    Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);
    Interpreter.SCRIPT_VERIFY_NONE = 0;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = 1 << 12;
    Interpreter.SCRIPT_VERIFY_P2SH = 1 << 0;
    Interpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1;
    Interpreter.SCRIPT_VERIFY_DERSIG = 1 << 2;
    Interpreter.SCRIPT_VERIFY_LOW_S = 1 << 3;
    Interpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4;
    Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5;
    Interpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7;
    Interpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8, Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;
    Interpreter.SCRIPT_VERIFY_WITNESS = 1 << 10;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 11;
    Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10;
    Interpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13;
    Interpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14;
    Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = 1 << 15;
    Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;
    Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17;
    Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = 1 << 18;
    Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;
    Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;
    Interpreter.SEQUENCE_LOCKTIME_MASK = 65535;
    Interpreter.castToBool = function(buf) {
      for (var i = 0; i < buf.length; i++) {
        if (buf[i] !== 0) {
          if (i === buf.length - 1 && buf[i] === 128) {
            return false;
          }
          return true;
        }
      }
      return false;
    };
    Interpreter.prototype.checkSignatureEncoding = function(buf) {
      var sig;
      if (buf.length == 0) {
        return true;
      }
      if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {
        this.errstr = "SCRIPT_ERR_SIG_DER_INVALID_FORMAT";
        return false;
      } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
        sig = Signature.fromTxFormat(buf);
        if (!sig.hasLowS()) {
          this.errstr = "SCRIPT_ERR_SIG_DER_HIGH_S";
          return false;
        }
      } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
        sig = Signature.fromTxFormat(buf);
        if (!sig.hasDefinedHashtype()) {
          this.errstr = "SCRIPT_ERR_SIG_HASHTYPE";
          return false;
        }
      }
      return true;
    };
    Interpreter.prototype.checkPubkeyEncoding = function(buf) {
      if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {
        this.errstr = "SCRIPT_ERR_PUBKEYTYPE";
        return false;
      }
      if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Interpreter.SIGVERSION_WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {
        this.errstr = "SCRIPT_ERR_WITNESS_PUBKEYTYPE";
        return false;
      }
      return true;
    };
    Interpreter.prototype.evaluate = function() {
      if (this.script.toBuffer().length > 1e4) {
        this.errstr = "SCRIPT_ERR_SCRIPT_SIZE";
        return false;
      }
      try {
        while (this.pc < this.script.chunks.length) {
          var fSuccess = this.step();
          if (!fSuccess) {
            return false;
          }
        }
        if (this.stack.length + this.altstack.length > 1e3) {
          this.errstr = "SCRIPT_ERR_STACK_SIZE";
          return false;
        }
      } catch (e) {
        this.errstr = "SCRIPT_ERR_UNKNOWN_ERROR: " + e;
        return false;
      }
      if (this.vfExec.length > 0) {
        this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkLockTime = function(nLockTime) {
      if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {
        return false;
      }
      if (nLockTime.gt(new BN(this.tx.nLockTime))) {
        return false;
      }
      if (!this.tx.inputs[this.nin].isFinal()) {
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkSequence = function(nSequence) {
      var txToSequence = this.tx.inputs[this.nin].sequenceNumber;
      if (this.tx.version < 2) {
        return false;
      }
      if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
        return false;
      }
      var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
      var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);
      var nSequenceMasked = nSequence.and(nLockTimeMask);
      var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
      if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {
        return false;
      }
      if (nSequenceMasked.gt(txToSequenceMasked)) {
        return false;
      }
      return true;
    };
    Interpreter.prototype.step = function() {
      var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;
      var fExec = this.vfExec.indexOf(false) === -1;
      var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;
      var sig, pubkey;
      var fValue, fSuccess;
      var chunk = this.script.chunks[this.pc];
      this.pc++;
      var opcodenum = chunk.opcodenum;
      if (_.isUndefined(opcodenum)) {
        this.errstr = "SCRIPT_ERR_UNDEFINED_OPCODE";
        return false;
      }
      if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
        this.errstr = "SCRIPT_ERR_PUSH_SIZE";
        return false;
      }
      if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {
        this.errstr = "SCRIPT_ERR_OP_COUNT";
        return false;
      }
      if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {
        this.errstr = "SCRIPT_ERR_DISABLED_OPCODE";
        return false;
      }
      if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {
        if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
          this.errstr = "SCRIPT_ERR_MINIMALDATA";
          return false;
        }
        if (!chunk.buf) {
          this.stack.push(Interpreter.false);
        } else if (chunk.len !== chunk.buf.length) {
          throw new Error("Length of push value not equal to length of data");
        } else {
          this.stack.push(chunk.buf);
        }
      } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {
        switch (opcodenum) {
          case Opcode.OP_1NEGATE:
          case Opcode.OP_1:
          case Opcode.OP_2:
          case Opcode.OP_3:
          case Opcode.OP_4:
          case Opcode.OP_5:
          case Opcode.OP_6:
          case Opcode.OP_7:
          case Opcode.OP_8:
          case Opcode.OP_9:
          case Opcode.OP_10:
          case Opcode.OP_11:
          case Opcode.OP_12:
          case Opcode.OP_13:
          case Opcode.OP_14:
          case Opcode.OP_15:
          case Opcode.OP_16:
            {
              n = opcodenum - (Opcode.OP_1 - 1);
              buf = new BN(n).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_NOP:
            break;
          case Opcode.OP_NOP2:
          case Opcode.OP_CHECKLOCKTIMEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);
            if (nLockTime.lt(new BN(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if (!this.checkLockTime(nLockTime)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode.OP_NOP3:
          case Opcode.OP_CHECKSEQUENCEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);
            if (nSequence.lt(new BN(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {
              break;
            }
            if (!this.checkSequence(nSequence)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode.OP_NOP1:
          case Opcode.OP_NOP4:
          case Opcode.OP_NOP5:
          case Opcode.OP_NOP6:
          case Opcode.OP_NOP7:
          case Opcode.OP_NOP8:
          case Opcode.OP_NOP9:
          case Opcode.OP_NOP10:
            {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
            }
            break;
          case Opcode.OP_IF:
          case Opcode.OP_NOTIF:
            {
              fValue = false;
              if (fExec) {
                if (this.stack.length < 1) {
                  this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                  return false;
                }
                buf = this.stack[this.stack.length - 1];
                if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
                  buf = this.stack[this.stack.length - 1];
                  if (buf.length > 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                  if (buf.length == 1 && buf[0] != 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                }
                fValue = Interpreter.castToBool(buf);
                if (opcodenum === Opcode.OP_NOTIF) {
                  fValue = !fValue;
                }
                this.stack.pop();
              }
              this.vfExec.push(fValue);
            }
            break;
          case Opcode.OP_ELSE:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
            }
            break;
          case Opcode.OP_ENDIF:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec.pop();
            }
            break;
          case Opcode.OP_VERIFY:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.pop();
              } else {
                this.errstr = "SCRIPT_ERR_VERIFY";
                return false;
              }
            }
            break;
          case Opcode.OP_RETURN:
            {
              this.errstr = "SCRIPT_ERR_OP_RETURN";
              return false;
            }
            break;
          case Opcode.OP_TOALTSTACK:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.altstack.push(this.stack.pop());
            }
            break;
          case Opcode.OP_FROMALTSTACK:
            {
              if (this.altstack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION";
                return false;
              }
              this.stack.push(this.altstack.pop());
            }
            break;
          case Opcode.OP_2DROP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
            }
            break;
          case Opcode.OP_2DUP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 2];
              buf2 = this.stack[this.stack.length - 1];
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode.OP_3DUP:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 3];
              buf2 = this.stack[this.stack.length - 2];
              var buf3 = this.stack[this.stack.length - 1];
              this.stack.push(buf1);
              this.stack.push(buf2);
              this.stack.push(buf3);
            }
            break;
          case Opcode.OP_2OVER:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 4];
              buf2 = this.stack[this.stack.length - 3];
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode.OP_2ROT:
            {
              if (this.stack.length < 6) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 6, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode.OP_2SWAP:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 4, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode.OP_IFDUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.push(buf);
              }
            }
            break;
          case Opcode.OP_DEPTH:
            {
              buf = new BN(this.stack.length).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_DROP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
            }
            break;
          case Opcode.OP_DUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(this.stack[this.stack.length - 1]);
            }
            break;
          case Opcode.OP_NIP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 1);
            }
            break;
          case Opcode.OP_OVER:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(this.stack[this.stack.length - 2]);
            }
            break;
          case Opcode.OP_PICK:
          case Opcode.OP_ROLL:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
              n = bn.toNumber();
              this.stack.pop();
              if (n < 0 || n >= this.stack.length) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - n - 1];
              if (opcodenum === Opcode.OP_ROLL) {
                this.stack.splice(this.stack.length - n - 1, 1);
              }
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_ROT:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = this.stack[this.stack.length - 3];
              x2 = this.stack[this.stack.length - 2];
              var x3 = this.stack[this.stack.length - 1];
              this.stack[this.stack.length - 3] = x2;
              this.stack[this.stack.length - 2] = x3;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode.OP_SWAP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = this.stack[this.stack.length - 2];
              x2 = this.stack[this.stack.length - 1];
              this.stack[this.stack.length - 2] = x2;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode.OP_TUCK:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
            }
            break;
          case Opcode.OP_SIZE:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn = new BN(this.stack[this.stack.length - 1].length);
              this.stack.push(bn.toScriptNumBuffer());
            }
            break;
          case Opcode.OP_EQUAL:
          case Opcode.OP_EQUALVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 2];
              buf2 = this.stack[this.stack.length - 1];
              var fEqual = buf1.toString("hex") === buf2.toString("hex");
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_EQUALVERIFY) {
                if (fEqual) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_EQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_1ADD:
          case Opcode.OP_1SUB:
          case Opcode.OP_NEGATE:
          case Opcode.OP_ABS:
          case Opcode.OP_NOT:
          case Opcode.OP_0NOTEQUAL:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
              switch (opcodenum) {
                case Opcode.OP_1ADD:
                  bn = bn.add(BN.One);
                  break;
                case Opcode.OP_1SUB:
                  bn = bn.sub(BN.One);
                  break;
                case Opcode.OP_NEGATE:
                  bn = bn.neg();
                  break;
                case Opcode.OP_ABS:
                  if (bn.cmp(BN.Zero) < 0) {
                    bn = bn.neg();
                  }
                  break;
                case Opcode.OP_NOT:
                  bn = new BN((bn.cmp(BN.Zero) === 0) + 0);
                  break;
                case Opcode.OP_0NOTEQUAL:
                  bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);
                  break;
              }
              this.stack.pop();
              this.stack.push(bn.toScriptNumBuffer());
            }
            break;
          case Opcode.OP_ADD:
          case Opcode.OP_SUB:
          case Opcode.OP_BOOLAND:
          case Opcode.OP_BOOLOR:
          case Opcode.OP_NUMEQUAL:
          case Opcode.OP_NUMEQUALVERIFY:
          case Opcode.OP_NUMNOTEQUAL:
          case Opcode.OP_LESSTHAN:
          case Opcode.OP_GREATERTHAN:
          case Opcode.OP_LESSTHANOREQUAL:
          case Opcode.OP_GREATERTHANOREQUAL:
          case Opcode.OP_MIN:
          case Opcode.OP_MAX:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
              bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
              bn = new BN(0);
              switch (opcodenum) {
                case Opcode.OP_ADD:
                  bn = bn1.add(bn2);
                  break;
                case Opcode.OP_SUB:
                  bn = bn1.sub(bn2);
                  break;
                case Opcode.OP_BOOLAND:
                  bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);
                  break;
                case Opcode.OP_BOOLOR:
                  bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);
                  break;
                case Opcode.OP_NUMEQUAL:
                  bn = new BN((bn1.cmp(bn2) === 0) + 0);
                  break;
                case Opcode.OP_NUMEQUALVERIFY:
                  bn = new BN((bn1.cmp(bn2) === 0) + 0);
                  break;
                case Opcode.OP_NUMNOTEQUAL:
                  bn = new BN((bn1.cmp(bn2) !== 0) + 0);
                  break;
                case Opcode.OP_LESSTHAN:
                  bn = new BN((bn1.cmp(bn2) < 0) + 0);
                  break;
                case Opcode.OP_GREATERTHAN:
                  bn = new BN((bn1.cmp(bn2) > 0) + 0);
                  break;
                case Opcode.OP_LESSTHANOREQUAL:
                  bn = new BN((bn1.cmp(bn2) <= 0) + 0);
                  break;
                case Opcode.OP_GREATERTHANOREQUAL:
                  bn = new BN((bn1.cmp(bn2) >= 0) + 0);
                  break;
                case Opcode.OP_MIN:
                  bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;
                  break;
                case Opcode.OP_MAX:
                  bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;
                  break;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(bn.toScriptNumBuffer());
              if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
                if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_NUMEQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_WITHIN:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
              bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
              var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
              fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;
              this.stack.pop();
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fValue ? Interpreter.true : Interpreter.false);
            }
            break;
          case Opcode.OP_RIPEMD160:
          case Opcode.OP_SHA1:
          case Opcode.OP_SHA256:
          case Opcode.OP_HASH160:
          case Opcode.OP_HASH256:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              var bufHash;
              if (opcodenum === Opcode.OP_RIPEMD160) {
                bufHash = Hash3.ripemd160(buf);
              } else if (opcodenum === Opcode.OP_SHA1) {
                bufHash = Hash3.sha1(buf);
              } else if (opcodenum === Opcode.OP_SHA256) {
                bufHash = Hash3.sha256(buf);
              } else if (opcodenum === Opcode.OP_HASH160) {
                bufHash = Hash3.sha256ripemd160(buf);
              } else if (opcodenum === Opcode.OP_HASH256) {
                bufHash = Hash3.sha256sha256(buf);
              }
              this.stack.pop();
              this.stack.push(bufHash);
            }
            break;
          case Opcode.OP_CODESEPARATOR:
            {
              this.pbegincodehash = this.pc;
            }
            break;
          case Opcode.OP_CHECKSIG:
          case Opcode.OP_CHECKSIGVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bufSig = this.stack[this.stack.length - 2];
              bufPubkey = this.stack[this.stack.length - 1];
              if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              var tmpScript = new Script().add(bufSig);
              subscript.findAndDelete(tmpScript);
              try {
                sig = Signature.fromTxFormat(bufSig);
                pubkey = PublicKey.fromBuffer(bufPubkey, false);
                fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
              } catch (e) {
                fSuccess = false;
              }
              if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {
                this.errstr = "SCRIPT_ERR_NULLFAIL";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKSIGVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_CHECKMULTISIG:
          case Opcode.OP_CHECKMULTISIGVERIFY:
            {
              var i = 1;
              if (this.stack.length < i) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
              if (nKeysCount < 0 || nKeysCount > 20) {
                this.errstr = "SCRIPT_ERR_PUBKEY_COUNT";
                return false;
              }
              this.nOpCount += nKeysCount;
              if (this.nOpCount > 201) {
                this.errstr = "SCRIPT_ERR_OP_COUNT";
                return false;
              }
              var ikey = ++i;
              i += nKeysCount;
              var ikey2 = nKeysCount + 2;
              if (this.stack.length < i) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
              if (nSigsCount < 0 || nSigsCount > nKeysCount) {
                this.errstr = "SCRIPT_ERR_SIG_COUNT";
                return false;
              }
              var isig = ++i;
              i += nSigsCount;
              if (this.stack.length < i) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              for (var k = 0; k < nSigsCount; k++) {
                bufSig = this.stack[this.stack.length - isig - k];
                subscript.findAndDelete(new Script().add(bufSig));
              }
              fSuccess = true;
              while (fSuccess && nSigsCount > 0) {
                bufSig = this.stack[this.stack.length - isig];
                bufPubkey = this.stack[this.stack.length - ikey];
                if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                  return false;
                }
                var fOk;
                try {
                  sig = Signature.fromTxFormat(bufSig);
                  pubkey = PublicKey.fromBuffer(bufPubkey, false);
                  fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
                } catch (e) {
                  fOk = false;
                }
                if (fOk) {
                  isig++;
                  nSigsCount--;
                }
                ikey++;
                nKeysCount--;
                if (nSigsCount > nKeysCount) {
                  fSuccess = false;
                }
              }
              while (i-- > 1) {
                if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && this.stack[this.stack.length - 1].length) {
                  this.errstr = "SCRIPT_ERR_NULLFAIL";
                  return false;
                }
                if (ikey2 > 0) {
                  ikey2--;
                }
                this.stack.pop();
              }
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {
                this.errstr = "SCRIPT_ERR_SIG_NULLDUMMY";
                return false;
              }
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKMULTISIGVERIFY";
                  return false;
                }
              }
            }
            break;
          default:
            this.errstr = "SCRIPT_ERR_BAD_OPCODE";
            return false;
        }
      }
      return true;
    };
  }
});

// node_modules/bitcore-lib/lib/script/index.js
var require_script2 = __commonJS({
  "node_modules/bitcore-lib/lib/script/index.js"(exports2, module2) {
    module2.exports = require_script();
    module2.exports.Interpreter = require_interpreter();
  }
});

// node_modules/bitcore-lib/lib/address.js
var require_address = __commonJS({
  "node_modules/bitcore-lib/lib/address.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var errors = require_errors();
    var Base58Check = require_base58check();
    var Bech32 = require_bech32();
    var Networks = require_networks();
    var Hash3 = require_hash2();
    var JSUtil = require_js();
    var PublicKey = require_publickey2();
    function Address2(data, network, type, multisigType) {
      if (!(this instanceof Address2)) {
        return new Address2(data, network, type);
      }
      if (_.isArray(data) && _.isNumber(network)) {
        return Address2.createMultisig(data, network, type, false, multisigType);
      }
      if (data instanceof Address2) {
        return data;
      }
      $.checkArgument(data, "First argument is required, please include address data.", "guide/address.html");
      if (network && !Networks.get(network)) {
        throw new TypeError('Second argument must be "livenet" or "testnet".');
      }
      if (type && (type !== Address2.PayToPublicKeyHash && type !== Address2.PayToScriptHash && type !== Address2.PayToWitnessPublicKeyHash && type !== Address2.PayToWitnessScriptHash && type !== Address2.PayToTaproot)) {
        throw new TypeError('Third argument must be "pubkeyhash", "scripthash", "witnesspubkeyhash", "witnessscripthash", or "taproot".');
      }
      var info = this._classifyArguments(data, network, type);
      info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
      info.type = info.type || type || Address2.PayToPublicKeyHash;
      JSUtil.defineImmutable(this, {
        hashBuffer: info.hashBuffer,
        network: info.network,
        type: info.type
      });
      return this;
    }
    Address2.prototype._classifyArguments = function(data, network, type) {
      if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {
        return Address2._transformHash(data, network, type);
      } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {
        return Address2._transformBuffer(data, network, type);
      } else if (data instanceof PublicKey) {
        return Address2._transformPublicKey(data, network, type);
      } else if (data instanceof Script) {
        return Address2._transformScript(data, network);
      } else if (typeof data === "string") {
        return Address2._transformString(data, network, type);
      } else if (_.isObject(data)) {
        return Address2._transformObject(data);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
    };
    Address2.PayToPublicKeyHash = "pubkeyhash";
    Address2.PayToScriptHash = "scripthash";
    Address2.PayToWitnessPublicKeyHash = "witnesspubkeyhash";
    Address2.PayToWitnessScriptHash = "witnessscripthash";
    Address2.PayToTaproot = "taproot";
    Address2._transformHash = function(hash2, network, type) {
      var info = {};
      if (!(hash2 instanceof Buffer) && !(hash2 instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (hash2.length !== 20 && hash2.length !== 32) {
        throw new TypeError("Address hashbuffers must be either 20 or 32 bytes.");
      }
      info.hashBuffer = hash2;
      info.network = Networks.get(network) || Networks.defaultNetwork;
      info.type = type;
      return info;
    };
    Address2._transformObject = function(data) {
      $.checkArgument(data.hash || data.hashBuffer, "Must provide a `hash` or `hashBuffer` property");
      $.checkArgument(data.type, "Must provide a `type` property");
      return {
        hashBuffer: data.hash ? Buffer.from(data.hash, "hex") : data.hashBuffer,
        network: Networks.get(data.network) || Networks.defaultNetwork,
        type: data.type
      };
    };
    Address2._classifyFromVersion = function(buffer2) {
      var version = {};
      if (buffer2.length > 21) {
        var info = Bech32.decode(buffer2.toString("utf8"));
        if (info.version !== 0 && info.version !== 1) {
          throw new TypeError("Only witness v0 and v1 addresses are supported.");
        }
        if (info.version === 0) {
          if (info.data.length === 20) {
            version.type = Address2.PayToWitnessPublicKeyHash;
          } else if (info.data.length === 32) {
            version.type = Address2.PayToWitnessScriptHash;
          } else {
            throw new TypeError("Witness data must be either 20 or 32 bytes.");
          }
        } else if (info.version === 1) {
          if (info.data.length === 32) {
            version.type = Address2.PayToTaproot;
          } else {
            throw new TypeError("Witness data must be 32 bytes for v1");
          }
        } else {
        }
        version.network = Networks.get(info.prefix, "bech32prefix");
      } else {
        var pubkeyhashNetwork = Networks.get(buffer2[0], "pubkeyhash");
        var scripthashNetwork = Networks.get(buffer2[0], "scripthash");
        if (pubkeyhashNetwork) {
          version.network = pubkeyhashNetwork;
          version.type = Address2.PayToPublicKeyHash;
        } else if (scripthashNetwork) {
          version.network = scripthashNetwork;
          version.type = Address2.PayToScriptHash;
        }
      }
      return version;
    };
    Address2._transformBuffer = function(buffer2, network, type) {
      var info = {};
      if (!(buffer2 instanceof Buffer) && !(buffer2 instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (buffer2.length < 21) {
        throw new TypeError("Address buffer is incorrect length.");
      }
      var networkObj = Networks.get(network);
      var bufferVersion = Address2._classifyFromVersion(buffer2);
      if (network && !networkObj) {
        throw new TypeError("Unknown network");
      }
      if (!bufferVersion.network || networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey) {
        throw new TypeError("Address has mismatched network type.");
      }
      if (!bufferVersion.type || type && type !== bufferVersion.type) {
        throw new TypeError("Address has mismatched type.");
      }
      if (buffer2.length > 21) {
        info.hashBuffer = Bech32.decode(buffer2.toString("utf8")).data;
      } else {
        info.hashBuffer = buffer2.slice(1);
      }
      info.network = networkObj || bufferVersion.network;
      info.type = bufferVersion.type;
      return info;
    };
    Address2._transformPublicKey = function(pubkey, network, type) {
      var info = {};
      if (!(pubkey instanceof PublicKey)) {
        throw new TypeError("Address must be an instance of PublicKey.");
      }
      if (type && type !== Address2.PayToScriptHash && type !== Address2.PayToWitnessPublicKeyHash && type !== Address2.PayToPublicKeyHash && type !== Address2.PayToTaproot) {
        throw new TypeError("Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.");
      }
      if (!pubkey.compressed && (type === Address2.PayToScriptHash || type === Address2.PayToWitnessPublicKeyHash)) {
        throw new TypeError("Witness addresses must use compressed public keys.");
      }
      if (type === Address2.PayToScriptHash) {
        info.hashBuffer = Hash3.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());
      } else if (type === Address2.PayToTaproot) {
        info.hashBuffer = Hash3.sha256ripemd160(Script.buildWitnessV1Out(pubkey).toBuffer());
      } else {
        info.hashBuffer = Hash3.sha256ripemd160(pubkey.toBuffer());
      }
      info.type = type || Address2.PayToPublicKeyHash;
      return info;
    };
    Address2._transformScript = function(script, network) {
      $.checkArgument(script instanceof Script, "script must be a Script instance");
      var info = script.getAddressInfo(network);
      if (!info) {
        throw new errors.Script.CantDeriveAddress(script);
      }
      return info;
    };
    Address2.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {
      network = network || publicKeys[0].network || Networks.defaultNetwork;
      if (type && type !== Address2.PayToScriptHash && type !== Address2.PayToWitnessScriptHash) {
        throw new TypeError("Type must be either scripthash or witnessscripthash to create multisig.");
      }
      if (nestedWitness || type === Address2.PayToWitnessScriptHash) {
        publicKeys = _.map(publicKeys, PublicKey);
        for (var i = 0; i < publicKeys.length; i++) {
          if (!publicKeys[i].compressed) {
            throw new TypeError("Witness addresses must use compressed public keys.");
          }
        }
      }
      var redeemScript = Script.buildMultisigOut(publicKeys, threshold);
      if (nestedWitness) {
        return Address2.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);
      }
      return Address2.payingTo(redeemScript, network, type);
    };
    Address2._transformString = function(data, network, type) {
      if (typeof data !== "string") {
        throw new TypeError("data parameter supplied is not a string.");
      }
      if (data.length > 100) {
        throw new TypeError("address string is too long");
      }
      if (network && !Networks.get(network)) {
        throw new TypeError("Unknown network");
      }
      data = data.trim();
      try {
        var info = Address2._transformBuffer(Buffer.from(data, "utf8"), network, type);
        return info;
      } catch (e) {
        if (type === Address2.PayToWitnessPublicKeyHash || type === Address2.PayToWitnessScriptHash || type === Address2.PayToTaproot) {
          throw e;
        }
      }
      var addressBuffer = Base58Check.decode(data);
      var info = Address2._transformBuffer(addressBuffer, network, type);
      return info;
    };
    Address2.fromPublicKey = function(data, network, type) {
      var info = Address2._transformPublicKey(data, network, type);
      network = network || Networks.defaultNetwork;
      return new Address2(info.hashBuffer, network, info.type);
    };
    Address2.fromPublicKeyHash = function(hash2, network) {
      var info = Address2._transformHash(hash2);
      return new Address2(info.hashBuffer, network, Address2.PayToPublicKeyHash);
    };
    Address2.fromScriptHash = function(hash2, network, type) {
      $.checkArgument(hash2, "hash parameter is required");
      var info = Address2._transformHash(hash2);
      if (type === Address2.PayToWitnessScriptHash && hash2.length !== 32) {
        throw new TypeError("Address hashbuffer must be exactly 32 bytes for v0 witness script hash.");
      }
      var type = type || Address2.PayToScriptHash;
      return new Address2(info.hashBuffer, network, type);
    };
    Address2.payingTo = function(script, network, type) {
      $.checkArgument(script, "script is required");
      $.checkArgument(script instanceof Script, "script must be instance of Script");
      var hash2;
      if (type === Address2.PayToWitnessScriptHash) {
        hash2 = Hash3.sha256(script.toBuffer());
      } else {
        hash2 = Hash3.sha256ripemd160(script.toBuffer());
      }
      var type = type || Address2.PayToScriptHash;
      return Address2.fromScriptHash(hash2, network, type);
    };
    Address2.fromScript = function(script, network) {
      $.checkArgument(script instanceof Script, "script must be a Script instance");
      var info = Address2._transformScript(script, network);
      return new Address2(info.hashBuffer, network, info.type);
    };
    Address2.fromBuffer = function(buffer2, network, type) {
      var info = Address2._transformBuffer(buffer2, network, type);
      return new Address2(info.hashBuffer, info.network, info.type);
    };
    Address2.fromString = function(str, network, type) {
      var info = Address2._transformString(str, network, type);
      return new Address2(info.hashBuffer, info.network, info.type);
    };
    Address2.fromObject = function fromObject(obj) {
      $.checkState(
        JSUtil.isHexa(obj.hash),
        'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
      );
      var hashBuffer = Buffer.from(obj.hash, "hex");
      return new Address2(hashBuffer, obj.network, obj.type);
    };
    Address2.getValidationError = function(data, network, type) {
      var error;
      try {
        new Address2(data, network, type);
      } catch (e) {
        error = e;
      }
      return error;
    };
    Address2.isValid = function(data, network, type) {
      return !Address2.getValidationError(data, network, type);
    };
    Address2.prototype.isPayToPublicKeyHash = function() {
      return this.type === Address2.PayToPublicKeyHash;
    };
    Address2.prototype.isPayToScriptHash = function() {
      return this.type === Address2.PayToScriptHash;
    };
    Address2.prototype.isPayToWitnessPublicKeyHash = function() {
      return this.type === Address2.PayToWitnessPublicKeyHash;
    };
    Address2.prototype.isPayToWitnessScriptHash = function() {
      return this.type === Address2.PayToWitnessScriptHash;
    };
    Address2.prototype.isPayToTaproot = function() {
      return this.type === Address2.PayToTaproot;
    };
    Address2.prototype.toBuffer = function() {
      if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
        return Buffer.from(this.toString(), "utf8");
      }
      var version = Buffer.from([this.network[this.type]]);
      return Buffer.concat([version, this.hashBuffer]);
    };
    Address2.prototype.toObject = Address2.prototype.toJSON = function toObject() {
      return {
        hash: this.hashBuffer.toString("hex"),
        type: this.type,
        network: this.network.toString()
      };
    };
    Address2.prototype.toString = function() {
      if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {
        let prefix = this.network.bech32prefix;
        let version = 0;
        let encoding = Bech32.encodings.BECH32;
        if (this.isPayToTaproot()) {
          version = 1;
          encoding = Bech32.encodings.BECH32M;
        }
        return Bech32.encode(prefix, version, this.hashBuffer, encoding);
      }
      return Base58Check.encode(this.toBuffer());
    };
    Address2.prototype.inspect = function() {
      return "<Address: " + this.toString() + ", type: " + this.type + ", network: " + this.network + ">";
    };
    module2.exports = Address2;
    var Script = require_script2();
  }
});

// node_modules/bitcore-lib/lib/crypto/random.js
var require_random = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/random.js"(exports2, module2) {
    "use strict";
    function Random() {
    }
    Random.getRandomBuffer = function(size3) {
      if (process.browser)
        return Random.getRandomBufferBrowser(size3);
      else
        return Random.getRandomBufferNode(size3);
    };
    Random.getRandomBufferNode = function(size3) {
      var crypto4 = require_crypto();
      return crypto4.randomBytes(size3);
    };
    Random.getRandomBufferBrowser = function(size3) {
      if (!window.crypto && !window.msCrypto)
        throw new Error("window.crypto not available");
      if (window.crypto && window.crypto.getRandomValues)
        var crypto4 = window.crypto;
      else if (window.msCrypto && window.msCrypto.getRandomValues)
        var crypto4 = window.msCrypto;
      else
        throw new Error("window.crypto.getRandomValues not available");
      var bbuf = new Uint8Array(size3);
      crypto4.getRandomValues(bbuf);
      var buf = Buffer.from(bbuf);
      return buf;
    };
    Random.getPseudoRandomBuffer = function(size3) {
      var b32 = 4294967296;
      var b = Buffer.alloc(size3);
      var r;
      for (var i = 0; i <= size3; i++) {
        var j = Math.floor(i / 4);
        var k = i - j * 4;
        if (k === 0) {
          r = Math.random() * b32;
          b[i] = r & 255;
        } else {
          b[i] = (r = r >>> 8) & 255;
        }
      }
      return b;
    };
    module2.exports = Random;
  }
});

// node_modules/bitcore-lib/lib/privatekey.js
var require_privatekey = __commonJS({
  "node_modules/bitcore-lib/lib/privatekey.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var Address2 = require_address();
    var Base58Check = require_base58check();
    var BN = require_bn2();
    var JSUtil = require_js();
    var Networks = require_networks();
    var Point2 = require_point();
    var PublicKey = require_publickey2();
    var Random = require_random();
    var $ = require_preconditions();
    function PrivateKey(data, network) {
      if (!(this instanceof PrivateKey)) {
        return new PrivateKey(data, network);
      }
      if (data instanceof PrivateKey) {
        return data;
      }
      var info = this._classifyArguments(data, network);
      if (!info.bn || info.bn.cmp(new BN(0)) === 0) {
        throw new TypeError("Number can not be equal to zero, undefined, null or false");
      }
      if (!info.bn.lt(Point2.getN())) {
        throw new TypeError("Number must be less than N");
      }
      if (typeof info.network === "undefined") {
        throw new TypeError('Must specify the network ("livenet" or "testnet")');
      }
      JSUtil.defineImmutable(this, {
        bn: info.bn,
        compressed: info.compressed,
        network: info.network
      });
      Object.defineProperty(this, "publicKey", {
        configurable: false,
        enumerable: true,
        get: this.toPublicKey.bind(this)
      });
      return this;
    }
    PrivateKey.prototype._classifyArguments = function(data, network) {
      var info = {
        compressed: true,
        network: network ? Networks.get(network) : Networks.defaultNetwork
      };
      if (_.isUndefined(data) || _.isNull(data)) {
        info.bn = PrivateKey._getRandomBN();
      } else if (data instanceof BN) {
        info.bn = data;
      } else if (data instanceof Buffer || data instanceof Uint8Array) {
        info = PrivateKey._transformBuffer(data, network);
      } else if (data.bn && data.network) {
        info = PrivateKey._transformObject(data);
      } else if (!network && Networks.get(data)) {
        info.bn = PrivateKey._getRandomBN();
        info.network = Networks.get(data);
      } else if (typeof data === "string") {
        if (JSUtil.isHexa(data)) {
          info.bn = new BN(Buffer.from(data, "hex"));
        } else {
          info = PrivateKey._transformWIF(data, network);
        }
      } else {
        throw new TypeError("First argument is an unrecognized data type.");
      }
      return info;
    };
    PrivateKey._getRandomBN = function() {
      var condition;
      var bn;
      do {
        var privbuf = Random.getRandomBuffer(32);
        bn = BN.fromBuffer(privbuf);
        condition = bn.lt(Point2.getN());
      } while (!condition);
      return bn;
    };
    PrivateKey._transformBuffer = function(buf, network) {
      var info = {};
      if (buf.length === 32) {
        return PrivateKey._transformBNBuffer(buf, network);
      }
      info.network = Networks.get(buf[0], "privatekey");
      if (!info.network) {
        throw new Error("Invalid network");
      }
      if (network && info.network !== Networks.get(network)) {
        throw new TypeError("Private key network mismatch");
      }
      if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
        info.compressed = true;
      } else if (buf.length === 1 + 32) {
        info.compressed = false;
      } else {
        throw new Error("Length of buffer must be 33 (uncompressed) or 34 (compressed)");
      }
      info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));
      return info;
    };
    PrivateKey._transformBNBuffer = function(buf, network) {
      var info = {};
      info.network = Networks.get(network) || Networks.defaultNetwork;
      info.bn = BN.fromBuffer(buf);
      info.compressed = false;
      return info;
    };
    PrivateKey._transformWIF = function(str, network) {
      return PrivateKey._transformBuffer(Base58Check.decode(str), network);
    };
    PrivateKey.fromBuffer = function(arg, network) {
      return new PrivateKey(arg, network);
    };
    PrivateKey._transformObject = function(json) {
      var bn = new BN(json.bn, "hex");
      var network = Networks.get(json.network);
      return {
        bn,
        network,
        compressed: json.compressed
      };
    };
    PrivateKey.fromString = PrivateKey.fromWIF = function(str) {
      $.checkArgument(_.isString(str), "First argument is expected to be a string.");
      return new PrivateKey(str);
    };
    PrivateKey.fromObject = function(obj) {
      $.checkArgument(_.isObject(obj), "First argument is expected to be an object.");
      return new PrivateKey(obj);
    };
    PrivateKey.fromRandom = function(network) {
      var bn = PrivateKey._getRandomBN();
      return new PrivateKey(bn, network);
    };
    PrivateKey.getValidationError = function(data, network) {
      var error;
      try {
        new PrivateKey(data, network);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PrivateKey.isValid = function(data, network) {
      if (!data) {
        return false;
      }
      return !PrivateKey.getValidationError(data, network);
    };
    PrivateKey.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    PrivateKey.prototype.toWIF = function() {
      var network = this.network;
      var compressed = this.compressed;
      var buf;
      if (compressed) {
        buf = Buffer.concat([
          Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 }),
          Buffer.from([1])
        ]);
      } else {
        buf = Buffer.concat([
          Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 })
        ]);
      }
      return Base58Check.encode(buf);
    };
    PrivateKey.prototype.toBigNumber = function() {
      return this.bn;
    };
    PrivateKey.prototype.toBuffer = function() {
      return this.bn.toBuffer({ size: 32 });
    };
    PrivateKey.prototype.toBufferNoPadding = function() {
      return this.bn.toBuffer();
    };
    PrivateKey.prototype.toPublicKey = function() {
      if (!this._pubkey) {
        this._pubkey = PublicKey.fromPrivateKey(this);
      }
      return this._pubkey;
    };
    PrivateKey.prototype.toAddress = function(network, type) {
      var pubkey = this.toPublicKey();
      return Address2.fromPublicKey(pubkey, network || this.network, type);
    };
    PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {
      return {
        bn: this.bn.toString("hex"),
        compressed: this.compressed,
        network: this.network.toString()
      };
    };
    PrivateKey.prototype.inspect = function() {
      var uncompressed = !this.compressed ? ", uncompressed" : "";
      return "<PrivateKey: " + this.toString() + ", network: " + this.network + uncompressed + ">";
    };
    module2.exports = PrivateKey;
  }
});

// node_modules/bitcore-lib/lib/publickey.js
var require_publickey2 = __commonJS({
  "node_modules/bitcore-lib/lib/publickey.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var Point2 = require_point();
    var Hash3 = require_hash2();
    var JSUtil = require_js();
    var Network = require_networks();
    var _ = require_lodash();
    var $ = require_preconditions();
    function PublicKey(data, extra) {
      if (!(this instanceof PublicKey)) {
        return new PublicKey(data, extra);
      }
      $.checkArgument(data, "First argument is required, please include public key data.");
      if (data instanceof PublicKey) {
        return data;
      }
      extra = extra || {};
      var info = this._classifyArgs(data, extra);
      info.point.validate();
      JSUtil.defineImmutable(this, {
        point: info.point,
        compressed: info.compressed,
        network: info.network || Network.defaultNetwork
      });
      return this;
    }
    PublicKey.prototype._classifyArgs = function(data, extra) {
      var info = {
        compressed: _.isUndefined(extra.compressed) || extra.compressed
      };
      if (data instanceof Point2) {
        info.point = data;
      } else if (data.x && data.y) {
        info = PublicKey._transformObject(data);
      } else if (typeof data === "string") {
        info = PublicKey._transformDER(Buffer.from(data, "hex"));
      } else if (PublicKey._isBuffer(data)) {
        info = PublicKey._transformDER(data);
      } else if (PublicKey._isPrivateKey(data)) {
        info = PublicKey._transformPrivateKey(data);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
      if (!info.network) {
        info.network = _.isUndefined(extra.network) ? void 0 : Network.get(extra.network);
      }
      return info;
    };
    PublicKey._isPrivateKey = function(param) {
      var PrivateKey = require_privatekey();
      return param instanceof PrivateKey;
    };
    PublicKey._isBuffer = function(param) {
      return param instanceof Buffer || param instanceof Uint8Array;
    };
    PublicKey._transformPrivateKey = function(privkey) {
      $.checkArgument(PublicKey._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = {};
      info.point = Point2.getG().mul(privkey.bn);
      info.compressed = privkey.compressed;
      info.network = privkey.network;
      return info;
    };
    PublicKey._transformDER = function(buf, strict) {
      $.checkArgument(PublicKey._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = {};
      strict = _.isUndefined(strict) ? true : strict;
      var x;
      var y;
      var xbuf;
      var ybuf;
      if (buf[0] === 4 || !strict && (buf[0] === 6 || buf[0] === 7)) {
        xbuf = buf.slice(1, 33);
        ybuf = buf.slice(33, 65);
        if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
          throw new TypeError("Length of x and y must be 32 bytes");
        }
        x = new BN(xbuf);
        y = new BN(ybuf);
        info.point = new Point2(x, y);
        info.compressed = false;
      } else if (buf[0] === 3) {
        xbuf = buf.slice(1);
        x = new BN(xbuf);
        info = PublicKey._transformX(true, x);
        info.compressed = true;
      } else if (buf[0] === 2) {
        xbuf = buf.slice(1);
        x = new BN(xbuf);
        info = PublicKey._transformX(false, x);
        info.compressed = true;
      } else {
        throw new TypeError("Invalid DER format public key");
      }
      return info;
    };
    PublicKey._transformX = function(odd, x) {
      $.checkArgument(typeof odd === "boolean", "Must specify whether y is odd or not (true or false)");
      var info = {};
      info.point = Point2.fromX(odd, x);
      return info;
    };
    PublicKey._transformObject = function(json) {
      var x = new BN(json.x, "hex");
      var y = new BN(json.y, "hex");
      var point = new Point2(x, y);
      return new PublicKey(point, {
        compressed: json.compressed
      });
    };
    PublicKey.fromPrivateKey = function(privkey) {
      $.checkArgument(PublicKey._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = PublicKey._transformPrivateKey(privkey);
      return new PublicKey(info.point, {
        compressed: info.compressed,
        network: info.network
      });
    };
    PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {
      $.checkArgument(PublicKey._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = PublicKey._transformDER(buf, strict);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.fromPoint = function(point, compressed) {
      $.checkArgument(point instanceof Point2, "First argument must be an instance of Point.");
      return new PublicKey(point, {
        compressed
      });
    };
    PublicKey.fromString = function(str, encoding) {
      var buf = Buffer.from(str, encoding || "hex");
      var info = PublicKey._transformDER(buf);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.fromX = function(odd, x) {
      var info = PublicKey._transformX(odd, x);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.getValidationError = function(data) {
      var error;
      try {
        new PublicKey(data);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PublicKey.isValid = function(data) {
      return !PublicKey.getValidationError(data);
    };
    PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {
      return {
        x: this.point.getX().toString("hex", 2),
        y: this.point.getY().toString("hex", 2),
        compressed: this.compressed
      };
    };
    PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {
      var x = this.point.getX();
      var y = this.point.getY();
      var xbuf = x.toBuffer({
        size: 32
      });
      var ybuf = y.toBuffer({
        size: 32
      });
      var prefix;
      if (!this.compressed) {
        prefix = Buffer.from([4]);
        return Buffer.concat([prefix, xbuf, ybuf]);
      } else {
        var odd = ybuf[ybuf.length - 1] % 2;
        if (odd) {
          prefix = Buffer.from([3]);
        } else {
          prefix = Buffer.from([2]);
        }
        return Buffer.concat([prefix, xbuf]);
      }
    };
    PublicKey.prototype._getID = function _getID() {
      return Hash3.sha256ripemd160(this.toBuffer());
    };
    PublicKey.prototype.toAddress = function(network, type) {
      var Address2 = require_address();
      return Address2.fromPublicKey(this, network || this.network, type);
    };
    PublicKey.prototype.toString = function() {
      return this.toDER().toString("hex");
    };
    PublicKey.prototype.inspect = function() {
      return "<PublicKey: " + this.toString() + (this.compressed ? "" : ", uncompressed") + ">";
    };
    module2.exports = PublicKey;
  }
});

// node_modules/bitcore-lib/lib/crypto/ecdsa.js
var require_ecdsa = __commonJS({
  "node_modules/bitcore-lib/lib/crypto/ecdsa.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var Point2 = require_point();
    var Signature = require_signature3();
    var PublicKey = require_publickey2();
    var Random = require_random();
    var Hash3 = require_hash2();
    var BufferUtil = require_buffer3();
    var _ = require_lodash();
    var $ = require_preconditions();
    var ECDSA = function ECDSA2(obj) {
      if (!(this instanceof ECDSA2)) {
        return new ECDSA2(obj);
      }
      if (obj) {
        this.set(obj);
      }
    };
    ECDSA.prototype.set = function(obj) {
      this.hashbuf = obj.hashbuf || this.hashbuf;
      this.endian = obj.endian || this.endian;
      this.privkey = obj.privkey || this.privkey;
      this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
      this.sig = obj.sig || this.sig;
      this.k = obj.k || this.k;
      this.verified = obj.verified || this.verified;
      return this;
    };
    ECDSA.prototype.privkey2pubkey = function() {
      this.pubkey = this.privkey.toPublicKey();
    };
    ECDSA.prototype.calci = function() {
      for (var i = 0; i < 4; i++) {
        this.sig.i = i;
        var Qprime;
        try {
          Qprime = this.toPublicKey();
        } catch (e) {
          console.error(e);
          continue;
        }
        if (Qprime.point.eq(this.pubkey.point)) {
          this.sig.compressed = this.pubkey.compressed;
          return this;
        }
      }
      this.sig.i = void 0;
      throw new Error("Unable to find valid recovery factor");
    };
    ECDSA.fromString = function(str) {
      var obj = JSON.parse(str);
      return new ECDSA(obj);
    };
    ECDSA.prototype.randomK = function() {
      var N = Point2.getN();
      var k;
      do {
        k = BN.fromBuffer(Random.getRandomBuffer(32));
      } while (!(k.lt(N) && k.gt(BN.Zero)));
      this.k = k;
      return this;
    };
    ECDSA.prototype.deterministicK = function(badrs) {
      if (_.isUndefined(badrs)) {
        badrs = 0;
      }
      var v = Buffer.alloc(32);
      v.fill(1);
      var k = Buffer.alloc(32);
      k.fill(0);
      var x = this.privkey.bn.toBuffer({
        size: 32
      });
      var hashbuf = this.endian === "little" ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;
      k = Hash3.sha256hmac(Buffer.concat([v, Buffer.from([0]), x, hashbuf]), k);
      v = Hash3.sha256hmac(v, k);
      k = Hash3.sha256hmac(Buffer.concat([v, Buffer.from([1]), x, hashbuf]), k);
      v = Hash3.sha256hmac(v, k);
      v = Hash3.sha256hmac(v, k);
      var T = BN.fromBuffer(v);
      var N = Point2.getN();
      for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {
        k = Hash3.sha256hmac(Buffer.concat([v, Buffer.from([0])]), k);
        v = Hash3.sha256hmac(v, k);
        v = Hash3.sha256hmac(v, k);
        T = BN.fromBuffer(v);
      }
      this.k = T;
      return this;
    };
    ECDSA.prototype.toPublicKey = function() {
      var i = this.sig.i;
      $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error("i must be equal to 0, 1, 2, or 3"));
      var e = BN.fromBuffer(this.hashbuf);
      var r = this.sig.r;
      var s = this.sig.s;
      var isYOdd = i & 1;
      var isSecondKey = i >> 1;
      var n = Point2.getN();
      var G = Point2.getG();
      var x = isSecondKey ? r.add(n) : r;
      var R = Point2.fromX(isYOdd, x);
      var nR = R.mul(n);
      if (!nR.isInfinity()) {
        throw new Error("nR is not a valid curve point");
      }
      var eNeg = e.neg().umod(n);
      var rInv = r.invm(n);
      var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);
      var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);
      return pubkey;
    };
    ECDSA.prototype.sigError = function() {
      if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
        return "hashbuf must be a 32 byte buffer";
      }
      var r = this.sig.r;
      var s = this.sig.s;
      if (!(r.gt(BN.Zero) && r.lt(Point2.getN())) || !(s.gt(BN.Zero) && s.lt(Point2.getN()))) {
        return "r and s not in range";
      }
      var e = BN.fromBuffer(this.hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var n = Point2.getN();
      var sinv = s.invm(n);
      var u1 = sinv.mul(e).umod(n);
      var u2 = sinv.mul(r).umod(n);
      var p = Point2.getG().mulAdd(u1, this.pubkey.point, u2);
      if (p.isInfinity()) {
        return "p is infinity";
      }
      if (p.getX().umod(n).cmp(r) !== 0) {
        return "Invalid signature";
      } else {
        return false;
      }
    };
    ECDSA.toLowS = function(s) {
      if (s.gt(BN.fromBuffer(Buffer.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex")))) {
        s = Point2.getN().sub(s);
      }
      return s;
    };
    ECDSA.prototype._findSignature = function(d, e) {
      var N = Point2.getN();
      var G = Point2.getG();
      var badrs = 0;
      var k, Q, r, s;
      do {
        if (!this.k || badrs > 0) {
          this.deterministicK(badrs);
        }
        badrs++;
        k = this.k;
        Q = G.mul(k);
        r = Q.x.umod(N);
        s = k.invm(N).mul(e.add(d.mul(r))).umod(N);
      } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);
      s = ECDSA.toLowS(s);
      return {
        s,
        r
      };
    };
    ECDSA.prototype.sign = function() {
      var hashbuf = this.hashbuf;
      var privkey = this.privkey;
      var d = privkey.bn;
      $.checkState(hashbuf && privkey && d, new Error("invalid parameters"));
      $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error("hashbuf must be a 32 byte buffer"));
      var e = BN.fromBuffer(hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var obj = this._findSignature(d, e);
      obj.compressed = this.pubkey.compressed;
      this.sig = new Signature(obj);
      return this;
    };
    ECDSA.prototype.signRandomK = function() {
      this.randomK();
      return this.sign();
    };
    ECDSA.prototype.toString = function() {
      var obj = {};
      if (this.hashbuf) {
        obj.hashbuf = this.hashbuf.toString("hex");
      }
      if (this.privkey) {
        obj.privkey = this.privkey.toString();
      }
      if (this.pubkey) {
        obj.pubkey = this.pubkey.toString();
      }
      if (this.sig) {
        obj.sig = this.sig.toString();
      }
      if (this.k) {
        obj.k = this.k.toString();
      }
      return JSON.stringify(obj);
    };
    ECDSA.prototype.verify = function() {
      if (!this.sigError()) {
        this.verified = true;
      } else {
        this.verified = false;
      }
      return this;
    };
    ECDSA.sign = function(hashbuf, privkey, endian) {
      return ECDSA().set({
        hashbuf,
        endian,
        privkey
      }).sign().sig;
    };
    ECDSA.verify = function(hashbuf, sig, pubkey, endian) {
      return ECDSA().set({
        hashbuf,
        endian,
        sig,
        pubkey
      }).verify().verified;
    };
    module2.exports = ECDSA;
  }
});

// node_modules/bitcore-lib/lib/encoding/varint.js
var require_varint = __commonJS({
  "node_modules/bitcore-lib/lib/encoding/varint.js"(exports2, module2) {
    "use strict";
    var BufferWriter = require_bufferwriter();
    var BufferReader = require_bufferreader();
    var BN = require_bn2();
    var Varint = function Varint2(buf) {
      if (!(this instanceof Varint2))
        return new Varint2(buf);
      if (Buffer.isBuffer(buf)) {
        this.buf = buf;
      } else if (typeof buf === "number") {
        var num = buf;
        this.fromNumber(num);
      } else if (buf instanceof BN) {
        var bn = buf;
        this.fromBN(bn);
      } else if (buf) {
        var obj = buf;
        this.set(obj);
      }
    };
    Varint.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf;
      return this;
    };
    Varint.prototype.fromString = function(str) {
      this.set({
        buf: Buffer.from(str, "hex")
      });
      return this;
    };
    Varint.prototype.toString = function() {
      return this.buf.toString("hex");
    };
    Varint.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Varint.prototype.fromBufferReader = function(br) {
      this.buf = br.readVarintBuf();
      return this;
    };
    Varint.prototype.fromBN = function(bn) {
      this.buf = BufferWriter().writeVarintBN(bn).concat();
      return this;
    };
    Varint.prototype.fromNumber = function(num) {
      this.buf = BufferWriter().writeVarintNum(num).concat();
      return this;
    };
    Varint.prototype.toBuffer = function() {
      return this.buf;
    };
    Varint.prototype.toBN = function() {
      return BufferReader(this.buf).readVarintBN();
    };
    Varint.prototype.toNumber = function() {
      return BufferReader(this.buf).readVarintNum();
    };
    module2.exports = Varint;
  }
});

// node_modules/bitcore-lib/lib/block/blockheader.js
var require_blockheader = __commonJS({
  "node_modules/bitcore-lib/lib/block/blockheader.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash3 = require_hash2();
    var JSUtil = require_js();
    var $ = require_preconditions();
    var GENESIS_BITS = 486604799;
    var BlockHeader = function BlockHeader2(arg) {
      if (!(this instanceof BlockHeader2)) {
        return new BlockHeader2(arg);
      }
      var info = BlockHeader2._from(arg);
      this.version = info.version;
      this.prevHash = info.prevHash;
      this.merkleRoot = info.merkleRoot;
      this.time = info.time;
      this.timestamp = info.time;
      this.bits = info.bits;
      this.nonce = info.nonce;
      if (info.hash) {
        $.checkState(
          this.hash === info.hash,
          "Argument object hash property does not match block hash."
        );
      }
      return this;
    };
    BlockHeader._from = function _from(arg) {
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = BlockHeader._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        info = BlockHeader._fromObject(arg);
      } else {
        throw new TypeError("Unrecognized argument for BlockHeader");
      }
      return info;
    };
    BlockHeader._fromObject = function _fromObject(data) {
      $.checkArgument(data, "data is required");
      var prevHash = data.prevHash;
      var merkleRoot = data.merkleRoot;
      if (_.isString(data.prevHash)) {
        prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, "hex"));
      }
      if (_.isString(data.merkleRoot)) {
        merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, "hex"));
      }
      var info = {
        hash: data.hash,
        version: data.version,
        prevHash,
        merkleRoot,
        time: data.time,
        timestamp: data.time,
        bits: data.bits,
        nonce: data.nonce
      };
      return info;
    };
    BlockHeader.fromObject = function fromObject(obj) {
      var info = BlockHeader._fromObject(obj);
      return new BlockHeader(info);
    };
    BlockHeader.fromRawBlock = function fromRawBlock(data) {
      if (!BufferUtil.isBuffer(data)) {
        data = Buffer.from(data, "binary");
      }
      var br = BufferReader(data);
      br.pos = BlockHeader.Constants.START_OF_HEADER;
      var info = BlockHeader._fromBufferReader(br);
      return new BlockHeader(info);
    };
    BlockHeader.fromBuffer = function fromBuffer(buf) {
      var info = BlockHeader._fromBufferReader(BufferReader(buf));
      return new BlockHeader(info);
    };
    BlockHeader.fromString = function fromString(str) {
      var buf = Buffer.from(str, "hex");
      return BlockHeader.fromBuffer(buf);
    };
    BlockHeader._fromBufferReader = function _fromBufferReader(br) {
      var info = {};
      info.version = br.readInt32LE();
      info.prevHash = br.read(32);
      info.merkleRoot = br.read(32);
      info.time = br.readUInt32LE();
      info.bits = br.readUInt32LE();
      info.nonce = br.readUInt32LE();
      return info;
    };
    BlockHeader.fromBufferReader = function fromBufferReader(br) {
      var info = BlockHeader._fromBufferReader(br);
      return new BlockHeader(info);
    };
    BlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {
      return {
        hash: this.hash,
        version: this.version,
        prevHash: BufferUtil.reverse(this.prevHash).toString("hex"),
        merkleRoot: BufferUtil.reverse(this.merkleRoot).toString("hex"),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    };
    BlockHeader.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    BlockHeader.prototype.toString = function toString3() {
      return this.toBuffer().toString("hex");
    };
    BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.writeInt32LE(this.version);
      bw.write(this.prevHash);
      bw.write(this.merkleRoot);
      bw.writeUInt32LE(this.time);
      bw.writeUInt32LE(this.bits);
      bw.writeUInt32LE(this.nonce);
      return bw;
    };
    BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {
      bits = bits || this.bits;
      var target = new BN(bits & 16777215);
      var mov = 8 * ((bits >>> 24) - 3);
      while (mov-- > 0) {
        target = target.mul(new BN(2));
      }
      return target;
    };
    BlockHeader.prototype.getDifficulty = function getDifficulty() {
      var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));
      var currentTargetBN = this.getTargetDifficulty();
      var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
      var decimalPos = difficultyString.length - 8;
      difficultyString = difficultyString.slice(0, decimalPos) + "." + difficultyString.slice(decimalPos);
      return parseFloat(difficultyString);
    };
    BlockHeader.prototype._getHash = function hash2() {
      var buf = this.toBuffer();
      return Hash3.sha256sha256(buf);
    };
    var idProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        if (!this._id) {
          this._id = BufferReader(this._getHash()).readReverse().toString("hex");
        }
        return this._id;
      },
      set: _.noop
    };
    Object.defineProperty(BlockHeader.prototype, "id", idProperty);
    Object.defineProperty(BlockHeader.prototype, "hash", idProperty);
    BlockHeader.prototype.validTimestamp = function validTimestamp() {
      var currentTime = Math.round(new Date().getTime() / 1e3);
      if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {
        return false;
      }
      return true;
    };
    BlockHeader.prototype.validProofOfWork = function validProofOfWork() {
      var pow3 = new BN(this.id, "hex");
      var target = this.getTargetDifficulty();
      if (pow3.cmp(target) > 0) {
        return false;
      }
      return true;
    };
    BlockHeader.prototype.inspect = function inspect() {
      return "<BlockHeader " + this.id + ">";
    };
    BlockHeader.Constants = {
      START_OF_HEADER: 8,
      MAX_TIME_OFFSET: 2 * 60 * 60,
      LARGEST_HASH: new BN("10000000000000000000000000000000000000000000000000000000000000000", "hex")
    };
    module2.exports = BlockHeader;
  }
});

// node_modules/bitcore-lib/lib/block/block.js
var require_block = __commonJS({
  "node_modules/bitcore-lib/lib/block/block.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var BlockHeader = require_blockheader();
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash3 = require_hash2();
    var Transaction = require_transaction2();
    var $ = require_preconditions();
    function Block(arg) {
      if (!(this instanceof Block)) {
        return new Block(arg);
      }
      _.extend(this, Block._from(arg));
      return this;
    }
    Block.MAX_BLOCK_SIZE = 1e6;
    Block._from = function _from(arg) {
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = Block._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        info = Block._fromObject(arg);
      } else {
        throw new TypeError("Unrecognized argument for Block");
      }
      return info;
    };
    Block._fromObject = function _fromObject(data) {
      var transactions = [];
      data.transactions.forEach(function(tx) {
        if (tx instanceof Transaction) {
          transactions.push(tx);
        } else {
          transactions.push(Transaction().fromObject(tx));
        }
      });
      var info = {
        header: BlockHeader.fromObject(data.header),
        transactions
      };
      return info;
    };
    Block.fromObject = function fromObject(obj) {
      var info = Block._fromObject(obj);
      return new Block(info);
    };
    Block._fromBufferReader = function _fromBufferReader(br) {
      var info = {};
      $.checkState(!br.finished(), "No block data received");
      info.header = BlockHeader.fromBufferReader(br);
      var transactions = br.readVarintNum();
      info.transactions = [];
      for (var i = 0; i < transactions; i++) {
        info.transactions.push(Transaction().fromBufferReader(br));
      }
      return info;
    };
    Block.fromBufferReader = function fromBufferReader(br) {
      $.checkArgument(br, "br is required");
      var info = Block._fromBufferReader(br);
      return new Block(info);
    };
    Block.fromBuffer = function fromBuffer(buf) {
      return Block.fromBufferReader(new BufferReader(buf));
    };
    Block.fromString = function fromString(str) {
      var buf = Buffer.from(str, "hex");
      return Block.fromBuffer(buf);
    };
    Block.fromRawBlock = function fromRawBlock(data) {
      if (!BufferUtil.isBuffer(data)) {
        data = Buffer.from(data, "binary");
      }
      var br = BufferReader(data);
      br.pos = Block.Values.START_OF_BLOCK;
      var info = Block._fromBufferReader(br);
      return new Block(info);
    };
    Block.prototype.toObject = Block.prototype.toJSON = function toObject() {
      var transactions = [];
      this.transactions.forEach(function(tx) {
        transactions.push(tx.toObject());
      });
      return {
        header: this.header.toObject(),
        transactions
      };
    };
    Block.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    Block.prototype.toString = function toString3() {
      return this.toBuffer().toString("hex");
    };
    Block.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.write(this.header.toBuffer());
      bw.writeVarintNum(this.transactions.length);
      for (var i = 0; i < this.transactions.length; i++) {
        this.transactions[i].toBufferWriter(bw);
      }
      return bw;
    };
    Block.prototype.getTransactionHashes = function getTransactionHashes() {
      var hashes = [];
      if (this.transactions.length === 0) {
        return [Block.Values.NULL_HASH];
      }
      for (var t = 0; t < this.transactions.length; t++) {
        hashes.push(this.transactions[t]._getHash());
      }
      return hashes;
    };
    Block.prototype.getMerkleTree = function getMerkleTree() {
      var tree = this.getTransactionHashes();
      var j = 0;
      for (var size3 = this.transactions.length; size3 > 1; size3 = Math.floor((size3 + 1) / 2)) {
        for (var i = 0; i < size3; i += 2) {
          var i2 = Math.min(i + 1, size3 - 1);
          var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
          tree.push(Hash3.sha256sha256(buf));
        }
        j += size3;
      }
      return tree;
    };
    Block.prototype.getMerkleRoot = function getMerkleRoot() {
      var tree = this.getMerkleTree();
      return tree[tree.length - 1];
    };
    Block.prototype.validMerkleRoot = function validMerkleRoot() {
      var h = new BN(this.header.merkleRoot.toString("hex"), "hex");
      var c = new BN(this.getMerkleRoot().toString("hex"), "hex");
      if (h.cmp(c) !== 0) {
        return false;
      }
      return true;
    };
    Block.prototype._getHash = function() {
      return this.header._getHash();
    };
    var idProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        if (!this._id) {
          this._id = this.header.id;
        }
        return this._id;
      },
      set: _.noop
    };
    Object.defineProperty(Block.prototype, "id", idProperty);
    Object.defineProperty(Block.prototype, "hash", idProperty);
    Block.prototype.inspect = function inspect() {
      return "<Block " + this.id + ">";
    };
    Block.Values = {
      START_OF_BLOCK: 8,
      NULL_HASH: Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex")
    };
    module2.exports = Block;
  }
});

// node_modules/bitcore-lib/lib/block/merkleblock.js
var require_merkleblock = __commonJS({
  "node_modules/bitcore-lib/lib/block/merkleblock.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var BlockHeader = require_blockheader();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash3 = require_hash2();
    var JSUtil = require_js();
    var Transaction = require_transaction2();
    var errors = require_errors();
    var $ = require_preconditions();
    function MerkleBlock(arg) {
      if (!(this instanceof MerkleBlock)) {
        return new MerkleBlock(arg);
      }
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = MerkleBlock._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        var header;
        if (arg.header instanceof BlockHeader) {
          header = arg.header;
        } else {
          header = BlockHeader.fromObject(arg.header);
        }
        info = {
          header,
          numTransactions: arg.numTransactions,
          hashes: arg.hashes,
          flags: arg.flags
        };
      } else {
        throw new TypeError("Unrecognized argument for MerkleBlock");
      }
      _.extend(this, info);
      this._flagBitsUsed = 0;
      this._hashesUsed = 0;
      return this;
    }
    MerkleBlock.fromBuffer = function fromBuffer(buf) {
      return MerkleBlock.fromBufferReader(BufferReader(buf));
    };
    MerkleBlock.fromBufferReader = function fromBufferReader(br) {
      return new MerkleBlock(MerkleBlock._fromBufferReader(br));
    };
    MerkleBlock.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.write(this.header.toBuffer());
      bw.writeUInt32LE(this.numTransactions);
      bw.writeVarintNum(this.hashes.length);
      for (var i = 0; i < this.hashes.length; i++) {
        bw.write(Buffer.from(this.hashes[i], "hex"));
      }
      bw.writeVarintNum(this.flags.length);
      for (i = 0; i < this.flags.length; i++) {
        bw.writeUInt8(this.flags[i]);
      }
      return bw;
    };
    MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {
      return {
        header: this.header.toObject(),
        numTransactions: this.numTransactions,
        hashes: this.hashes,
        flags: this.flags
      };
    };
    MerkleBlock.prototype.validMerkleTree = function validMerkleTree() {
      $.checkState(_.isArray(this.flags), "MerkleBlock flags is not an array");
      $.checkState(_.isArray(this.hashes), "MerkleBlock hashes is not an array");
      if (this.hashes.length > this.numTransactions) {
        return false;
      }
      if (this.flags.length * 8 < this.hashes.length) {
        return false;
      }
      var height = this._calcTreeHeight();
      var opts = { hashesUsed: 0, flagBitsUsed: 0 };
      var root2 = this._traverseMerkleTree(height, 0, opts);
      if (opts.hashesUsed !== this.hashes.length) {
        return false;
      }
      return BufferUtil.equals(root2, this.header.merkleRoot);
    };
    MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {
      $.checkState(_.isArray(this.flags), "MerkleBlock flags is not an array");
      $.checkState(_.isArray(this.hashes), "MerkleBlock hashes is not an array");
      if (this.hashes.length > this.numTransactions) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      if (this.flags.length * 8 < this.hashes.length) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      if (this.hashes.length === 1) {
        return [];
      }
      ;
      var height = this._calcTreeHeight();
      var opts = { hashesUsed: 0, flagBitsUsed: 0 };
      var txs = this._traverseMerkleTree(height, 0, opts, true);
      if (opts.hashesUsed !== this.hashes.length) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      return txs;
    };
    MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {
      opts = opts || {};
      opts.txs = opts.txs || [];
      opts.flagBitsUsed = opts.flagBitsUsed || 0;
      opts.hashesUsed = opts.hashesUsed || 0;
      var checkForTxs = checkForTxs || false;
      if (opts.flagBitsUsed > this.flags.length * 8) {
        return null;
      }
      var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;
      if (depth === 0 || !isParentOfMatch) {
        if (opts.hashesUsed >= this.hashes.length) {
          return null;
        }
        var hash2 = this.hashes[opts.hashesUsed++];
        if (depth === 0 && isParentOfMatch) {
          opts.txs.push(hash2);
        }
        return Buffer.from(hash2, "hex");
      } else {
        var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);
        var right = left;
        if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {
          right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);
        }
        if (checkForTxs) {
          return opts.txs;
        } else {
          return Hash3.sha256sha256(new Buffer.concat([left, right]));
        }
        ;
      }
    };
    MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {
      return this.numTransactions + (1 << height) - 1 >> height;
    };
    MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {
      var height = 0;
      while (this._calcTreeWidth(height) > 1) {
        height++;
      }
      return height;
    };
    MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {
      $.checkArgument(!_.isUndefined(tx), "tx cannot be undefined");
      $.checkArgument(
        tx instanceof Transaction || typeof tx === "string",
        'Invalid tx given, tx must be a "string" or "Transaction"'
      );
      var hash2 = tx;
      if (tx instanceof Transaction) {
        hash2 = BufferUtil.reverse(Buffer.from(tx.id, "hex")).toString("hex");
      }
      var txs = [];
      var height = this._calcTreeHeight();
      this._traverseMerkleTree(height, 0, { txs });
      return txs.indexOf(hash2) !== -1;
    };
    MerkleBlock._fromBufferReader = function _fromBufferReader(br) {
      $.checkState(!br.finished(), "No merkleblock data received");
      var info = {};
      info.header = BlockHeader.fromBufferReader(br);
      info.numTransactions = br.readUInt32LE();
      var numHashes = br.readVarintNum();
      info.hashes = [];
      for (var i = 0; i < numHashes; i++) {
        info.hashes.push(br.read(32).toString("hex"));
      }
      var numFlags = br.readVarintNum();
      info.flags = [];
      for (i = 0; i < numFlags; i++) {
        info.flags.push(br.readUInt8());
      }
      return info;
    };
    MerkleBlock.fromObject = function fromObject(obj) {
      return new MerkleBlock(obj);
    };
    module2.exports = MerkleBlock;
  }
});

// node_modules/bitcore-lib/lib/block/index.js
var require_block2 = __commonJS({
  "node_modules/bitcore-lib/lib/block/index.js"(exports2, module2) {
    module2.exports = require_block();
    module2.exports.BlockHeader = require_blockheader();
    module2.exports.MerkleBlock = require_merkleblock();
  }
});

// node_modules/bitcore-lib/lib/hdpublickey.js
var require_hdpublickey = __commonJS({
  "node_modules/bitcore-lib/lib/hdpublickey.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BN = require_bn2();
    var Base58 = require_base58();
    var Base58Check = require_base58check();
    var Hash3 = require_hash2();
    var HDPrivateKey = require_hdprivatekey();
    var Network = require_networks();
    var Point2 = require_point();
    var PublicKey = require_publickey2();
    var bitcoreErrors = require_errors();
    var errors = bitcoreErrors;
    var hdErrors = bitcoreErrors.HDPublicKey;
    var assert2 = require_assert();
    var JSUtil = require_js();
    var BufferUtil = require_buffer3();
    function HDPublicKey(arg) {
      if (arg instanceof HDPublicKey) {
        return arg;
      }
      if (!(this instanceof HDPublicKey)) {
        return new HDPublicKey(arg);
      }
      if (arg) {
        if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
          var error = HDPublicKey.getSerializedError(arg);
          if (!error) {
            return this._buildFromSerialized(arg);
          } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
            return this._buildFromSerialized(arg.toString());
          } else {
            if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
              return new HDPrivateKey(arg).hdPublicKey;
            }
            throw error;
          }
        } else {
          if (_.isObject(arg)) {
            if (arg instanceof HDPrivateKey) {
              return this._buildFromPrivate(arg);
            } else {
              return this._buildFromObject(arg);
            }
          } else {
            throw new hdErrors.UnrecognizedArgument(arg);
          }
        }
      } else {
        throw new hdErrors.MustSupplyArgument();
      }
    }
    HDPublicKey.isValidPath = function(arg) {
      if (_.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);
      }
      if (_.isNumber(arg)) {
        return arg >= 0 && arg < HDPublicKey.Hardened;
      }
      return false;
    };
    HDPublicKey.prototype.derive = function(arg, hardened) {
      return this.deriveChild(arg, hardened);
    };
    HDPublicKey.prototype.deriveChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPublicKey.prototype._deriveWithNumber = function(index2, hardened) {
      if (index2 >= HDPublicKey.Hardened || hardened) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      }
      if (index2 < 0) {
        throw new hdErrors.InvalidPath(index2);
      }
      var indexBuffer = BufferUtil.integerAsBuffer(index2);
      var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
      var hash2 = Hash3.sha512hmac(data, this._buffers.chainCode);
      var leftPart = BN.fromBuffer(hash2.slice(0, 32), { size: 32 });
      var chainCode = hash2.slice(32, 64);
      var publicKey;
      try {
        publicKey = PublicKey.fromPoint(Point2.getG().mul(leftPart).add(this.publicKey.point));
      } catch (e) {
        return this._deriveWithNumber(index2 + 1);
      }
      var derived = new HDPublicKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index2,
        chainCode,
        publicKey
      });
      return derived;
    };
    HDPublicKey.prototype._deriveFromString = function(path) {
      if (_.includes(path, "'")) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      } else if (!HDPublicKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index2) {
        return prev._deriveWithNumber(index2);
      }, this);
      return derived;
    };
    HDPublicKey.isValidSerialized = function(data, network) {
      return _.isNull(HDPublicKey.getSerializedError(data, network));
    };
    HDPublicKey.getSerializedError = function(data, network) {
      if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
        return new hdErrors.UnrecognizedArgument("expected buffer or string");
      }
      if (!Base58.validCharacters(data)) {
        return new errors.InvalidB58Char("(unknown)", data);
      }
      try {
        data = Base58Check.decode(data);
      } catch (e) {
        return new errors.InvalidB58Checksum(data);
      }
      if (data.length !== HDPublicKey.DataSize) {
        return new hdErrors.InvalidLength(data);
      }
      if (!_.isUndefined(network)) {
        var error = HDPublicKey._validateNetwork(data, network);
        if (error) {
          return error;
        }
      }
      var version = BufferUtil.integerFromBuffer(data.slice(0, 4));
      if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {
        return new hdErrors.ArgumentIsPrivateExtended();
      }
      return null;
    };
    HDPublicKey._validateNetwork = function(data, networkArg) {
      var network = Network.get(networkArg);
      if (!network) {
        return new errors.InvalidNetworkArgument(networkArg);
      }
      var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
      if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {
        return new errors.InvalidNetwork(version);
      }
      return null;
    };
    HDPublicKey.prototype._buildFromPrivate = function(arg) {
      var args = _.clone(arg._buffers);
      var point = Point2.getG().mul(BN.fromBuffer(args.privateKey));
      args.publicKey = Point2.pointToCompressed(point);
      args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);
      args.privateKey = void 0;
      args.checksum = void 0;
      args.xprivkey = void 0;
      return this._buildFromBuffers(args);
    };
    HDPublicKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
        depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, "hex") : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
        checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check.decode(arg);
      var buffers = {
        version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
        depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPublicKey.ParentFingerPrintStart,
          HDPublicKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
        publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
        checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
        xpubkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromBuffers = function(arg) {
      HDPublicKey._validateBufferArguments(arg);
      JSUtil.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        arg.publicKey
      ];
      var concat2 = BufferUtil.concat(sequence);
      var checksum = Base58Check.checksum(concat2);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = checksum;
      } else {
        if (arg.checksum.toString("hex") !== checksum.toString("hex")) {
          throw new errors.InvalidB58Checksum(concat2, checksum);
        }
      }
      var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
      var xpubkey;
      xpubkey = Base58Check.encode(BufferUtil.concat(sequence));
      arg.xpubkey = Buffer.from(xpubkey);
      var publicKey = new PublicKey(arg.publicKey, { network });
      var size3 = HDPublicKey.ParentFingerPrintSize;
      var fingerPrint = Hash3.sha256ripemd160(publicKey.toBuffer()).slice(0, size3);
      JSUtil.defineImmutable(this, {
        xpubkey,
        network,
        depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
        publicKey,
        fingerPrint
      });
      return this;
    };
    HDPublicKey._validateBufferArguments = function(arg) {
      var checkBuffer = function(name, size3) {
        var buff = arg[name];
        assert2(BufferUtil.isBuffer(buff), name + " argument is not a buffer, it's " + typeof buff);
        assert2(
          buff.length === size3,
          name + " has not the expected size: found " + buff.length + ", expected " + size3
        );
      };
      checkBuffer("version", HDPublicKey.VersionSize);
      checkBuffer("depth", HDPublicKey.DepthSize);
      checkBuffer("parentFingerPrint", HDPublicKey.ParentFingerPrintSize);
      checkBuffer("childIndex", HDPublicKey.ChildIndexSize);
      checkBuffer("chainCode", HDPublicKey.ChainCodeSize);
      checkBuffer("publicKey", HDPublicKey.PublicKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer("checksum", HDPublicKey.CheckSumSize);
      }
    };
    HDPublicKey.fromString = function(arg) {
      $.checkArgument(_.isString(arg), "No valid string was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.fromObject = function(arg) {
      $.checkArgument(_.isObject(arg), "No valid argument was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toString = function() {
      return this.xpubkey;
    };
    HDPublicKey.prototype.inspect = function() {
      return "<HDPublicKey: " + this.xpubkey + ">";
    };
    HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {
      return {
        network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
        depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
        chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
        publicKey: this.publicKey.toString(),
        checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
        xpubkey: this.xpubkey
      };
    };
    HDPublicKey.fromBuffer = function(arg) {
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toBuffer = function() {
      return BufferUtil.copy(this._buffers.xpubkey);
    };
    HDPublicKey.Hardened = 2147483648;
    HDPublicKey.RootElementAlias = ["m", "M"];
    HDPublicKey.VersionSize = 4;
    HDPublicKey.DepthSize = 1;
    HDPublicKey.ParentFingerPrintSize = 4;
    HDPublicKey.ChildIndexSize = 4;
    HDPublicKey.ChainCodeSize = 32;
    HDPublicKey.PublicKeySize = 33;
    HDPublicKey.CheckSumSize = 4;
    HDPublicKey.DataSize = 78;
    HDPublicKey.SerializedByteSize = 82;
    HDPublicKey.VersionStart = 0;
    HDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
    HDPublicKey.DepthStart = HDPublicKey.VersionEnd;
    HDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
    HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
    HDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
    HDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;
    HDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
    HDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;
    HDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
    HDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;
    HDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
    HDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;
    HDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;
    assert2(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
    assert2(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);
    module2.exports = HDPublicKey;
  }
});

// node_modules/bitcore-lib/lib/hdprivatekey.js
var require_hdprivatekey = __commonJS({
  "node_modules/bitcore-lib/lib/hdprivatekey.js"(exports2, module2) {
    "use strict";
    var assert2 = require_assert();
    var buffer2 = require_buffer();
    var _ = require_lodash();
    var $ = require_preconditions();
    var BN = require_bn2();
    var Base58 = require_base58();
    var Base58Check = require_base58check();
    var Hash3 = require_hash2();
    var Network = require_networks();
    var Point2 = require_point();
    var PrivateKey = require_privatekey();
    var Random = require_random();
    var errors = require_errors();
    var hdErrors = errors.HDPrivateKey;
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var MINIMUM_ENTROPY_BITS = 128;
    var BITS_TO_BYTES = 1 / 8;
    var MAXIMUM_ENTROPY_BITS = 512;
    function HDPrivateKey(arg) {
      if (arg instanceof HDPrivateKey) {
        return arg;
      }
      if (!(this instanceof HDPrivateKey)) {
        return new HDPrivateKey(arg);
      }
      if (!arg) {
        return this._generateRandomly();
      }
      if (Network.get(arg)) {
        return this._generateRandomly(arg);
      } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
        if (HDPrivateKey.isValidSerialized(arg)) {
          this._buildFromSerialized(arg);
        } else if (JSUtil.isValidJSON(arg)) {
          this._buildFromJSON(arg);
        } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
          this._buildFromSerialized(arg.toString());
        } else {
          throw HDPrivateKey.getSerializedError(arg);
        }
      } else if (_.isObject(arg)) {
        this._buildFromObject(arg);
      } else {
        throw new hdErrors.UnrecognizedArgument(arg);
      }
    }
    HDPrivateKey.isValidPath = function(arg, hardened) {
      if (_.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);
      }
      if (_.isNumber(arg)) {
        if (arg < HDPrivateKey.Hardened && hardened === true) {
          arg += HDPrivateKey.Hardened;
        }
        return arg >= 0 && arg < HDPrivateKey.MaxIndex;
      }
      return false;
    };
    HDPrivateKey._getDerivationIndexes = function(path) {
      var steps = path.split("/");
      if (_.includes(HDPrivateKey.RootElementAlias, path)) {
        return [];
      }
      if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {
        return null;
      }
      var indexes = steps.slice(1).map(function(step) {
        var isHardened = step.slice(-1) === "'";
        if (isHardened) {
          step = step.slice(0, -1);
        }
        if (!step || step[0] === "-") {
          return NaN;
        }
        var index2 = +step;
        if (isHardened) {
          index2 += HDPrivateKey.Hardened;
        }
        return index2;
      });
      return _.some(indexes, isNaN) ? null : indexes;
    };
    HDPrivateKey.prototype.derive = function(arg, hardened) {
      return this.deriveNonCompliantChild(arg, hardened);
    };
    HDPrivateKey.prototype.deriveChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened, true);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg, true);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype._deriveWithNumber = function(index2, hardened, nonCompliant) {
      if (!HDPrivateKey.isValidPath(index2, hardened)) {
        throw new hdErrors.InvalidPath(index2);
      }
      hardened = index2 >= HDPrivateKey.Hardened ? true : hardened;
      if (index2 < HDPrivateKey.Hardened && hardened === true) {
        index2 += HDPrivateKey.Hardened;
      }
      var indexBuffer = BufferUtil.integerAsBuffer(index2);
      var data;
      if (hardened && nonCompliant) {
        var nonZeroPadded = this.privateKey.bn.toBuffer();
        data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);
      } else if (hardened) {
        var privateKeyBuffer = this.privateKey.bn.toBuffer({ size: 32 });
        assert2(privateKeyBuffer.length === 32, "length of private key buffer is expected to be 32 bytes");
        data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);
      } else {
        data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
      }
      var hash2 = Hash3.sha512hmac(data, this._buffers.chainCode);
      var leftPart = BN.fromBuffer(hash2.slice(0, 32), {
        size: 32
      });
      var chainCode = hash2.slice(32, 64);
      var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point2.getN()).toBuffer({
        size: 32
      });
      if (!PrivateKey.isValid(privateKey)) {
        return this._deriveWithNumber(index2 + 1, null, nonCompliant);
      }
      var derived = new HDPrivateKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index2,
        chainCode,
        privateKey
      });
      return derived;
    };
    HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {
      if (!HDPrivateKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index2) {
        return prev._deriveWithNumber(index2, null, nonCompliant);
      }, this);
      return derived;
    };
    HDPrivateKey.isValidSerialized = function(data, network) {
      return !HDPrivateKey.getSerializedError(data, network);
    };
    HDPrivateKey.getSerializedError = function(data, network) {
      if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
        return new hdErrors.UnrecognizedArgument("Expected string or buffer");
      }
      if (!Base58.validCharacters(data)) {
        return new errors.InvalidB58Char("(unknown)", data);
      }
      try {
        data = Base58Check.decode(data);
      } catch (e) {
        return new errors.InvalidB58Checksum(data);
      }
      if (data.length !== HDPrivateKey.DataLength) {
        return new hdErrors.InvalidLength(data);
      }
      if (!_.isUndefined(network)) {
        var error = HDPrivateKey._validateNetwork(data, network);
        if (error) {
          return error;
        }
      }
      return null;
    };
    HDPrivateKey._validateNetwork = function(data, networkArg) {
      var network = Network.get(networkArg);
      if (!network) {
        return new errors.InvalidNetworkArgument(networkArg);
      }
      var version = data.slice(0, 4);
      if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {
        return new errors.InvalidNetwork(version);
      }
      return null;
    };
    HDPrivateKey.fromString = function(arg) {
      $.checkArgument(_.isString(arg), "No valid string was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.fromObject = function(arg) {
      $.checkArgument(_.isObject(arg), "No valid argument was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.prototype._buildFromJSON = function(arg) {
      return this._buildFromObject(JSON.parse(arg));
    };
    HDPrivateKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
        depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? Buffer.from(arg.privateKey, "hex") : arg.privateKey,
        checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : void 0
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check.decode(arg);
      var buffers = {
        version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
        depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPrivateKey.ParentFingerPrintStart,
          HDPrivateKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
        privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
        checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
        xprivkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._generateRandomly = function(network) {
      return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);
    };
    HDPrivateKey.fromSeed = function(hexa, network) {
      if (JSUtil.isHexaString(hexa)) {
        hexa = Buffer.from(hexa, "hex");
      }
      if (!Buffer.isBuffer(hexa)) {
        throw new hdErrors.InvalidEntropyArgument(hexa);
      }
      if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
      }
      if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
      }
      var hash2 = Hash3.sha512hmac(hexa, Buffer.from("Bitcoin seed"));
      return new HDPrivateKey({
        network: Network.get(network) || Network.defaultNetwork,
        depth: 0,
        parentFingerPrint: 0,
        childIndex: 0,
        privateKey: hash2.slice(0, 32),
        chainCode: hash2.slice(32, 64)
      });
    };
    HDPrivateKey.prototype._calcHDPublicKey = function() {
      if (!this._hdPublicKey) {
        var HDPublicKey = require_hdpublickey();
        this._hdPublicKey = new HDPublicKey(this);
      }
    };
    HDPrivateKey.prototype._buildFromBuffers = function(arg) {
      HDPrivateKey._validateBufferArguments(arg);
      JSUtil.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        BufferUtil.emptyBuffer(1),
        arg.privateKey
      ];
      var concat2 = buffer2.Buffer.concat(sequence);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = Base58Check.checksum(concat2);
      } else {
        if (arg.checksum.toString() !== Base58Check.checksum(concat2).toString()) {
          throw new errors.InvalidB58Checksum(concat2);
        }
      }
      var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
      var xprivkey;
      xprivkey = Base58Check.encode(buffer2.Buffer.concat(sequence));
      arg.xprivkey = Buffer.from(xprivkey);
      var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);
      var publicKey = privateKey.toPublicKey();
      var size3 = HDPrivateKey.ParentFingerPrintSize;
      var fingerPrint = Hash3.sha256ripemd160(publicKey.toBuffer()).slice(0, size3);
      JSUtil.defineImmutable(this, {
        xprivkey,
        network,
        depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
        privateKey,
        publicKey,
        fingerPrint
      });
      this._hdPublicKey = null;
      Object.defineProperty(this, "hdPublicKey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey;
        }
      });
      Object.defineProperty(this, "xpubkey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey.xpubkey;
        }
      });
      return this;
    };
    HDPrivateKey._validateBufferArguments = function(arg) {
      var checkBuffer = function(name, size3) {
        var buff = arg[name];
        assert2(BufferUtil.isBuffer(buff), name + " argument is not a buffer");
        assert2(
          buff.length === size3,
          name + " has not the expected size: found " + buff.length + ", expected " + size3
        );
      };
      checkBuffer("version", HDPrivateKey.VersionSize);
      checkBuffer("depth", HDPrivateKey.DepthSize);
      checkBuffer("parentFingerPrint", HDPrivateKey.ParentFingerPrintSize);
      checkBuffer("childIndex", HDPrivateKey.ChildIndexSize);
      checkBuffer("chainCode", HDPrivateKey.ChainCodeSize);
      checkBuffer("privateKey", HDPrivateKey.PrivateKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer("checksum", HDPrivateKey.CheckSumSize);
      }
    };
    HDPrivateKey.prototype.toString = function() {
      return this.xprivkey;
    };
    HDPrivateKey.prototype.inspect = function() {
      return "<HDPrivateKey: " + this.xprivkey + ">";
    };
    HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {
      return {
        network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), "xprivkey").name,
        depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
        chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
        privateKey: this.privateKey.toBuffer().toString("hex"),
        checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
        xprivkey: this.xprivkey
      };
    };
    HDPrivateKey.fromBuffer = function(arg) {
      return new HDPrivateKey(arg.toString());
    };
    HDPrivateKey.prototype.toBuffer = function() {
      return BufferUtil.copy(this._buffers.xprivkey);
    };
    HDPrivateKey.DefaultDepth = 0;
    HDPrivateKey.DefaultFingerprint = 0;
    HDPrivateKey.DefaultChildIndex = 0;
    HDPrivateKey.Hardened = 2147483648;
    HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;
    HDPrivateKey.RootElementAlias = ["m", "M", "m'", "M'"];
    HDPrivateKey.VersionSize = 4;
    HDPrivateKey.DepthSize = 1;
    HDPrivateKey.ParentFingerPrintSize = 4;
    HDPrivateKey.ChildIndexSize = 4;
    HDPrivateKey.ChainCodeSize = 32;
    HDPrivateKey.PrivateKeySize = 32;
    HDPrivateKey.CheckSumSize = 4;
    HDPrivateKey.DataLength = 78;
    HDPrivateKey.SerializedByteSize = 82;
    HDPrivateKey.VersionStart = 0;
    HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
    HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
    HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
    HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
    HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
    HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
    HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
    HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
    HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
    HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
    HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
    HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
    HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;
    assert2(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);
    module2.exports = HDPrivateKey;
  }
});

// node_modules/bitcore-lib/lib/message.js
var require_message = __commonJS({
  "node_modules/bitcore-lib/lib/message.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var PrivateKey = require_privatekey();
    var PublicKey = require_publickey2();
    var Address2 = require_address();
    var BufferWriter = require_bufferwriter();
    var ECDSA = require_ecdsa();
    var Signature = require_signature3();
    var sha256sha256 = require_hash2().sha256sha256;
    var JSUtil = require_js();
    var $ = require_preconditions();
    function Message(message) {
      if (!(this instanceof Message)) {
        return new Message(message);
      }
      $.checkArgument(_.isString(message), "First argument should be a string");
      this.message = message;
      return this;
    }
    Message.MAGIC_BYTES = Buffer.from("Bitcoin Signed Message:\n");
    Message.prototype.magicHash = function magicHash() {
      var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);
      var messageBuffer = Buffer.from(this.message);
      var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);
      var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);
      var hash2 = sha256sha256(buf);
      return hash2;
    };
    Message.prototype._sign = function _sign(privateKey) {
      $.checkArgument(privateKey instanceof PrivateKey, "First argument should be an instance of PrivateKey");
      var hash2 = this.magicHash();
      var ecdsa = new ECDSA();
      ecdsa.hashbuf = hash2;
      ecdsa.privkey = privateKey;
      ecdsa.pubkey = privateKey.toPublicKey();
      ecdsa.signRandomK();
      ecdsa.calci();
      return ecdsa.sig;
    };
    Message.prototype.sign = function sign(privateKey) {
      var signature = this._sign(privateKey);
      return signature.toCompact().toString("base64");
    };
    Message.prototype._verify = function _verify(publicKey, signature) {
      $.checkArgument(publicKey instanceof PublicKey, "First argument should be an instance of PublicKey");
      $.checkArgument(signature instanceof Signature, "Second argument should be an instance of Signature");
      var hash2 = this.magicHash();
      var verified = ECDSA.verify(hash2, signature, publicKey);
      if (!verified) {
        this.error = "The signature was invalid";
      }
      return verified;
    };
    Message.prototype.verify = function verify(bitcoinAddress, signatureString) {
      $.checkArgument(bitcoinAddress);
      $.checkArgument(signatureString && _.isString(signatureString));
      if (_.isString(bitcoinAddress)) {
        bitcoinAddress = Address2.fromString(bitcoinAddress);
      }
      var signature = Signature.fromCompact(Buffer.from(signatureString, "base64"));
      var ecdsa = new ECDSA();
      ecdsa.hashbuf = this.magicHash();
      ecdsa.sig = signature;
      var publicKey = ecdsa.toPublicKey();
      var signatureAddress = Address2.fromPublicKey(publicKey, bitcoinAddress.network);
      if (bitcoinAddress.toString() !== signatureAddress.toString()) {
        this.error = "The signature did not match the message digest";
        return false;
      }
      return this._verify(publicKey, signature);
    };
    Message.prototype.recoverPublicKey = function recoverPublicKey2(bitcoinAddress, signatureString) {
      $.checkArgument(bitcoinAddress);
      $.checkArgument(signatureString && _.isString(signatureString));
      if (_.isString(bitcoinAddress)) {
        bitcoinAddress = Address2.fromString(bitcoinAddress);
      }
      var signature = Signature.fromCompact(Buffer.from(signatureString, "base64"));
      var ecdsa = new ECDSA();
      ecdsa.hashbuf = this.magicHash();
      ecdsa.sig = signature;
      var publicKey = ecdsa.toPublicKey();
      var signatureAddress = Address2.fromPublicKey(publicKey, bitcoinAddress.network);
      if (bitcoinAddress.toString() !== signatureAddress.toString()) {
        this.error = "The signature did not match the message digest";
      }
      return publicKey.toString();
    };
    Message.fromString = function(str) {
      return new Message(str);
    };
    Message.fromJSON = function fromJSON(json) {
      if (JSUtil.isValidJSON(json)) {
        json = JSON.parse(json);
      }
      return new Message(json.message);
    };
    Message.prototype.toObject = function toObject() {
      return {
        message: this.message
      };
    };
    Message.prototype.toJSON = function toJSON2() {
      return JSON.stringify(this.toObject());
    };
    Message.prototype.toString = function() {
      return this.message;
    };
    Message.prototype.inspect = function() {
      return "<Message: " + this.toString() + ">";
    };
    module2.exports = Message;
    var Script = require_script2();
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/bitcore-lib/lib/uri.js
var require_uri = __commonJS({
  "node_modules/bitcore-lib/lib/uri.js"(exports2, module2) {
    "use strict";
    var _ = require_lodash();
    var URL2 = require_url();
    var Address2 = require_address();
    var Unit = require_unit();
    var URI = function(data, knownParams) {
      if (!(this instanceof URI)) {
        return new URI(data, knownParams);
      }
      this.extras = {};
      this.knownParams = knownParams || [];
      this.address = this.network = this.amount = this.message = null;
      if (typeof data === "string") {
        var params = URI.parse(data);
        if (params.amount) {
          params.amount = this._parseAmount(params.amount);
        }
        this._fromObject(params);
      } else if (typeof data === "object") {
        this._fromObject(data);
      } else {
        throw new TypeError("Unrecognized data format.");
      }
    };
    URI.fromString = function fromString(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return new URI(str);
    };
    URI.fromObject = function fromObject(json) {
      return new URI(json);
    };
    URI.isValid = function(arg, knownParams) {
      try {
        new URI(arg, knownParams);
      } catch (err) {
        return false;
      }
      return true;
    };
    URI.parse = function(uri) {
      var info = URL2.parse(uri, true);
      if (info.protocol !== "bitcoin:") {
        throw new TypeError("Invalid bitcoin URI");
      }
      var group = /[^:]*:\/?\/?([^?]*)/.exec(uri);
      info.query.address = group && group[1] || void 0;
      return info.query;
    };
    URI.Members = ["address", "amount", "message", "label", "r"];
    URI.prototype._fromObject = function(obj) {
      if (!Address2.isValid(obj.address)) {
        throw new TypeError("Invalid bitcoin address");
      }
      this.address = new Address2(obj.address);
      this.network = this.address.network;
      this.amount = obj.amount;
      for (var key in obj) {
        if (key === "address" || key === "amount") {
          continue;
        }
        if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {
          throw Error("Unknown required argument " + key);
        }
        var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;
        destination[key] = obj[key];
      }
    };
    URI.prototype._parseAmount = function(amount) {
      amount = Number(amount);
      if (isNaN(amount)) {
        throw new TypeError("Invalid amount");
      }
      return Unit.fromBTC(amount).toSatoshis();
    };
    URI.prototype.toObject = URI.prototype.toJSON = function toObject() {
      var json = {};
      for (var i = 0; i < URI.Members.length; i++) {
        var m = URI.Members[i];
        if (this.hasOwnProperty(m) && typeof this[m] !== "undefined") {
          json[m] = this[m].toString();
        }
      }
      _.extend(json, this.extras);
      return json;
    };
    URI.prototype.toString = function() {
      var query = {};
      if (this.amount) {
        query.amount = Unit.fromSatoshis(this.amount).toBTC();
      }
      if (this.message) {
        query.message = this.message;
      }
      if (this.label) {
        query.label = this.label;
      }
      if (this.r) {
        query.r = this.r;
      }
      _.extend(query, this.extras);
      return URL2.format({
        protocol: "bitcoin:",
        host: this.address,
        query
      });
    };
    URI.prototype.inspect = function() {
      return "<URI: " + this.toString() + ">";
    };
    module2.exports = URI;
  }
});

// node_modules/bitcore-lib/index.js
var require_bitcore_lib = __commonJS({
  "node_modules/bitcore-lib/index.js"(exports2, module2) {
    "use strict";
    var bitcore2 = module2.exports;
    bitcore2.version = "v" + require_package().version;
    bitcore2.versionGuard = function(version) {
      if (version !== void 0) {
        var message = "More than one instance of bitcore-lib found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency.";
        throw new Error(message);
      }
    };
    bitcore2.versionGuard(globalThis._bitcore);
    globalThis._bitcore = bitcore2.version;
    bitcore2.crypto = {};
    bitcore2.crypto.BN = require_bn2();
    bitcore2.crypto.ECDSA = require_ecdsa();
    bitcore2.crypto.Hash = require_hash2();
    bitcore2.crypto.Random = require_random();
    bitcore2.crypto.Point = require_point();
    bitcore2.crypto.Signature = require_signature3();
    bitcore2.encoding = {};
    bitcore2.encoding.Base58 = require_base58();
    bitcore2.encoding.Base58Check = require_base58check();
    bitcore2.encoding.BufferReader = require_bufferreader();
    bitcore2.encoding.BufferWriter = require_bufferwriter();
    bitcore2.encoding.Varint = require_varint();
    bitcore2.util = {};
    bitcore2.util.buffer = require_buffer3();
    bitcore2.util.js = require_js();
    bitcore2.util.preconditions = require_preconditions();
    bitcore2.errors = require_errors();
    bitcore2.Address = require_address();
    bitcore2.Block = require_block2();
    bitcore2.MerkleBlock = require_merkleblock();
    bitcore2.BlockHeader = require_blockheader();
    bitcore2.HDPrivateKey = require_hdprivatekey();
    bitcore2.HDPublicKey = require_hdpublickey();
    bitcore2.Message = require_message();
    bitcore2.Networks = require_networks();
    bitcore2.Opcode = require_opcode();
    bitcore2.PrivateKey = require_privatekey();
    bitcore2.PublicKey = require_publickey2();
    bitcore2.Script = require_script2();
    bitcore2.Transaction = require_transaction2();
    bitcore2.URI = require_uri();
    bitcore2.Unit = require_unit();
    bitcore2.deps = {};
    bitcore2.deps.bnjs = require_bn();
    bitcore2.deps.bs58 = require_bs58();
    bitcore2.deps.Buffer = Buffer;
    bitcore2.deps.elliptic = require_elliptic();
    bitcore2.deps._ = require_lodash();
    bitcore2.Transaction.sighash = require_sighash();
  }
});

// node_modules/@particle-network/btc-connectkit/esm/index.js
var import_events3 = __toESM(require_events());

// node_modules/@particle-network/aa/es/index.js
var import_events = __toESM(require_events());

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size3 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size3--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method2) => {
  defaults.headers[method2] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + "=" + encodeURIComponent(value)];
    utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils_default.isString(path) && cookie.push("path=" + path);
    utils_default.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  },
  read(name) {
    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 864e5);
  }
} : {
  write() {
  },
  read() {
    return null;
  },
  remove() {
  }
};

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? function standardBrowserEnv() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url) {
    let href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin(requestURL) {
    const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.6.8";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method2) => {
        delete headers[method2];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
  Axios.prototype[method2] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method2,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method2,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method2] = generateHTTPMethod();
  Axios.prototype[method2 + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@particle-network/aa/es/index.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var SendTransactionMode = ((SendTransactionMode2) => {
  SendTransactionMode2[SendTransactionMode2["UserSelect"] = 0] = "UserSelect";
  SendTransactionMode2[SendTransactionMode2["Gasless"] = 1] = "Gasless";
  SendTransactionMode2[SendTransactionMode2["UserPaidNative"] = 2] = "UserPaidNative";
  return SendTransactionMode2;
})(SendTransactionMode || {});
var SendTransactionEvent = ((SendTransactionEvent2) => {
  SendTransactionEvent2["Request"] = "RequestSendTransaction";
  SendTransactionEvent2["Resolve"] = "ResolveSendTransaction";
  SendTransactionEvent2["Reject"] = "RejectSendTransaction";
  return SendTransactionEvent2;
})(SendTransactionEvent || {});
var rpcUrl = () => {
  const productionApi = "https://rpc.particle.network";
  const developmentApi = "https://rpc-debug.particle.network";
  const dev = typeof window !== "undefined" && window.__PARTICLE_ENVIRONMENT__ === "development";
  return dev ? developmentApi : productionApi;
};
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
var SmartAccount = class {
  constructor(provider, config) {
    this.provider = provider;
    this.config = config;
    this.smartAccountContract = {
      name: "BICONOMY",
      version: "1.0.0"
    };
    this.getChainId = () => __async(this, null, function* () {
      return yield this.provider.request({ method: "eth_chainId" });
    });
    const aaOrder = ["BICONOMY", "CYBERCONNECT", "SIMPLE"];
    for (const name of aaOrder) {
      const accountContract = this.config.aaOptions.accountContracts[name];
      if (accountContract && accountContract.length > 0) {
        for (const contract of accountContract) {
          if (contract.chainIds.length > 0) {
            this.smartAccountContract = {
              name,
              version: contract.version
            };
            break;
          }
        }
      }
    }
    this.connection = axios_default.create({
      baseURL: `${rpcUrl()}/evm-chain`,
      timeout: 6e4
    });
    this.connection.interceptors.request.use((config2) => {
      var _a, _b, _c;
      if ((_a = config2 == null ? void 0 : config2.data) == null ? void 0 : _a.method) {
        config2.baseURL = `${config2.baseURL}${((_b = config2.baseURL) == null ? void 0 : _b.includes("?")) ? "&" : "?"}method=${(_c = config2 == null ? void 0 : config2.data) == null ? void 0 : _c.method}`;
      }
      return config2;
    });
  }
  setSmartAccountContract(contract) {
    const accountContract = this.config.aaOptions.accountContracts[contract.name];
    if (!accountContract || accountContract.length === 0 || accountContract.every((item) => item.version !== contract.version)) {
      throw new Error("Please configure the smart account contract first");
    }
    this.smartAccountContract = contract;
  }
  getAccountConfig() {
    return __async(this, null, function* () {
      const chainId = yield this.getChainId();
      const apiKey = yield this.getPaymasterApiKey();
      const ownerAddress = (yield this.provider.request({ method: "eth_accounts" }))[0];
      const accountContract = this.config.aaOptions.accountContracts[this.smartAccountContract.name];
      if (!accountContract || accountContract.every((item) => item.version !== this.smartAccountContract.version)) {
        throw new Error("Please configure the smart account contract first");
      }
      const contractConfig = accountContract.find((item) => item.version === this.smartAccountContract.version);
      if (contractConfig.chainIds.every((id) => id !== Number(chainId))) {
        throw new Error(`Current chain is not supported, chainId: ${chainId}, please configure it first`);
      }
      return {
        name: this.smartAccountContract.name,
        version: this.smartAccountContract.version,
        biconomyApiKey: apiKey,
        ownerAddress
      };
    });
  }
  getPaymasterApiKey() {
    return __async(this, null, function* () {
      var _a;
      const chainId = yield this.getChainId();
      const apiKeyConfig = (_a = this.config.aaOptions.paymasterApiKeys) == null ? void 0 : _a.find((item) => item.chainId === Number(chainId));
      return apiKeyConfig == null ? void 0 : apiKeyConfig.apiKey;
    });
  }
  getFeeQuotes(tx) {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      return this.sendRpc({
        method: "particle_aa_getFeeQuotes",
        params: [accountConfig, Array.isArray(tx) ? tx : [tx]]
      });
    });
  }
  buildUserOperation(_0) {
    return __async(this, arguments, function* ({ tx, feeQuote, tokenPaymasterAddress }) {
      const accountConfig = yield this.getAccountConfig();
      return yield this.sendRpc({
        method: "particle_aa_createUserOp",
        params: [accountConfig, Array.isArray(tx) ? tx : [tx], feeQuote, tokenPaymasterAddress].filter(
          (val) => !!val
        )
      });
    });
  }
  signUserOperation(_0) {
    return __async(this, arguments, function* ({ userOpHash, userOp }) {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const signature = yield this.provider.request({
        method: "personal_sign",
        params: [userOpHash, eoas[0]]
      });
      return __spreadProps(__spreadValues({}, userOp), { signature });
    });
  }
  sendUserOperation(_0) {
    return __async(this, arguments, function* ({ userOpHash, userOp }) {
      const signedUserOp = yield this.signUserOperation({ userOpHash, userOp });
      return this.sendSignedUserOperation(signedUserOp);
    });
  }
  sendSignedUserOperation(userOp, sessionDataParams) {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      return this.sendRpc({
        method: "particle_aa_sendUserOp",
        params: [accountConfig, userOp, sessionDataParams]
      });
    });
  }
  sendTransaction(params) {
    return __async(this, null, function* () {
      if (Object.prototype.hasOwnProperty.call(params, "userOpHash") && Object.prototype.hasOwnProperty.call(params, "userOp")) {
        const { userOpHash, userOp } = params;
        if (userOpHash && userOp) {
          return this.sendUserOperation({ userOpHash, userOp });
        }
      }
      const { tx, feeQuote, tokenPaymasterAddress } = params;
      const userOpBundle = yield this.buildUserOperation({ tx, feeQuote, tokenPaymasterAddress });
      return this.sendUserOperation(userOpBundle);
    });
  }
  getAccount() {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      const accounts = yield this.sendRpc({
        method: "particle_aa_getSmartAccount",
        params: [accountConfig]
      });
      return accounts[0];
    });
  }
  getAddress() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      if (!eoas || eoas.length === 0) {
        return "";
      }
      const accountConfig = yield this.getAccountConfig();
      const localKey = `particle_${accountConfig.name}_${accountConfig.version}_${eoas[0]}`;
      if (typeof window !== "undefined" && localStorage) {
        const localAA = localStorage.getItem(localKey);
        if (localAA) {
          return localAA;
        }
      }
      const account = yield this.getAccount();
      const address = account.smartAccountAddress;
      if (typeof window !== "undefined" && localStorage) {
        localStorage.setItem(localKey, address);
      }
      return address;
    });
  }
  getOwner() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      return eoas[0];
    });
  }
  isDeployed() {
    return __async(this, null, function* () {
      const account = yield this.getAccount();
      return account.isDeployed;
    });
  }
  deployWalletContract() {
    return __async(this, null, function* () {
      return this.sendTransaction({
        tx: {
          to: "0x0000000000000000000000000000000000000000",
          data: "0x"
        }
      });
    });
  }
  sendRpc(arg) {
    return __async(this, null, function* () {
      const chainId = yield this.getChainId();
      const response = yield this.connection.post(
        "",
        __spreadProps(__spreadValues({}, arg), {
          id: payloadId(),
          jsonrpc: "2.0"
        }),
        {
          params: {
            chainId: Number(chainId),
            projectUuid: this.config.projectId,
            projectKey: this.config.clientKey
          }
        }
      ).then((res) => res.data);
      if (response.error) {
        return Promise.reject(response.error);
      } else {
        return response.result;
      }
    });
  }
  createSessions(options) {
    return __async(this, null, function* () {
      if (this.smartAccountContract.name !== "BICONOMY" && this.smartAccountContract.version !== "2.0.0") {
        throw new Error("Only BICONOMY 2.0.0 is supported");
      }
      const accountConfig = yield this.getAccountConfig();
      return yield this.sendRpc({
        method: "particle_aa_createSessions",
        params: [accountConfig, options]
      });
    });
  }
  validateSession(targetSession, sessions) {
    return __async(this, null, function* () {
      if (this.smartAccountContract.name !== "BICONOMY" && this.smartAccountContract.version !== "2.0.0") {
        throw new Error("Only BICONOMY 2.0.0 is supported");
      }
      const accountConfig = yield this.getAccountConfig();
      return yield this.sendRpc({
        method: "particle_aa_validateSession",
        params: [
          accountConfig,
          {
            sessions,
            targetSession
          }
        ]
      });
    });
  }
};

// node_modules/@particle-network/wallet/esm/index.js
var import_debounce = __toESM(require_debounce());
var import_sha256 = __toESM(require_sha256());
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return unsafeStringify(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes2[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output3 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output3.push(hex);
  }
  return output3;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output3 = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output3[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output3;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes2) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes2.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@particle-network/wallet/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@particle-network/wallet/esm/index.js
"use client";
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var isServer = () => {
  return typeof window === "undefined";
};
function isNullish(x) {
  return x === void 0 || x === null;
}
var _devEnv;
var _stagingEnv;
var _productionEnv;
var GlobalConfig = class {
  constructor() {
    __privateAdd(this, _devEnv, {
      walletUrl: "https://wallet-debug.particle.network"
    });
    __privateAdd(this, _stagingEnv, {
      walletUrl: "https://wallet-staging.particle.network"
    });
    __privateAdd(this, _productionEnv, {
      walletUrl: "https://wallet.particle.network"
    });
  }
  get version() {
    return "web_1.4.0";
  }
  get env() {
    if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "development") {
      return __privateGet(this, _devEnv);
    } else if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "staging") {
      return __privateGet(this, _stagingEnv);
    } else {
      return __privateGet(this, _productionEnv);
    }
  }
};
_devEnv = /* @__PURE__ */ new WeakMap();
_stagingEnv = /* @__PURE__ */ new WeakMap();
_productionEnv = /* @__PURE__ */ new WeakMap();
var globalConfig = new GlobalConfig();
var config_default = globalConfig;
var html = `
  <button class="particle-pwe-btn">
    <img class="particle-pwe-img particle-pwe-wallet-icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="" />
    <img class="particle-pwe-img particle-pwe-down-arrow particle-pwe-down-arrow-hide" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="" />
  </button>
  <div class="particle-pwe-iframe-content">
  </div>
`;
var walletEntryRender = () => {
  const className = "particle-wallet-entry-container";
  const el = document.querySelector("." + className);
  el && el.remove();
  const EL = document.createElement("div");
  EL.classList.add(className);
  EL.innerHTML = html;
  document.body.appendChild(EL);
};
var html_default = walletEntryRender;
var walletIconDarkBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAIABJREFUeF7dfQlwXdWZ5neenvanXbKNWWRWIxkIiwgTQmwSSIPorsmiOEhqZEjiHjuTiUUcsqjLnqbHrjipqXhipqobd1HdiQWWXY4gSXfaIsGAFDLNopiwWLLxIj0veJFkWct72t67Z+o/9913t3OX9yQZ05dyCVt3Oef+5/+/71/Ofxn+kxxvPHz2E/EgX8bjWAaGag4s5GD5Cud5jLE8hSMfDEWKmC8bUcAjjLFoXFF/KmBnAXZAAT8AKAdq2xa++5/h1bCP4yTerj+9JM6U+znY5xSghoNdT/Pg4g9L/NT+rv4EGFThIvFTfp52feK8w5yx1xWOfZkBtu+h58pOftze18dCwPtXnq5AULkfjN2nKPgcY+xqRYiNhKb9VIXIxX+q8My/N5+nXWc8X71Ofl7i/MOcYR8Utm86Pt351T2XDVzqAr9kBfzKvTxYvvDUgzzAmhTgv3KwHFVougZqGqlqrn8NdtN0iwaL58nOBxBROJ5njLW+u7R035NPMm04l5TMLzkBv//w8Tt5IKOJc9SDsQpdw1w1yyAEfxpsvK9c490tgK7p4nkfgmNnnLNf1O8uff9SkvAlI+BDDR/eE4fyQw72l2aNdNIgdwy13kM1396abtRg7fwEMXO9XrMsnLN/Uxh+0thW+tqlIOiPXMCHHj5RywOBv1XA7zFiplEYMqy1YrBuRo2abjTnzhisEzArptuvtz/H4b4cf+CM/6ixrazjoxT0RyJg/iQPfHDw5BcAtICxO81Y6ovd2giVEwY7Y7aZkGnX29m2E7ZbCZ0DO2fsLYXjR0eXFv/mo8Dpiy7g3lUny4Iz+F8cfC3AAlYWrLNbHQN9sNt5x2Bntu1kGVSXTcyHMUVR+D/yrODfPbqjcOhiavRFEzAHZ331J1crDFs4UOZfU2blxyZxczYYLGfdZkvj5YcnsH0IjP2gaWfRPzMwzSmYV3lfFAH3P9J/ezyW8X/BcLeXf2rWFKNw/bNoWVDD2V92uq/VJVPP8xq/+TlG827iBv8vHlD+5uvPlfXMq3TFiOf56P/rE7Vc4c9ysFIn4pQeu5VjqDWS5Ry58sZg93FZgyIpRcjIfJ9XFPbIN3YX7Z1PEcybgPlKnnE8eHIz5/wHnDFmjhD5Ybdufqic3fph20ZC536++fmpWhYj27ZziOT4OQd+HIoVbfzqHhafD0HPi4D7VvYtyghm7OLACmd2a40Nm82ZXRNTiSXLXSU3jUz6sYZwpbcG6361GYP1YIvb/A337wzEgvVf2xM6M9dCnnMBH3/4+LUsgBcV8Gt1YuMZ4zUkALSX44aNur+aLrv1GyHTgxz+ImSyGLcvy8JxVOF4YM3u4qNzKeQ5FfCJhhMrGPgeDlTYo1F21uknQiTzT9PXLHOGScaOjQTNDzewn+/Xj5di9kCc46G1u4q750rIcybgk43hlYyzVgU826q58+nHyvxmeWTKbBGMsWTnSJbZUvi576z9eM6jPIDH1uws3jMXQp4TAX/YEH4cwFZy6Z3ysTJMtWu5ez7Xj0bNNpbsV4NT9ePtWSoXTVfRYP2atqKfzVbIsxbwmYa+Bs4ynlU4D8wmlmzEOj9+rD+sSz+WbA+f+sPgVNm2UeMtlo6G8OjatqJnZyPkWQn4dH3fvYwFfq8AQZ+RHDFWGXG5ZGPJjvlgo/lOJ0vlw4/niIHxB77ZVvxyukJOW8CnHz5+ZyCD71M4L5Bhk08/MFmRYT/f3Q/2Pn92fqy2CI2WIjXLMmd+/BhjuP+bO4veTEfIaQn4dEN4WYChk3OKKWsa6c+PNbJiZwy2+5GpxZL1sKKTZZBFvLRFYzabzvloc42Xv/k7R9Ycw5pk8YbiCr9rXRouVMoC5isPZA0GQ/sV8GVu/p1zbZR8ZRs1MtUIU6rs1ox1Tv62cZF89H4853h/IF5wx5N72HQqmpyygAcbwj9TwJudNdG/HyjzQ/3HktPRLLsfLDO7fti9e4zb/Tnp+vEK+LZvtxWRx+L7SEnAg/X9X+IMzxsn5yefa9fIuY0lG2uqciuDuKIuhNKabMSiHCM90/iwYwLDPVOmktqMPIbrmwqQUxEQOZfR8AyOd0whMhBLZo00TXeJJc+aQ6Tqx3Owr3y7raDdr4R9C/jcyr5FgSDr5UAxrUB3P1COof7rknWzmYqlKF+Ri2vXFEnn/sH2MZzunBDpvvzKIG7bWIJgnnn6tCDe3jqKoZ5pSX21NRLnZqnc5y+3XK4YbFh0GA7EAtXf8hm39iVgKrE5fzD8OzDcZ2WX6eVZ5z6WHMgL4NanKkCa6XS80TyEiYE47nmmwiZc7ZqZKEfXuvOYjtLMZPlfN3ZsxOrUY+lmSye/XiwOxl46f0PoAT8lQL4EPFzf95jC2L8YsSNVDJJFmFLB4Iy8DJTX5qOiNg8ZeQHEowqG35rE8dZxxKIKSHuvcdBeTXhHW8dBArxxTYGrhXtv+zhOdk4Kbc+tyMDly7OTGnSiawrjA2pmbz5j6XLvxIDtjDU07yzY5WWqPQU88PWDBcGJnGMKeLk7azbUICVXvizv67wynbCahHvNxlLkVmba5hMNz+DgpmEsqM0T2Ot2nOqIYiaiYInHeUfaozjcHsWS2lxUNeXbbvn29gj6OydNOyfkfrnz/P358fagkG4x2Ymp3MllP/jnijG3OXsKeLih72ccaJbHkmV5T+86ZvdIlr0Gq6KuAIvqnLVusGsC0XAMVzW5a2Z/e0S8iyV1dqEZX9KR9ggmBjluXuO8YF7bPIYBKVZ7z18mXCtz9/b7RX5823faClxZtauARx85tjQeZwcAluHElucSg50waNkzi4RZdjv+3DyAW7dVuJ7zzuYLQoNrtpS6nvfm5hEhXDLPTsdgzwz+sHlMyqIvoh8fnwG/6Ym2woNO43QV8IWGvpc58FkjVhqxwQ8GmV0qdRh+/EDjc27eudgLanBw83mEqrIczfTZrgkcfHpMPPvWjcUorsqS3vNc9zR6WyNYsa3E85kvNA75YNv+arWM3oJzhEziXzO27/GdBfenLOBhkUhgr8grH9yzNN67++RhPVr5WZVBEOZODcYwPaAIDbnFh4D/tPqc8HsX1+VjcW2+iU0T9oZ/GRG/p5dH7tHStYWoqCHypB/DvTPY/9MRzESBB3eW+xDweRcNpsuNOyWM3MN5/s5xBSfXixOt/ux3dhW8KhuwowaPNPR1cOABp1iuHSO8Y7FumptbnY3L1pQg02AWIz1TON06CsLgopocxxc+2juNg5voZesvtag6W2jreH8MMwaXx6gp5A+XVGcJl2isP4bRcCyhkRz3P1Pu6ErRU6KDCl5cdwG5FQFcdkcWMvMZpiMcfV3T4n5anCAVP96IzX4wWL83XvxOW8GDvgUceaT/9liMd/NkdbZ9H67b/txUMSi3OgdXbpBrDLlD4a0XULm+WIrD9Hti0ePhGanGeLNVM6vXLNa1dbm43oWM7d8eQV55ADfW5ZreK7lhf26dwNEky7Zqsvr3VGvCnCNeYvyc8/gn10tKfaQaPFrf9yvO8AWZxhmxMRU/1q1S4upti0yaa12Jw11RDOyNYvGqQoGz2jHWO43jO8YQEcJNFeu8/dib14ZwxXK75TjaMYGZCMeNdXmOVuW1rRGc6FbzAnKu4h1Ld+cqFm+D49frdxV80Togm4AjD/ffHg/wbiq/MQ7OSWOda5DURzlFvrTFQZhbuWWhK96Rlr6/+owwn5kVAWRVZCLSP4O4wFSXiI8pWa+d53a+OYlPgyqpzkRpVSbKqjMxEo7heOcURsJxPPRMKTJdombD4ThebBl1nb+3pTP7wdr5Mo7DOTjn/Mbv7i78wPgybQIeE34vZYvssVd7LNnZD/aHQRxknq9wMM/Ggb7TeFrCvo1lNGaGSUTtsto8FFZlYqR3BuQDaxpBfjCx6LHwDI61R0V0y+qHus2/tDoT92wo9CRhbY3DLhrstDvR27LQWO3CFtdte8LiF5sEzP9bd+b4aOkpbtpZL8cQ7x4Xck2xBjlYHsN1z7i7QdODcfSuO5tS741btpQi3xD5IiZ9dMc4rlkVwhUP6qaVYtNvtAxjOqqO1xsbgfLqLHx6g3tQhd7arsZhmwbbOYHTe9LGoxUi+qgJY+xcKJR/xZp/YipmWfcmjTb0fZEBL9hXs17tSBf58WMNDM8Tg67YWI68KrPLYlSPs+1jONM+Lu2eQ5p6RVMBsisyQGz6zN4J5C0JonqD3Y/94+oBfPoZezCkZ/sYzr41hatq81BSlSlY95H2CWGSZf4p/ZuXiY4MKvjNuhExDTlX8Rvxcr/ezm34l55oK/yVVMCRxr5fxTn/gkbR08Vg99olfWVqZiaQl4HKHy9AZrk9cjQRnsHhlkGTZhkxqGpLGfIMmnq+exJnOiakAu5qPIflOxfYTCsJuPyOLCww+MVktjvXncdUQrOtHGRpXa4nyTrZPT0vGCyvYFH1lXO++4ldBfU2AY+tPFzBghmnOJApW3HyygdvDHZmkWYMolBk+aoiFNbkgFJ/M4NxDHdGQdrrNJ786iws3WAPO77bMoSl3y1GtmHBXOidxjubLuBai4mm4Mdr64Zw7zN2N+2NzSOgkKSGeVbLdfvafFwlMk3m4/32CfR3TaOoMoj88gDO9M5gOKwuEf3P3GCwxDsZz41NXPatPQvGTSZ6vOHo40Dg//jBICP7+yj3BhVUZ+MGiYD3N6saf2VdSJjukR4iWTRfdQObIFnVmcLV+aB1HBMDCu7faTfd+7eO4XT3lLQfl6bRRZUZWFSjBjrofn1dU7j+wRzcUGt2r872xNC5NSIsQro1Yd4RQnXRKIx97fs7Qz83CTjScOznHHjUaWeCmx+bnr+cOgaRdl+1tkgEPMZ6pnGidRRL1haZTDTh8IFNw46sWLco5uffsCofVxnIF0W1KCZN6cLCyqBg2gdaozieyBObNVHXzFtX5QkByw5ynX63aTwhZPPznS2d03tyZdu/+F5b6DGrgPs5WKW3BqfB7iQxWSPVl2OKmV2S/3vDFqrY0LNKlAs+snUYi+sKkEUkq2cap/dGRcxZ33tk9QKc/WAiWRU1WaLqo3fHOD65sVgI13j8UZhtjXyZzWx+RQZqt8lLhrR7dLdOoGcv1YdZx2X+uyYH+44Pd+8kYVnC32sLLUkKeKK+b4nCeJ8bO3aPPc++WtGoWbLIT8mKfFwpqdjobjyT7EHpNf5UsjRkyWolCYdD7VEcbFdru6zc4PraHHyiyTm6RXM82xvDi5uMHoFWFpS+dyLr+BfjwatbduX2Cz94vLHvMXD+L5ofmGqExQ82yIrJ3Z9jthREqK7dIOrskwdFsvavpj3T2uZwsx/rXFPlb8/S5yUJB6rm0M20uV66ui4X9MftIAGTmbZH+OSWxug3u3sn6vVJC8zxte/vCv08IeBjuxjHw3YnXB2qPhj1795+sNGM+PMDzRgkY+cMS9aXmLJK/dtHMJiolJSxU3KfqHx2qHsKY+EYLk9g7PGOqGEesg546vPJbfrE2lAyq3SmexpvbtVYvX1ei2uycPd697Kho13T+OPTUal/ne6eLRk7B5jAYSHgSMOxfgCV5jpgq3A1ofnFYPP1Rmz3U62oDdqKQYU12cipzMSF7ilRpmONRRNWl96Rg3Ndk1i2sUSUyBImH2sdww1r1PDiwe1jAmdDV2XiVBdhtjFwb16cORUZAocpBTgTAWrWh5BHzDwcw/6noxgOkxulV1/WPlUkXCOn44XmEYwNqAzBzYI5CM0j9m6yYIe+31ZwI+NNZ/KjsegogIDxpn5jyW6s24+mp19tqU9GwyAiYJ94ivK4AZzvnkJGPkNRVRYmB+M4/PQYbt5QLF7rkdZxXNekatrprkkcSFR6yOavWZbMvAA+91SJKcEQHVDQ0XwhISzV0hVXBnHvxgJpIuI/tkdxpJNqrnXhzsX8ze85uVjjlbH8bDbe2Hcr4/xt1fT6res1J/f9sGBz1sm7y47LvlkLbHBRAVJck41oOI6qjSWimoMiWkeeHkPJndnCD44OxBCqzBRCII2muiyq7DjdRbseYoKdhzuIPJktlWZBSquD+NQGO0N+uWUEF8JxE6bSYqj+Sg5KKoNC0JEBBQc7pnAmwb7NsOfE6p1iz06WVcfgZIQQvIpFG/vqOedtOrY6RVjc9xxpq8gcBLFGbvyybTkGqytf382ovXyKZhVUZ2FqII6j20eRVxnEuc7JRCWHJW+a4BAUACmuVnPLVYk66UOtEfTvNQpZfR49t6AyE8u32AX8r6vVRIVx/sbgDwl4WZ0qbDrGBxS88/wkxgbUJWyPL7jvGzbO38rirRxKYbyBReqPPgnG/k6dilMNkf3f5WbG+frUMdgoZHfLsmxLuQh2EKt+a7WWdZJrhhWzi6ozcUfCdH/QGkHfXiJg8gqWW9cW4EpDaPJoxyTe2UGluDqLN8asSaif3ViALEne+MXN4zjTQ5rvrcF+LKudIFPzyMDfs2jDsVYOPKJrsH3F+6lI0FaWeSV7a3D6GKTDBAU5ypbnYrh7SpTuyFa20Y83+41MaDKZ6+KqoCiVfe/pMVF4J9tLdeWKHOSUMwz2xjAg4tS6H2s9/6+2FSFfbG6zH6T1v2kZw/iAWghoff9O+Wj9/Xp7JwCeZZGGY9TP+AH1AfOHwUaz5QeD3HfdOWO4E4aaNcW+Y4CK7+5IYKy6s0GumfSCqbrjtjXEpgMgovX61nGcD6u7ErXnVK7Iwl1r3Avs32qdxPt7tR0SZgtqfl/p9bHmYC+SgF8HcJcbBsttvXMs2c8OeTNmG1ewfwxyrss2V3r48ePJHfovW9Qdh7TD8Gwy1WeeJ/2+9hlzBouEvLf5gqn3CAU8bvIIepzpjaFjk15pYjezdguYCgYDeIONNxw7yICls8FgPyzan2bJ+1L5sSwyDHIbl+xlknu1eEUOqIHkya4Jg5nWF11ZdRB3S9j0r1cPJ85XMfWG2mzc6hG27OmYwhs7JqQYnk4s3cqhONg7pMEiyDFXGGw0v25+sNlMe2OQDOtStSwyf9GIdaHKID61Ra0E6e+YQO8Oo3apWEtBjxUWNk2Zpt+s1spzVK2jYAhhsNvx8tYIjndTsMZ7/vYwpa9Kj0MkYArmJssavWKk9mCAkQX63fHghKFm/zr1WLJTRMqOYUYN1l4eEax7tqnmlzCYynas74Ouu21tyMSm/7Q9gr5Oyhub53XX2nxcLSkIoPPOh+P41xaKSZvfn2xcdlbv3opKO5+DnSUBE8qLsgT5zeUvXRe0bOe7kx9r//fU/ECnl2HFKjkGm4sT5BpQWp2F7IoATnWqKT3zPPX7EpvOLWc43R3DsCBY8pd+26pcLLXkhynh8MpPI5hMFvo5P8f6fHtWzzmWDo4p8oMnwVii7sTbj021p0Sa+cy08rmGlet5vRMG12wsQkFlEPtNRMucpSKsvqkpX7DoD7tncKRjUqLp+mIgc11SmSFcpjM9Mzgfpj1XVtasejHGalU/3MZ9x0NgymSirebXDUOtGmzEcGd2q6/UVDE4TQyyaJY9kmbEdvKHaxIEilg0CVlmqQiDqd5KO8gf7toszzLRIrjpyzmgYgDNNPd2UJcArUbLf4RQG4vVj5dxi8T7EiY6SbKsGCJbQXPhn8lXprOr5BZhk5ndVPLMZrYKVK8tABW27//pKEYNMWbtOU4smtwkijkbNZMiWQ9ssRfIU5CDkv6qJqeKwcbzncPK6n0DYRZtPHaQc9VNon9y1iy5f+pfsy5ujNseIXP3r2nuNzTli0gW1WJRIZ4Mg8uqs3C3ZFcDZZV0rVRZ9F9sKZSGKekd07m/bKYknrsGy5TOj2VNLPJDLFJ/7HUwNdDhT1Pcshzpd8+xJ7vNKzWVvVF+Ndh4HplnLZJ1qmsS7z5NrS/klSIrthSbTPRg7wxe3aSdr47bjx/8x+0T+ECwb03IZqxP1Y+3yy/whiVUacRIGTtzxzD3lWVl2zqLnUc/0DcGU4TqnqfKTJEsp/mIDeRfyRVCHuiJ4fBeylzpGSW67tPrQ7i8Rt5FQMPuP7dP4s/tVrbuHCGUYa1HFeyLFMlqZYlkg18MdsNQGTt0swwyDPKjgUaNp/roy74cAlVZ9reaNck+HrMFCuQBt6wvRsGSIN7ZOorpiJLAXjvWEXu+vk4VLIUn32uNYsqw2dv4/qrrcjxDlSTgt9uNsWg/fnwqGMyeZZHGvifBuUgXWjHYzQ/UfpcqBtvP988inWLcSzeWoiCxb/i9liHDZnBn4qaNv7g6G7cnmPOHXZN4P1ndYbdgn7GwZ70Ri/E56nusqM7CZze412e1N48my3fs2mnNUvnrT232x9HCxhqP1Ad4QCT8vTDY7Gdaz7f6df7zubPFoIW1IVzZVCBqtE53RFDxmVyc+8OESPpbsT2Z7anLx2XLc3CiY0L8pGQDafBgD23atueDCyozsHyLWvJjPGQVHep8OB7YUoTiSnmnniOi+I4iZapGqsqlPtcce5fLRebHW+XHEfiSpWTHzKLdMNWZbTvFSJ0x2A+2eLFN7R537VwkJkFlObTDYUlTCOPhGI61juPqphAo3kw1WVorJarXem3deQNWy3cMUITrUxL2/HLLaDKSZX1fVM1xz3dDWFBlLp4nP/itHVpttdyCaZbOaCn9vCfj+QxKFeMrD4QmgnkXOLhYak4RFmNFhh8MdvaX5ezYOPhUMdho9q9eW4SK5bn4sCOCnPKgKJulgwR8TaLQbrB7SrQ/XLQ8F8faI+hrj9qS+7KaMNJg404H2um/r+WCtOyGNJdcLsJ0xhhoDxMRsdM9M4Ykv5vr6e5FGDVYBnsKuBJdGsq0lM1aMcs7Rmq8uTeLNg7auyLBzgk4Spbni20qVH812EX1xXbLoC3SihW5uG5NIaYG43h30wXclii0e3/rCAa6NfZqr8jQXx5EbfTCOzJF3dXJrilcXZsrOutQ2WzvL9WUonHeRMDuXJsnqiu1g67d3zqBIyaXKL3521mzfP4cUMtmaRC08Yy+8OGMwX7YnR2DZWbGuQZJryixY5BqWZasLzUVvg91TqBvO5WtmjHMOA9aDJMD8WQihSouNZfGzVKQBaqszTP1qqTrXlp33pQnNs6HqikfeqrIsXfH69ujOJwQcmrehnt/bdn8OaAXvo/XH3mMsYDoJmthYdJYrPU8PxUc7mzbOcukaUeoOgfXSLaKvtc8gMkBrb9Vun68TnR0bWS422KS6d1oe5Po/zVN1+Z/i8vOQjqfNPlX60YTWST3LF1q3obZMtLi4YktpEKDtc1ns8Ng40uyhiW9qzXdY9wMeZK9SeKFbz4vtpI6WQaZH+wWITKef+9Tpci1dB0gAR+S5Inp+bXbShyL7DRz/XtRTakl+c2RK387Pvx5JzM8Q998ljDT/dxU2eE/Rpoqu3PHajM2aYuOCtNvfGqBbfvooU3DwkWiAnfaPnqqPSK65/hl3ZqwKTp1fVMIC+/MFg1LD7ZGEarMwPWWXlhdLSOS/K865rqd7k1OaS6agI2WQvb+UuM25iwdBws/Ydw+quMwe9SYj9QB3W+15VznM831xrmVWVhYF0KoOkto7cnWMVyzvti0AZzI19vNgzaN9qrLrlpbgMWWpmevNg+LZuALa7IEbn/QPiFaCMssAAnpU+tDoA1obsdvW0ZFFsmPH+tmaVSYdOxA+IsnrBvAxxuPNTGOHc4ryy2WLMcwu+tjxPjZYxA1CK/aYu+t0bP5PGIRoLIphKLqLLG7kNwk2nBGJKuyLh+LVuQiFlFAxe7nuidxv6Q5CzUFpz9GVq37mfbxl1dnYoVLeyWq5Pi9aW+wlVjKOYR3XbrFO+Fs1RO7Qq3qEkgc5A9HM3PPKxyZxpVhXynp+GfelSJldQUoXJ6fbGl4oTOKgefHBAM2j0fHINJo6rJjPd5rOY+qjcViE5p20H3ebB7CDWsLhP9rPN5sGcYt3y1EjgVvKW3Yt1eretTmbZ5/YWWGiE1Tm3/ao/SJVXlYIqnDorZK//7DMUyaYtd+skd278R9PzaP8GDBwu+1MtH93NQILVJ/zNCjcm4x2I2dX7VlAbIl7fqphWHfpiFQKyUny1K5thjlBoFRj46T7eOolnXf2TyMWyT9syjYMTmooNrwLQfaT/zGphHTviN9sUMI9aamPJDWaofo4/HLCVw4Hsf1D2ajeElQNGahnpWH9k651GDZs3SpYrD2fjlY0jzbBdzQ90UF/AUtlirfPiHXYDum2Km71TLQ/UvqClBW59wWcHogjkPNZ6URNu1+FIsOVWVirDeGc51RZOQHcNs2u+l+q3kIN28stmnqYbHpLAoKRxZVBRGPAic79bpo3Syrloj83fstW0mNFoG6zR5Kar4RlqwJA7/ehhzOZBgMoHZ9W4h2qyRQ2jAyamUYGSs9yYEFfiImMqLgpGlOrLZy22WunWZpeIdbBjBh6DpnZ+H2xXTt2iIsMGg2dXw/9PQYFq7IxVKDplKcunvTcHITuNv4tbw1pQzdOs2SJv/buhFTNx13Vi+PA/j3NpIcaCC/IHS5YytDepljDUd/BgSaU40lp1tted3Oy11ZJ/2yb/N5jPaoedNUxrVgRR6yygOYGuQ406mFNTkoRUhNSklTT3WqO/xlsWcnrPv0xiKUVdm/AGOcyCubx3DO4O9aK1KMyuEee7djsAu73rberRkp3Yo2hHPO3/aoFBBzkbFLqwbo2CvP0lQ+dZm0haHxZfVtHsKY+DSdxjqtMXKjGUx1XP7y0UYzfd9TJaIZuNvxyuZxnO0x9rH2n2XzZs1mtp2siAmwW9Y/F3rPOC5pQ/Cxxr5f8UTPShH2ShYDOHd+nzcMHozj0LqzWFBXID6MpfXJGuqM4vTzERGm9I5MpRdLz60IYvHybOSWB0QL/zPdM7gQnsEn1xeK7nZux+9EGlHb+Z96LNmt2lJqWTj/9fpdhd4NwWnQF+qP1gRY4E1qCm4WrjUIOewsAAAJp0lEQVRi4uzHyQiaGVPUezHqFruxXMqiVfM8hAVfDiG/2t4Tklg2RbIiYTX4oN0/9brsJIYl77F4Ra70u0nH9k7g9J9m8GmXftEDvTN4JdkqyU/Hd51DGN+3Xwwm3OI8UPOd3fn7rYvO5aMctG+YiY9yOGeZ5FWU7phifJkqplK32fJVhSioyRWNSOmI9E7hzI5R5FG9VZMzy6aIFsWj/WSp/I6L9grfKdlBqL08ikdTrlfWiJQ0nSosx5L+u/z9pYrBrvl4xl58fGcKH+UQZKu+716F4RWr1tn9M7/+sj8MyqwIYspgdq/bUiHaJrkd7zYPiPwwLY5FtXnJ+iwKbtCnZfVd/6rFoWhWeU0OymqyEItwjIXj+FBsF1UrI2s2FIvid6eDzvv31eeFmSYhFy0JIjIQFxWWH+ydTPjOep7ZXROd89kyiyd1XTlS/6wOTW6ksf8lzpX75BhnZXdGouMne6Rfb98aql+/zMc3k0iDKaCgdtixk5/D20dxplONSFGDlmXri0QNlvGgEp/uTRfEp3X+QtJ51irsV5PddXSLpBPK1OYvSw3KWLfUAnFl3+O7ilL/MBYNdrSh70YFeJ8DGfabW6Mv1pWoJQrctzo6s271fks2liHfpRs8jfNAyyCuW18iWgfLDhLeW+sGRded27eUibos2UGx6v9oGcbnJL2j5QLWO8I79dQwCl2+u9FIAM1KIvP3LTs24koGlj3+bOEhJ2vj6+OUDKzZaWeBV5bGrS7Zz8798roCLHT5MCV9z+HEjjFcu95e8WicNCUbIuFYshma0ws5sH0MVz2YK3YYupno366mQr35iCXbLaP2nqyVLhxsW/NsPk5Jj9I+L8vByzXC5Zfdqee7a7qspsro7xKuXr2xzBGHe1uGQO0NL/f4ZCxllAiLKz3OOyryyXHcut6Z2Jk7zrpXRc52/nYcTpYnnYjOxedlaYDDjX2PcQ7RjdaNrc4XBolP5KwqRMlyw9dSwjMIPz2K8fC06Be92JeAYyJV6HaQgGln/+IV2bhZ8iHpYx0TeH+HMYUo32zuFLlyj/i5f2fK+P7jjDc07yya/QeitZcx3ND/ew5+v7pJ2VszZcRhLjAovzpHsGxKQmjjoO8d3rLN/rENoyB7t46IfPDtHp+WJROtfv2bCSJGCX8qlaUqSqqqpC2iftmtG4bKvBNvPz5ZFP/St9uKPu+6UhO/9MRg7SbnVvYtCgZZjwJeYmTV/uql09916B4h0+97xaoCLHpQrp2EvftbhgRmUumsE8miIvguUQTvbKmsFkzfX6wHK9wtndPuTPn1Nn+Z4wyLB2771p4Q9VbxPHwLmO401NBfB+CXfjA43Xymjln+YsTGCNaVEiGP9E6jV3wyVhUNFQFUf7fI9v1gyv9S11n1C6R6zFuHHX9+vBmm0rF0HrF0nnH//9gV2ucp2VQ1WLvhYEPfzwDWbNcs9Qx7lx7zyky1Q4D/LJX6fDLXhSKsyRHpj2MsEca0jqusJlv0kqbRTQ0qOCW+Fuo9fue9RO7zl78v5w52Mu+EscC2b+50/6S7VfApabDQrpUHsoYy8v/EGW5y02R5bNie99TuIcdsa9ZIRmhS+9afX8uinWccnxuH8I69y7epmO9vz5Lpv8ebZbHCz3x1D1M/aerzSFnAdN+BR44t5fHAHwFWlg4GeWd/5JUPfrDRhlniRfiJLDlho/x6+3P8Y3DK82dsKBBX7lqzu/ioT7kmT0tLwHT1YOOxTyo88BIHKzBqcqoYZA9Tzn8+1w+H8D+uOYglJ8Qh7Z7DMBaP475v7S56K1XhqktzFsdgQ//n4hwvcsaCWlDDCYPnAoO8/HB6Rvp9ufxxiLnwY513MNjCujGFK5//5q6SV9MV06wETA892xB+hDY6cck3H9L1A40sVr+HtVwn1QiZUztDucWYLz9eZhmk+WvGFIXjkbVtRYnN+emJeNYCFkJuPP5NhSv/4JZ18vaXnf1APxgqq6nyg3Xe4zJjsJloee/48OvH2yKECv/va3YX/2N6YtWvmhMB0+1ON4ZXcgWtYMhOu6bI1hvSvV44tef4Y9syVu+O2bPvXGDCXgb6psBjq3cW75mtcGeNwdYBnG44sYLz+K85CxR5VxG6s9v5zlJpmmXci+VH450x2IlFq/+uchSvCFlgAJw/9I1dxd1zIdw5F7DQ5Ibwsjjwa4Bda175ZqzT2LZfP9CMxer051uztPtL2a3l+d5+vHz+Bq/jaEDBA4+l4Qq5LYY5M9HGh5xtOLZwGsHdAFbYX477Srd2xXFm53ILINcU9288uHe1MbPrVOqyjcEeD/+8M4bgw3/TFjo7V5qr3WdeBCy0ayXPOBE8sQnAD43VmW7bYfz4p/ZIlFOEyN57w7na0inl59dSGBetfz+ei1PZT3JjRRu+uofRLrs5P+ZNwNpITzx8olYJ8Gc5UOqNQebekO7n29mtHl6ce3br7cebLZMnh+D8DDIyvv7oc0V751yqhhvOu4DpWUdXfnhVMBh7TgHu8e0HunTP8ZOP9qoUsfMDe02ZG4ew/k5uju1eQAIOXovHslZ+zWfKbzYL4KIIWCVEnIUbT35d4fwnFMNOLeLl/a3DVLNUdkx04gZ2DE6dbavj54wNQVFa/npX6TNM3VMw78dFE7A2k5OrTpZNzSj/G2CPKSJU6o6h/jRFlqWyY7DfCFlq/rXbBz+SGky3fHomM/g/H91RSJUHF+246ALWZnak/tTdYMo2BaiRYe3FyFJpz3Vn0bofa65ulLN4mxfA+essmPGt+meLbdtKLoaUPzIBJwXdcOLBOPC3APuMG4um83Wz7s1u7X6pO7tN14918eNf4wp+VL+7dF5JlNci+cgFrA3wUEP4HrCMHygcf2XXKH9+bApZGlOXG2+2blwcnn78bwH246+2lb7m9fIvxu8vGQFrkz3YcOIWzgLf4BwNClCha4ifXXoO+2Z9xLgtOwZsPTCtkTTLuAaAwC4OPPOVttJ3L4bg/D7jkhOwNvBX7uXBhYtOPRAHmsDYFxQgx6hpl0AsOcKBF6Cw1uKzpS9/9lWmfh3rEjsuWQEb39PBrw8UTE1O/yU47uOM3cc5rvbjx2r+8hzGkg+DsX1xhe3LzZzZ+0DrItGq6FI+PhYCtr7At+tPL+FQ7gNj9xEL52DX66zbym7Vq+UxbvdaLQZ2OM7xOgLsZcbYSw89V3byUhambGwfSwHLJvJ6w9lbGPgyAMs4sEwBFnKOPASQTz8VsHyAFyWwdoT2mCscUc5AXxAkTTyrcNbDwA7EuXLgwd0L3/m4CVM23v8Px4l5/WI3HHkAAAAASUVORK5CYII=";
var downArrowDarkBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAGm5JREFUeF7tXQ1wHdV1Pmf1/C9ZQrKxCU0wofyakpZCmMkQQzAZA+kUmEZYT7GxMaQ2pdTGMRAyTUNqhobpTIunMw3TySSAjSWNmwCdZggN5qd1EgMGyo/BDlhPsgzG2MZ/ksD2e3s6u/tWe3fv39l9P5aYKkOM0e7be/fcc77zfefc+xA+Iz8vzt/zpVKOZlMJZgPCeQQwgwCnuESTEXGySzAFEJpdf754yAUaQsThkhv86QLuAcCtLtBWAHfr1V0z3vgsvBoci5N4rWP3rBK6VxLgFS7ARQR4pjcP8v/B8p/h34M/ARAC40L5T/V14f3l694lxM0uwcZxDm685rG2XWPtfY0JA7/avns65NwrAXGu68IViHi665vNM1r4Z2BE8v8XGC/++/h14X3i9cF96uvK179LCBvBxY3HSsdeuGHDKXtHu8FHrYGfu5xy02a8fxU5uNAF+HMCnBgYLfLA0CMDz+V7sMnTEx7sP091PQAMuQS/QMS1b5zduvHeezEczqiy+agz8Fvzd15MTsNCIugAxOmRhxk9SzACz4PFz1V7vDkCRJ7uP+8DIFhfInyko6f1rdFk4VFj4O35Dy4tgftdAvxG3CN1HmTG0ORnBOHb7umiB4fXlxMz4/1hZCHC/3QRHujsat00Ggx9wg28ff7A1eQ433OBLhUxUzSGCmuTGByFUdHTxXCux+AoAUtiuny//BzN5xL8DyHd39nV9qsTaegTYmC6l5zfb9t1LQDcA4gXx7GUld1KCZUOg/WYHU/IwvvlbFuH7cmETpOdI77sEty/4+yW/zgROF13A79z46623HH4ewJaBoBOMguOstsIAxnZbc0xWJ9t6yJDQNn8+SC6rks/pvG5Hyx6dOr+enp03QxMQFjo2HWLi/APBNDG95SKeOwIblaCweqsOx5pbDy8jO37AfHuheubf4qAISmoqb3rYuC+BX0XlooN/wIIX7Hx07iniMblZ9EqUUPPl3Wfm6RkwXW28cefI4b3WG7w25LjfnvJY21v19S6/ohr/NP3rYGryaV1BNiqS5yyZbdqDE0qWXrlyo7B5nElRZFUCpkXvj92XVxwc0/zU7U0Qc0MTO3UsDO36z4iupsQMa4QcbJbEw9VZ7ecbFtM6MzXx5+fNrKI2bacQ4yMnwjgR43F5u/fsAFLtTB0TQxcaC/MbMg1dBPAZfrsNqkNx8OZ7IlptGQ1VTJ55AiPFeRKuwdHvDqOwZHYYpq/8PkvOMVcx00bGj+stpGrbuCd83eegQ487QKdESU2Vo1XKACEL8eEjRFfzZrdchWySOTgKWQqjZsVWQh2uATzlva07Kimkatq4IH8wGUItIEApstqlJx1chQiFT/N7lnxCpMqOxYTNE5uIF/P5fFKzN5bIrhmWXfLlmoZuWoG3tXZ346Ea12gCUnPrSWPVfFmtTIVjwiilqxXsuKRgvO5FfN4omFyYPHS9S0bqmHkqhj4g3z/CgD4J4/S6+qxKkyVvdxcz+V4VKVaMteD0/J4uUpl8PQADVYu7Wp+sFIjV2zgD/OFPGHDOpfIqURLFrGOw2N5WJddS5blUx4Gp822RY9PRDpvCIuWdTWvq8TIFRl4d0fhckTn1y5Ajqnk+GNVJS6jVkvW1oPF8J2lSsXg8QRFQJp3a1fLs1mNnNnAu+fvvNhpoI0uUZMKm5g8cKQjQ77ezIPt11fGY8NFKEaKdJGlajz+CCJceev65peyGDmTgXfn+2c7CC8QeZpy6JE8HitmxXoMlnlkOi05khV1kUGleIWLJh429fXoeI8Xb/56ZU0ra3oRb3/JpUv+JgOFSm1gat86fl+u8VUXaLaJ3+l7o9QrW/TItApT2uw2jnU6vi0ukhPP44ngrb2lpj+9dwMeS+PJqQ28L9//oAu0XO+JfB6o4qF8LTmLZ8k8WBV2Odm9WeM2Pycrj3eB1tze1ewxFvZPKgPv6+i7nhB+IU6OU8+VPbK6WjKnpyptdluvHCItjyfAb97e1fRzroXZBv6ovTDTyeE7BNDiTd7MA9UYyu9LjsJmtkhRGQarFkM6Hm+evzpyGTF4pFRJAAeconPebUzdmmVgr8Xm4239/wUIc5PZZbY662dQSy4v+iwKWbo+bgBCfObjsxrncVqAWAY+0FFY7CL+TMSOtBikUphqjcEc5SstBousoZZaupqdCNiOmF++vqnbFqqtBt67ZFtT7pOJvS7QNHPWLPQgjXQ+qOq+6qw1Cvvi7/X3q6/Xd0Um+pgVnRlJ3pwUL8Jx6ccfZucqWdLUBarPIWRRKPocHDg66dPZd/90+hGTka0GPpAvPEgAy9UYpKp72vuYzUoWtwdL19Wo66xIVrPkxZAuu9UpUfb5q0SaZOZu5/1+fXzNHV1NxqzaaODDC3rPLpVwKwA26LLlamJwPEJwPYXPY9NhnU57HlU8vnQc6PxVXVO36bzYaOCD+cKzBPA1ESvTYlCcUgXD4HiKFYMSGjFPIVLzUw5Wc/cs1Z3HI25csb7pytQGPuAXEvA5deeDuUpj9xS1rMfpfIgnevLuQj0vt2G7jMH6iMKpUqk9nV+lSo5HR73IS6u/dkd30/MqI2s9+FC+8CsCmBe9UBnD9IpPdbVkTraqEl9MnvlZ4vEA8PQdXU1XsQ08tKDvwmKRttBId7bJU+IYWBceGNvHW10MtvdqVQeD7c/hsg3/OiIqfXmlotVH6cGHOwpPEMK1Kg+wY6O+94qzn7emnRIC/n/meDzBkyu7m65LerFk4KH5fReWHNritd+oNWf7yqolD+RWqeTFyeOxcW147PB4IiAiOuc7PVN/LxpZMvARn/d61SIVbwxuTcNjwxet5nV6Hs3hgXFj87Lz+HjS8XhZSzeP36y9V4fHJ5xpzaoEL44ZmP5yy7jBw63vU2xnfRJzTNmdWDfVYWNwf1oM0nuuHYM52bm8aM3jt/eEnQAej/hRY+OUP1j6b3g89OKYgQ/nC9chwOP67JjPYyNP4e3ZET2Lg9Wq69XZdlxZSsvj048r3KCm6nTh9WWb3r9K8Yq/L7p+VdfUJ5QGHuosPFEiujYMj1kx2Ny7FKxs7/9Dz0qjxdYag5NhX1c9C8Ufcz23Nlq6uoOlHBmJelZ1N3VIBj7S/u50zDW8TwDjROXK7CmjC4PMipSKx6fDYFXipusDF3MIPY8X5dDI43m8X6ulD04qfnLKbRtOHgxMXv4ZzO9YAeD8sx0bK8PgaPGEkzNjaN32BpUjymeBx7uIN921vvHhmIGH8r0PE8Ai04rkYeOJxqDa9YRx5j9KePwjd3Y1Lk4auI8AT7N7cIShcv1TDBvVz27r1W1Zy71U/BwiiHDyjg9Wdt9/Z1fjrBEDf9JRmOUiFUwYJvNS3ekz3HpuZdltPAG0Z/dZPUvP4+3zN+cE8vzT5RDmE/+KlDv9nu5JfT4GD3YWFgPRz0J+avcUtdjBr+dmO3vDrJDJ/JqTnev3Bpk8RdcgZ49gAXuwn3Bg2LNkvH8kQhDcdFd348NlA/d2I8F8OQFKDsbuKXJ4M6909a47VXarxla+QsbNDZjnX1Vpz5K6J8w+/7iiqGwv8nHYN/BQvrcPAE6rR08RH4OCQWfEoDLPro+WzIkUYm7D6+OutCeMtt/V1XQO0sIPpwwXhw8DgCNiQLiy9Bhk7kmqlZbsTEYoDoeJnpiImLVovqdwc4jqa8npMNj6/kunFadMwMHOwh8j0WueJ/P27Ihhmr9nx16lifPrJAaNm+bArO+0waTTcnBoy6dQeOgglIY9D41jpZ0FxGFHjCim+Z86Zzx8fs5EOD5MsO3nw3Cwv5R4X+rxq3m8HYPNkU5/v8jjHaBzcbiz0EFEXYGBIyOrsZGnpXJ256VVyGatbIWpF00MdRn4pL8I21bv843MUZhED7Z7irhoAE6dMwG+tKxp5Nn73j4Om+47rDlHmrHvN1aXjk4PUr3/aKzpcwgXKY9DHTvuBcQfBKO3Z4H6Myi4K1iU5/SdIknPOuP7bTDl3PEjL9n7F8/I78SMnL5KpdeSAyN/LmHccAC/vOVjOK6IIMn+5+w5hJho2at0KoWQ0PkhDud71xLAgsiDuRik5rFmzNZHgOTzk4ra1IsmwayVJ8UM7P1l2Pfk/T4uc3m83Pim7rb0jHuB4Lnhwwf++yi88tBgzIOjrJbbl23msbp6fPR+7ewEANbhUL7XO894Xq0x2F6l0WNwGFla50yGzy9rURr57dX7y+E6DK9mHmvTuE/RGPdwfwk2rT4Ex8qJnq1f3AZ7pi5QTnZu4vEE+LRn4M0AcIkJg6NB1haDORjUOmcSfMFg5KKPyaoqTRLrdB4QhOU/UnhuaFwv0dJjY3oM5uQQ6fqyg/kDwIs4mO/dhgBnV4LB6vqknN3aFTL1uVTJ7Nbz5NM0Rt7qh+vAyKZxqT0LwfPc8zXG/c3qQ3B82POZeD1b9ZxwkVWCwZz3asohCPB1z4N9kaNaGGxWWKIIIF7HqdIkV3DbnElaI781YmTxeeYqk2fwU+ZM1Br3t75xkzgfsg6ReukjQ1xnyIbBItabImt5cWz3DOwdgDkjBDa5gyGOjbIYEqcU8uk0ZuoVxyAdVVPvGmybMxlmLWtWYvKbZUxWz0fWkmfOmQizNZ77Ox9zvU9KUpUs3/EQ5+Gm+es7N8yNj0KnzB7PwJ8CwIQkBsu8kYctYcFCriur70/3nPhi8v7mhevTFUYe6i/Cm6s/htIwWc/l0hn3SH8Jfrf6YNlzzfOPRy6dlqzODfgYHMyfw+N9DCY46vHgTwHRN7CJB0eYEj3EjKnVw2AbP59mMPIbvpFFxUt8SQgz50yA85ZNlaLAkf4ibBay5fRacjYeqz6Xy65PeLOS35NzNBaik+HXvFL09UxeT1F1McjD5C9qPPn1spHj8wHwPPdcjXFflDDX3ili96x4DpKWnYSfz+XxLoAfokeSrHjio85C02qkYrZqz6I5GCxHhhAOphmM/L8JT55hMO5LAuam65fmnB5k5ufy++JF1sCDk893+nG4s3cbUUCT5IuCm1SUIlxN/E6J+tRZPSOfofFkz8gehfKMe47Gc19efXBExOBgYyUad7o+7nRnY5adaTsOdfRuBgyEDg4G8+u56TCI7ym6yBKNf/qcyXCGwoCD/UX4YOMwnLVEjblbYp6rixQmD6zf6UEqp1Ng8IsJqdLEG2uHQRwezI8UwRw8I/+hwshSNuW1LPUXYcuI56bTkkV+Xi8M5uRG5ff1tKdkrcVysYGLwRx+ZqvSmPhp2uxc16t1MsPInnFfURi3mnVmGwtIhvlqzR8A1+FQZ+FeIPLLhUkMTotB5uwu2RyQZc8ShwfGq2Enz5kEZ2o8OTSuqFDFcw5Re+fyeJOSJYZ3ezVInTiZeXCcj8M9eKTzvQ6HHL/gb8NgQSFhnDOVDoNlTNFhXZzH6nOC6H7PyGcljDw0UIRXf+glVIFCpduDdCK05Gr1ZRM41ydaduKptinWx8O5mG3ztdisPJCLQeJ1X7yxCT531WR/oIN9RXjtvgOCQiXOOx0Gc7PotDlEeL3IVuLzNkcA734E91yk9q2Nn+QmHySgBhUG8z0ruTh0nRv6LDhOvcweLHuWigfGPXN8WwPkJgMMDgQIK2Md5/QcUxZdGY9PM3/RLvLi8bN5d/jsxnGJttkk7x1dGBRv41GvYH1k4WrJZgzN2qsmhl1OBMraLx7OnwCCtlnvP3gbz7xv+NBjsJi48HmgKsyYzpeO92XHExJelUqn2XI8K+7R8XpuZfPnsRNTDmRWyFT1aQKIGt8HO95bjOj4p8kmsjCpcyEKI7pwpvOsbN9VyMMguXpjr7rIJcOsPJbTRWrGYPX4Q1ZiV7xkZ6DyFlLfg8PNZ5VhcPrsVowYXIUs216iyr7BjNcvLs+fm53LO0r43aZiH7T4vOPUEG0+K4fpPop1dtiVK/vKEjE8CnPZMIifnacZV9bsVh/p7LkBZ/7c7FzuvvQbLPpXidtHIxzGRarTY3grWMYwzgpOr3hFnpJN8cnWl63zFFVEqRaPNb0/NQsY8fxHViU3gA929i5Egkej1WVXTMJUfTRiUD0xmJfdmyKiOYewR6Q4BhPhjau6G9cGLlf+8fjw8LhJH7sE4+LYaFa4kp38an6m70gQOyX0Gnf2Kk3WKhVHIVOxDotnZdxLpZ6/mvXQEOWaZty5FodiBvbDdEevcEZldTGYm50nI4h3X9bslqP88LEurnFH4+K+J55CFhc7RF3CnINE/BdHwrNs4HzhOhfo8SC86VJ3kxKl2xukV4h4GMzplDDzSLtn6XMIjsIkRi7VJvh68XgAuHplV6O3W8X/kY4yHDrSuosATlZ3Rep6inRdhKb6sr1TJHyxaTEofU+YSHHGNI/fO6Wp8VTtUYaexY/kdzwI4CwfuxiU9ESfNrDPxpQ9kZeDjBIev2al6TBSbyrehnAiek324PpgUFxsSY9B6bHRvuNBxPJ02XkwfnudPB4Z7RErHhlHPt/BC1Y+1vhmGJ6lEB3+4khn4Qkqn1np3TyWMEi9P3fsacmpd3wQPbmye6r9QHDPyAc7dlzkoPOSdyh4MqsTtWhVONPxaHnl8zE4eo6sjKmqNKMJg/XsQdbCk87EUbzKOxiIyLnojp4pr4req/Vg7xeH/H3D6H8ph6nTQ6V8cRQmmS+rs3M5+9RdZ8/us43LPP+0Ox6yaulGvQDx6RXrU3wph59sdRQudxGeS3JJmTfyeaDaE+P3p8XgtFpy1nqu3hPt80/L41NjMEH6r9Xxvbiz7xkidy5PYRITinR7aXRdkUlFzV51Ue2642rPcnODyeNVMm18cYYRRR9Z5M/PcL40uRtXdDen/2Isb7CH84VzXIC3CKBBNRjTypQ9S9dREeedZk9R8W1ulUreWZHOs3Q7C7i82Tx/9fuSF12iD7vkNsDsFeumbk9ib/h31pdTIuBy0+kxds/6fy3ZnqvYc4ikQkaAa5ZX8uWU3ioIv16WgKaFCRc3uwuuH9tassgaONl5knXUav4AODBcja+X9QZ4oLOwmAj802hNPVUnBINiZ3HUH4PjCpYZQz0P1Gvv5hwmyWZKSPnl65sr/4LoMJYfyPf9moCuDAZp98y0GJwFg8w9S8nsPHi52fcS8XII0YPlSMfLIfSRIryfnrm9q/nrOtwV/7sVg8OLP2ovzMzl8G0X6CQxq651PVcWU3g8OK2WnlZLrmTHg6oLktNt6r93gg+x5PzJbRsavbNVrD9sA3uftD/f9xcA8O8cDObXWZMHm+jqnvpsNcnVTcrXmOfx1HDlX3c3brRatnxBKgN79+zLFx4EwOUqmZKDwWZPycADDRhsVq680SYxMdv50vXi8YjOmlvXm7/SPWn41Aam9q3j9zdMeYUQzrfx4PD3ctuMutvSjqlxDLVfbyqUmLP70NPjmKrHULm7UdXTxsNgVQQCgJfailO/esMGPMb13mAJZ/jZu6D3bCo5vwHANlu34WjXku38NO7pWbXkSk7PIcT9Tsm9ZGlPy4605spkYD9Ud/Z+2SXnGQJsEj05Hqbt2bYc3ngYLD4nLQZzcgj+uPRaOmdcVi0d4UipBHNv62l+Oa1xM3tw+KB9+b4rSgRPE2IuFDV0+2zVmK0/KS5tlUYFB/XCYBXFU3WbhuNRZ9FxHlyef9El9+u3dp/0fBbjVmxg7wP25PsXeBudSPGdD1l5oDoLrp6WPCZ4PKLrEixY1tVc3pyfzcSZQ7T4uD2dO291yf1XU9XJzpe5VRczDxYjhXo88fvt40pm22KiJB5LkV5LNtbZXfqrpT0tP85m1uiuqhjY+7jdnf3t5MJaQJiQup5ZHg8HG+2K12jYGxQ2+uk6UDQ9VZ5ujzAMAItvWd+yoVLjViVEi4PYnR+4jKj0JKHTXM0dD3rMyl6lCj29kuyW0+li1p6TdXNnLxBdc3N3y5ZqGLfqBvY9Od8/uwTwJACeYcoiwyzYrN3qPcC73+zxcnZrUrhMPNbcFSl3m3IiWMQCRsSVHY4L8xZnoEKmxVC1EB3D5HzvjGOQ6wGAy+SXk0VLtn/PUPoqTbC+eRisPp+Z48GqRFORG7xQhNz8b3c17qmW54afUxMD+97VTg0DuYHVAPBdsTtT5Smc3Ymip6sWjW4nhsJTjN+zJPJrTrat2qbCiRTlCOS9mgcmFZv/9oYNWKq2cWsSopODHJg/cLXr0DoCaDXzUjm7Tcdjo/s5+5llXs7PzjnVICuPJ/oQGhqWLHqs+alaGLbmHiwOekf7B1/I5YqPuQCXqhQiTqdENs/S7aXiZbccJSpbDkGbSsXx7TcxS36VLICahejkoAgI+zt3LXGJHvA07HSKlx2D01apZL6s8+BgJnL9NwiAul61eE4Q3O9pyuC693yru/UnGOwpqPlP3QwczmTXjbvajh53/xEAF7t+scN8flXSi4Lr9d2G0e+4dWZZIeNkwfGcQFwcSh7ufeRDx8fl/m7Ro1P319yqwgPqbuDw2e91vP8VQHeNC3CRCmvrUaWKa8M1wmCizZhruK1jXYu0raQehj5hBh4xdH7gqhLA9wDwqyZemxaDrVWaBI9Oq5CF4zFg8CZy4f6OntaaJlG2RXLCDRwOcHu+/1LAhrtdgj/j7JCXmwhMOxh03zNk15Iz8PhfAuCPbuhq3WR7+fX4/agxcDjZbfmBCwidm4kg7wJMjzwky/nSwadyNG6525K3b7jsyXsBnG4C+Mk3u1rfqIfhuM8YdQYOB/7c5ZSbMfP9eSWAhYB4rQswMdlDFe8z5ilkvDNB5Ow4SHlj9eshAngcXFzbsqf12a89j0XuS6/ndaPWwOJL2LZkb9PRT499AwjmEuJcIjhd5qiqPujgU6qoJb8LiBtLLm6cNO74U/PWzvSPKhrNP2PCwMkX+FrH7lkE7lxAnOtl4QR4ZpR1S54mGDlJicw8FgHfLRFsBgefRcRnrnmsbddoNqZqbGPSwKqJbM7vuQCBZgPAbAKY7QLMIILJ4MAU708XcAoANZex9pB3LJhLMOzVXwnA88Q9LuHbCLi1RO7Wq3pmvD7WjKka7/8BbY+V/aWsSwsAAAAASUVORK5CYII=";
var IframeWalletMessageType = "particle-auth-core-iframe-wallet-message";
var walletIframeId = "particle-auth-core-iframe-wallet";
var EntryPosition = ((EntryPosition2) => {
  EntryPosition2["BR"] = "bottom-right";
  EntryPosition2["BL"] = "bottom-left";
  EntryPosition2["TR"] = "top-right";
  EntryPosition2["TL"] = "top-left";
  return EntryPosition2;
})(EntryPosition || {});
var walletPluginIds = [walletIframeId];
function checkMessage(message) {
  const { id, messageType, data } = message;
  const { nonce, date, hash: hash2, iframeId } = JSON.parse(Buffer.from(id, "base64").toString());
  const hashBody = (0, import_fast_json_stable_stringify.default)({
    state: { nonce, date, iframeId },
    messageType,
    data
  });
  const hashValue = (0, import_sha256.default)(hashBody).toString();
  if (hashValue === hash2) {
    return {
      state: { nonce, date, hash: hash2, iframeId },
      messageType,
      data
    };
  }
}
function buildMessage(data, messageType, nonce) {
  const state = {
    nonce: nonce || v4_default(),
    date: Date.now()
  };
  const hashValue = (0, import_sha256.default)(
    (0, import_fast_json_stable_stringify.default)({
      state,
      messageType,
      data
    })
  ).toString().toLowerCase();
  const id = Buffer.from(
    JSON.stringify({
      ...state,
      hash: hashValue
    })
  ).toString("base64");
  return {
    id,
    messageType,
    data
  };
}
var handleEthereumRpc = async (data, provider) => {
  if (!provider) {
    throw {
      code: 4200,
      message: "Wallet plugin not support EVM chains."
    };
  }
  const result = await provider.request(data);
  return result;
};
var handleSolanaRpc = async (data, solana) => {
  if (!solana) {
    throw {
      code: 4200,
      message: "Wallet plugin not support Solana chains."
    };
  }
  if (data.method === "solana_requestAccounts") {
    const publicAddress = solana.selectedAddress;
    if (!publicAddress) {
      await solana.connect();
    }
    return solana.selectedAddress;
  } else if (data.method === "solana_chainId") {
    return solana.chainId;
  } else if (data.method === "solana_signTransaction") {
    const { VersionedTransaction } = await import("./index.browser.esm-BBVP3YNF.js");
    const result = await solana.signTransaction(
      VersionedTransaction.deserialize(Buffer.from(data.params[0], "base64")),
      data.chainId
    );
    return Buffer.from(result.serialize()).toString("base64");
  } else if (data.method === "solana_signAllTransactions") {
    const { VersionedTransaction } = await import("./index.browser.esm-BBVP3YNF.js");
    const txs = data.params[0].map(
      (tx) => VersionedTransaction.deserialize(Buffer.from(tx, "base64"))
    );
    const result = await solana.signAllTransactions(txs, data.chainId);
    return result.map((tx) => Buffer.from(tx.serialize()).toString("base64"));
  } else if (data.method === "solana_signAndSendTransaction") {
    const { VersionedTransaction } = await import("./index.browser.esm-BBVP3YNF.js");
    const result = await solana.signAndSendTransaction(
      VersionedTransaction.deserialize(Buffer.from(data.params[0], "base64")),
      data.chainId
    );
    return result;
  } else if (data.method === "solana_signMessage") {
    const result = await solana.signMessage(Buffer.from(data.params[0], "base64"));
    return Buffer.from(result).toString("base64");
  } else if (data.method === "solana_switchChain") {
    if (!solana.switchChain) {
      throw {
        code: 4200,
        message: "Solana Wallet not support switch chain."
      };
    }
    await solana.switchChain(data.params[0]);
  }
};
var handleRpc = async (event, walletCore) => {
  var _a, _b, _c;
  const messageBody = checkMessage((_a = event.data) == null ? void 0 : _a.message);
  if (messageBody) {
    if (!walletPluginIds.includes(messageBody.state.iframeId)) {
      walletPluginIds.push(messageBody.state.iframeId);
    }
    let message;
    try {
      let result;
      if (messageBody.messageType === "ethereum-rpc") {
        result = await handleEthereumRpc(messageBody.data, walletCore.ethereum);
      } else {
        result = await handleSolanaRpc(messageBody.data, walletCore.solana);
      }
      message = buildMessage({ result }, messageBody.messageType, messageBody.state.nonce);
    } catch (error) {
      message = buildMessage(
        {
          error: {
            message: error.message || error.stack || error.toString(),
            code: error.code
          }
        },
        messageBody.messageType,
        messageBody.state.nonce
      );
    }
    (_c = (_b = window.document.getElementById(messageBody.state.iframeId)) == null ? void 0 : _b.contentWindow) == null ? void 0 : _c.postMessage(
      {
        type: IframeWalletMessageType,
        message
      },
      "*"
    );
  } else {
  }
};
var handleCustomEvent = async (event, customEventHandler) => {
  var _a, _b, _c;
  const messageBody = checkMessage((_a = event.data) == null ? void 0 : _a.message);
  if (messageBody) {
    if (!walletPluginIds.includes(messageBody.state.iframeId)) {
      walletPluginIds.push(messageBody.state.iframeId);
    }
    let message;
    try {
      if (!customEventHandler) {
        message = buildMessage(
          {
            error: {
              code: 4200,
              message: "Wallet plugin not support custom event."
            }
          },
          messageBody.messageType,
          messageBody.state.nonce
        );
      } else {
        const result = await customEventHandler(messageBody.messageType, messageBody.data);
        message = buildMessage({ result }, messageBody.messageType, messageBody.state.nonce);
      }
    } catch (error) {
      message = buildMessage(
        {
          error: {
            message: error.message || error.stack || error.toString(),
            code: error.code
          }
        },
        messageBody.messageType,
        messageBody.state.nonce
      );
    }
    (_c = (_b = window.document.getElementById(messageBody.state.iframeId)) == null ? void 0 : _b.contentWindow) == null ? void 0 : _c.postMessage(
      {
        type: IframeWalletMessageType,
        message
      },
      "*"
    );
  } else {
  }
};
var sendEthereumEvent = (event, args) => {
  var _a, _b;
  const message = buildMessage({ name: event, args }, "ethereum-event");
  for (const iframeId of walletPluginIds) {
    (_b = (_a = window.document.getElementById(iframeId)) == null ? void 0 : _a.contentWindow) == null ? void 0 : _b.postMessage(
      {
        type: IframeWalletMessageType,
        message
      },
      "*"
    );
  }
};
var style = `
.particle-wallet-entry-container .particle-pwe-btn {
  background: none;
  border: none;
  cursor: pointer;
  height: 60px;
  margin: 0;
  outline: none;
  padding: 0;
  position: fixed;
  width: 60px;
  border-radius: 60px;
  z-index: 1000;
}
.particle-wallet-entry-container .particle-pwe-btn:not(.is-dragging) {
  -webkit-transition: all 0.2s;
  transition: all 0.2s;
}
.particle-wallet-entry-container .particle-pwe-btn > img {
  height: 100%;
  width: 100%;
  -webkit-box-shadow: 2px 2px 10px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 2px 2px 10px 3px rgba(0, 0, 0, 0.1);
  border-radius: 60px;
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-wallet-icon {
  display: block;
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-wallet-icon:not(.particle-pwe-wallet-icon-hide) {
  -webkit-animation: particle-pwe-wallet-icon-show 0.3s ease-in-out;
          animation: particle-pwe-wallet-icon-show 0.3s ease-in-out;
}
@-webkit-keyframes particle-pwe-wallet-icon-show {
  0% {
    -webkit-transform: scale(0.8);
            transform: scale(0.8);
  }
  100% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
}
@keyframes particle-pwe-wallet-icon-show {
  0% {
    -webkit-transform: scale(0.6);
            transform: scale(0.6);
  }
  100% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-wallet-icon.particle-pwe-wallet-icon-hide {
  display: none;
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-down-arrow {
  display: block;
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-down-arrow:not(.particle-pwe-down-arrow-hide) {
  -webkit-animation: particle-pwe-down-arrow-show 0.3s ease-in-out;
          animation: particle-pwe-down-arrow-show 0.3s ease-in-out;
}
@-webkit-keyframes particle-pwe-down-arrow-show {
  0% {
    -webkit-transform: scale(0.6);
            transform: scale(0.6);
  }
  100% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
}
@keyframes particle-pwe-down-arrow-show {
  0% {
    -webkit-transform: scale(0.6);
            transform: scale(0.6);
  }
  100% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
}
.particle-wallet-entry-container .particle-pwe-btn .particle-pwe-down-arrow.particle-pwe-down-arrow-hide {
  display: none;
}
.particle-wallet-entry-container .particle-pwe-iframe-content {
  background-color: #fff;
  border: none;
  border-radius: 10px;
  -webkit-box-shadow: -1px 3px 11px 2px #00000073;
          box-shadow: -1px 3px 11px 2px #00000073;
  display: none;
  height: 650px;
  overflow: hidden;
  position: fixed;
  width: 400px;
  z-index: 10000;
}
.particle-wallet-entry-container .particle-pwe-iframe-content.particle-pwe-full-screen-iframe-content {
  top: 0 !important;
  left: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border-radius: 0 !important;
}
@media screen and (max-height: 660px) {
  .particle-wallet-entry-container .particle-pwe-iframe-content {
    height: 600px;
    width: 360px;
  }
}
.particle-wallet-entry-container .particle-pwe-iframe-content.particle-pwe-iframe-content-show {
  display: block;
}
.particle-pwe-iframe-content-dark{
  background-color: #000 !important;
}
.particle-pwe-iframe-content-light{
  background-color: #fff !important;
}
.particle-wallet-entry-container .particle-pwe-iframe-content .particle-pwe-iframe {
  border: none;
  height: 100%;
  width: 100%;
}

`;
var renderStyle = () => {
  const className = "particle-wallet-entry-style";
  const el = document.querySelector("." + className);
  el && el.remove();
  const styleEl = document.createElement("style");
  styleEl.classList.add(className);
  styleEl.innerHTML = style;
  document.head.appendChild(styleEl);
};
var style_default = renderStyle;
var fullScreenClass = "particle-pwe-full-screen-iframe-content";
var isListen = false;
var timer = null;
var draggie;
var _onMessage;
var _onEthereumAccountsChanged;
var _onEthereumChainChanged;
var _WalletEntryPlugin = class {
  constructor() {
    __privateAdd(this, _onMessage, (event) => {
      var _a, _b, _c;
      if (((_a = event.data) == null ? void 0 : _a.type) === IframeWalletMessageType) {
        if (!this.walletCore) {
          throw new Error("Please init wallet entry plugin first!");
        }
        const messageType = (_c = (_b = event.data) == null ? void 0 : _b.message) == null ? void 0 : _c.messageType;
        if (messageType === "ethereum-rpc" || messageType === "solana-rpc") {
          handleRpc(event, this.walletCore);
        } else {
          handleCustomEvent(event, this.customEventHandler);
        }
      }
    });
    __privateAdd(this, _onEthereumAccountsChanged, (args) => {
      sendEthereumEvent("accountsChanged", args);
    });
    __privateAdd(this, _onEthereumChainChanged, (args) => {
      sendEthereumEvent("chainChanged", args);
    });
    if (typeof window !== "undefined") {
      window.addEventListener("message", (event) => {
        var _a, _b, _c;
        if (((_a = event == null ? void 0 : event.data) == null ? void 0 : _a.name) === "particle-network-wallet") {
          const type = (_c = (_b = event == null ? void 0 : event.data) == null ? void 0 : _b.data) == null ? void 0 : _c.type;
          if (type === "logout") {
            this.walletEntryDestroy();
          }
        }
      });
    }
  }
  init(projectConfig, options) {
    var _a;
    this.projectConfig = projectConfig;
    this.walletEntryOptions = {
      entryPosition: "bottom-right",
      preload: false,
      themeType: "light",
      ...options || {},
      visible: (_a = options == null ? void 0 : options.visible) != null ? _a : true
    };
    this.destroy();
    if (typeof window !== "undefined") {
      window.removeEventListener("message", __privateGet(this, _onMessage));
      window.addEventListener("message", __privateGet(this, _onMessage));
    }
  }
  setWalletCore(walletCore, customEventHandler) {
    var _a, _b;
    if (!walletCore.ethereum && !walletCore.solana) {
      throw new Error("Please provide ethereum or solana wallet!");
    }
    if (this.walletCore) {
      (_a = this.walletCore.ethereum) == null ? void 0 : _a.removeListener("accountsChanged", __privateGet(this, _onEthereumAccountsChanged));
      (_b = this.walletCore.ethereum) == null ? void 0 : _b.removeListener("chainChanged", __privateGet(this, _onEthereumChainChanged));
    }
    this.walletCore = walletCore;
    this.customEventHandler = customEventHandler;
    if (this.walletCore.ethereum) {
      this.walletCore.ethereum.removeListener("accountsChanged", __privateGet(this, _onEthereumAccountsChanged));
      this.walletCore.ethereum.on("accountsChanged", __privateGet(this, _onEthereumAccountsChanged));
      this.walletCore.ethereum.removeListener("chainChanged", __privateGet(this, _onEthereumChainChanged));
      this.walletCore.ethereum.on("chainChanged", __privateGet(this, _onEthereumChainChanged));
    }
  }
  walletEntryCreate() {
    this.destroy();
    this.walletEntryRander();
  }
  walletEntryDestroy() {
    this.destroy();
  }
  getWalletUrl(options) {
    var _a;
    if (!this.projectConfig) {
      throw new Error("Please init wallet entry plugin first!");
    }
    const { pathName = "/", query = {} } = options || {};
    let url = `${config_default.env.walletUrl}${pathName}?iframeid=${walletIframeId}&${JSON.stringify(query).replace(/[{}"]/g, "").split(",").filter((value) => !!(value == null ? void 0 : value.trim())).map((keyValue) => {
      const [key, value] = keyValue.split(":");
      return `${encodeURIComponent(key)}=${encodeURIComponent(value.trim())}`;
    }).join("&")}`;
    const { projectId, clientKey, appId } = this.projectConfig;
    const { erc4337, language, themeType, customStyle } = this.walletEntryOptions;
    const topMenuType = (options == null ? void 0 : options.topMenuType) || ((_a = this.walletEntryOptions) == null ? void 0 : _a.topMenuType);
    url += `&projectConfig=${encodeURIComponent(
      Buffer.from(JSON.stringify({ projectId, clientKey, appId })).toString("base64")
    )}`;
    if (themeType) {
      url += "&theme=" + themeType;
    }
    if (language) {
      url += "&language=" + language;
    }
    if (erc4337) {
      url += `&erc4337=${encodeURIComponent(JSON.stringify(erc4337))}`;
    }
    if (topMenuType) {
      url += `&topMenuType=${topMenuType}`;
    }
    if (customStyle) {
      let supportChains = customStyle.supportChains;
      if (supportChains) {
        supportChains = supportChains.map((chain) => {
          return {
            name: chain.name,
            id: chain.id
          };
        });
      }
      url += `&customStyle=${encodeURIComponent(
        Buffer.from(JSON.stringify({ ...customStyle, supportChains })).toString("base64")
      )}`;
    }
    return url;
  }
  openWallet(params) {
    var _a, _b, _c, _d, _e;
    const url = this.getWalletUrl(params);
    const walletIcon = document.querySelector(".particle-pwe-wallet-icon");
    const downArrow = document.querySelector(".particle-pwe-down-arrow");
    const iframeContent = document.querySelector(".particle-pwe-iframe-content");
    if ((params == null ? void 0 : params.windowSize) === "large" || window.screen.width < 600) {
      iframeContent == null ? void 0 : iframeContent.classList.add(fullScreenClass);
    }
    const modalBorderRadius = ((_d = (_c = (_a = this.walletEntryOptions) == null ? void 0 : _a.customStyle) == null ? void 0 : _c[((_b = this.walletEntryOptions) == null ? void 0 : _b.themeType) || "light"]) == null ? void 0 : _d.cardBorderRadius) || 18;
    if (!isNullish(modalBorderRadius)) {
      iframeContent.style.borderRadius = `${modalBorderRadius}px`;
    }
    iframeContent == null ? void 0 : iframeContent.classList.add("particle-pwe-iframe-content-show");
    const uiMode = ((_e = this.walletEntryOptions) == null ? void 0 : _e.themeType) || "light";
    if (uiMode == "dark") {
      iframeContent == null ? void 0 : iframeContent.classList.add("particle-pwe-iframe-content-dark");
      iframeContent == null ? void 0 : iframeContent.classList.remove("particle-pwe-iframe-content-light");
    } else {
      iframeContent == null ? void 0 : iframeContent.classList.add("particle-pwe-iframe-content-light");
      iframeContent == null ? void 0 : iframeContent.classList.remove("particle-pwe-iframe-content-dark");
    }
    let iframe = document.querySelector(".particle-pwe-iframe");
    if ((iframe == null ? void 0 : iframe.src) && new URLSearchParams(iframe == null ? void 0 : iframe.src).get("theme") !== uiMode) {
      iframe.remove();
      iframe = null;
    }
    if (!iframe) {
      iframe = document.createElement("iframe");
      iframe.className = "particle-pwe-iframe";
      iframe.allow = "camera";
      iframeContent == null ? void 0 : iframeContent.appendChild(iframe);
      iframe.src = url;
      iframe.id = walletIframeId;
    } else if (iframe.getAttribute("src") !== url) {
      iframe.remove();
      iframe = document.createElement("iframe");
      iframe.className = "particle-pwe-iframe";
      iframe.allow = "camera";
      iframeContent == null ? void 0 : iframeContent.appendChild(iframe);
      iframe.src = url;
      iframe.id = walletIframeId;
    }
    walletIcon == null ? void 0 : walletIcon.classList.add("particle-pwe-wallet-icon-hide");
    downArrow == null ? void 0 : downArrow.classList.remove("particle-pwe-down-arrow-hide");
    this.updateIframeContentPosition();
  }
  setWalletIcon() {
    const walletIconEl = document.querySelector(".particle-pwe-wallet-icon");
    const downArrowEl = document.querySelector(".particle-pwe-down-arrow");
    walletIconEl && walletIconEl.setAttribute("src", walletIconDarkBase64);
    downArrowEl && downArrowEl.setAttribute("src", downArrowDarkBase64);
  }
  updateIframeContentPosition() {
    var _a, _b;
    const iframeContent = document.querySelector(".particle-pwe-iframe-content");
    if (!iframeContent || ((_a = iframeContent == null ? void 0 : iframeContent.style) == null ? void 0 : _a.display) === "none") {
      return;
    }
    const walletBtn = document.querySelector(".particle-pwe-btn");
    if (!((_b = this.walletEntryOptions) == null ? void 0 : _b.visible)) {
      walletBtn.style.display = "none";
    }
    const walletBtnRect = walletBtn.getBoundingClientRect();
    const iframeContentRect = iframeContent.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    const iframeContentHeight = iframeContentRect.height;
    const iframeContentWidth = iframeContentRect.width;
    const walletBtnHeight = walletBtnRect.height;
    const walletBtnTop = walletBtnRect.top;
    const walletBtnLeft = walletBtnRect.left;
    const walletBtnBottom = walletBtnRect.bottom;
    const walletBtnRight = walletBtnRect.right;
    if (walletBtnBottom + iframeContentHeight + 10 < windowHeight && walletBtnRight + iframeContentWidth + 10 < windowWidth) {
      iframeContent.style.top = walletBtnBottom + 10 + "px";
      iframeContent.style.left = walletBtnLeft + "px";
    } else if (walletBtnBottom + iframeContentHeight + 10 < windowHeight && walletBtnLeft - iframeContentWidth - 10 > 0) {
      iframeContent.style.top = walletBtnBottom + 10 + "px";
      iframeContent.style.left = walletBtnRight - iframeContentWidth + "px";
    } else if (walletBtnTop - iframeContentHeight - 10 > 0 && walletBtnRight + iframeContentWidth + 10 < windowWidth) {
      iframeContent.style.top = walletBtnTop - iframeContentHeight - 10 + "px";
      iframeContent.style.left = walletBtnLeft + "px";
    } else if (walletBtnTop - iframeContentHeight - 10 > 0 && walletBtnLeft - iframeContentWidth - 10 > 0) {
      iframeContent.style.top = walletBtnTop - iframeContentHeight - 10 + "px";
      iframeContent.style.left = walletBtnRight - iframeContentWidth + "px";
    } else if (walletBtnRight + iframeContentWidth + 10 < windowWidth) {
      const top = walletBtnTop + walletBtnHeight / 2 - iframeContentHeight / 2;
      iframeContent.style.top = top < 30 ? 30 + "px" : top > windowHeight - iframeContentHeight - 30 ? windowHeight - iframeContentHeight - 30 + "px" : top + "px";
      iframeContent.style.left = walletBtnRight + 10 + "px";
    } else if (walletBtnLeft - iframeContentWidth - 10 > 0) {
      const top = walletBtnTop + walletBtnHeight / 2 - iframeContentHeight / 2;
      iframeContent.style.top = top < 30 ? 30 + "px" : top > windowHeight - iframeContentHeight - 30 ? windowHeight - iframeContentHeight - 30 + "px" : top + "px";
      iframeContent.style.left = walletBtnLeft - iframeContentWidth - 10 + "px";
    } else {
    }
  }
  setButtonStorageData(data) {
    const { innerWidth, innerHeight } = window;
    const position = this.walletEntryOptions.entryPosition || "bottom-right";
    localStorage.setItem(
      _WalletEntryPlugin.WALLET_BTN_POSITION,
      `${data.x},${data.y},${data.direction},${position}`
    );
    localStorage.setItem(_WalletEntryPlugin.WALLET_BTN_POSITION + "_window", `${innerWidth},${innerHeight}`);
  }
  getButtonStorageData() {
    var _a, _b, _c, _d, _e, _f;
    const { innerWidth, innerHeight } = window;
    const [x, y, direction = "right", position] = ((_b = (_a = localStorage == null ? void 0 : localStorage.getItem(_WalletEntryPlugin.WALLET_BTN_POSITION)) == null ? void 0 : _a.split) == null ? void 0 : _b.call(_a, ",")) || [];
    let [width, height] = ((_d = (_c = localStorage.getItem(_WalletEntryPlugin.WALLET_BTN_POSITION + "_window")) == null ? void 0 : _c.split) == null ? void 0 : _d.call(_c, ",")) || [];
    width = Number(width || 0);
    height = Number(height || 0);
    if (width && height && (width != innerWidth || height != innerHeight)) {
      localStorage.removeItem(_WalletEntryPlugin.WALLET_BTN_POSITION);
      localStorage.removeItem(_WalletEntryPlugin.WALLET_BTN_POSITION + "_window");
      return {
        x: innerWidth,
        y: innerHeight,
        position: position || ((_e = this.walletEntryOptions) == null ? void 0 : _e.entryPosition) || "bottom-right",
        direction: "right"
      };
    }
    return {
      x: Number(x) || 0,
      y: Number(y) || 0,
      position: position || ((_f = this.walletEntryOptions) == null ? void 0 : _f.entryPosition) || "bottom-right",
      direction
    };
  }
  updateWalletBtnPosition(x, y, type = "") {
    const { width } = document.body.getBoundingClientRect();
    const { direction } = this.getButtonStorageData();
    const isRight = x > width / 2 || type == "windowResize" && direction === "right";
    let left = isRight ? width - 60 : 0;
    let top = y;
    let newDirection = "left";
    const safeDistance = window.screen.width > 600 ? 30 : 10;
    if (left < safeDistance) {
      left = safeDistance;
      newDirection = "left";
    } else if (left > width - (60 + safeDistance)) {
      left = width - (60 + safeDistance);
      newDirection = "right";
    }
    if (top < safeDistance) {
      top = safeDistance;
    } else if (top > window.innerHeight - (60 + safeDistance)) {
      top = window.innerHeight - (60 + safeDistance);
    }
    return {
      left,
      top,
      direction: newDirection
    };
  }
  closeWallet() {
    const iframeContent = document.querySelector(".particle-pwe-iframe-content");
    iframeContent == null ? void 0 : iframeContent.classList.remove("particle-pwe-iframe-content-show");
    iframeContent == null ? void 0 : iframeContent.classList.remove(fullScreenClass);
    const walletIcon = document.querySelector(".particle-pwe-wallet-icon");
    const downArrow = document.querySelector(".particle-pwe-down-arrow");
    walletIcon == null ? void 0 : walletIcon.classList.remove("particle-pwe-wallet-icon-hide");
    downArrow == null ? void 0 : downArrow.classList.add("particle-pwe-down-arrow-hide");
  }
  resize() {
    const that = this;
    return () => {
      if (isServer())
        return;
      clearTimeout(timer);
      timer = setTimeout(() => {
        localStorage.removeItem(_WalletEntryPlugin.WALLET_BTN_POSITION);
        const walletBtn = document.querySelector(".particle-pwe-btn");
        const { x: btnX, y: btnY } = this.getButtonStorageData();
        const x = btnX || window.innerWidth;
        const y = btnY || window.innerHeight;
        const { left, top, direction } = that.updateWalletBtnPosition(x, y, "windowResize");
        if (walletBtn) {
          walletBtn.style.left = left + "px";
          walletBtn.style.top = top + "px";
        }
        this.setButtonStorageData({
          x,
          y,
          direction
        });
        that.updateIframeContentPosition();
        (async () => {
          let count = 0;
          do {
            count++;
            await this.sleep(100);
            this.updateIframeContentPosition();
          } while (count < 15);
        })();
      }, 10);
    };
  }
  async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  preload() {
    const url = config_default.env.walletUrl;
    const script = document.createElement("script");
    script.src = `${url}/preload.js?_=${Math.floor(Date.now() / 6e4) * 6e4}`;
    script.setAttribute("data-target", "web-wallet");
    document.body.appendChild(script);
  }
  async walletEntryRander() {
    var _a;
    if (isServer())
      return;
    style_default();
    html_default();
    this.setWalletIcon();
    if (((_a = this.walletEntryOptions) == null ? void 0 : _a.preload) !== false) {
      this.preload();
    }
    const walletBtn = document.querySelector(".particle-pwe-btn");
    const { x: btnX, y: btnY } = this.getButtonStorageData();
    if (btnX && btnY) {
      if ((Number(btnX) || 0) < window.innerWidth && (Number(btnY) || 0) < window.innerHeight) {
        const { left, top } = this.updateWalletBtnPosition(Number(btnX) || 0, Number(btnY) || 0);
        walletBtn.style.left = left + "px";
        walletBtn.style.top = top + "px";
        this.updateIframeContentPosition();
      } else {
        const { left, top } = this.updateWalletBtnPosition(window.innerWidth, window.innerHeight);
        walletBtn.style.left = left + "px";
        walletBtn.style.top = top + "px";
        this.updateIframeContentPosition();
      }
    } else {
      const position = this.walletEntryOptions.entryPosition || "bottom-left";
      let top, left;
      if (position === "bottom-right") {
        top = window.innerHeight;
        left = window.innerWidth;
      } else if (position === "top-right") {
        top = 0;
        left = window.innerWidth;
      } else if (position === "top-left") {
        top = 0;
        left = 0;
      } else {
        top = window.innerHeight;
        left = 0;
      }
      const positionData = this.updateWalletBtnPosition(left, top);
      walletBtn.style.left = positionData.left + "px";
      walletBtn.style.top = positionData.top + "px";
      this.updateIframeContentPosition();
    }
    let isDraggie = false;
    const Module = await import("./draggabilly-GWQYC2ZW.js");
    const Draggabilly = Module.default ? Module.default : Module;
    draggie = new Draggabilly(walletBtn);
    draggie.on("dragStart", () => {
      isDraggie = true;
      walletBtn.style.cursor = "move";
    });
    draggie.on("dragMove", () => {
      this.updateIframeContentPosition();
    });
    draggie.on("dragEnd", (event, pointer) => {
      event.stopPropagation();
      walletBtn.style.cursor = "pointer";
      const { clientX: x, clientY: y } = pointer;
      const { left, top, direction } = this.updateWalletBtnPosition(x, y - 35);
      walletBtn.style.left = left + "px";
      walletBtn.style.top = top + "px";
      this.updateIframeContentPosition();
      (async () => {
        let count = 0;
        do {
          count++;
          await this.sleep(20);
          this.updateIframeContentPosition();
        } while (count < 70);
      })();
      this.setButtonStorageData({
        x: left,
        y: top,
        direction
      });
      setTimeout(() => {
        isDraggie = false;
      }, 50);
    });
    const controlIframe = (0, import_debounce.default)(() => {
      var _a2, _b;
      if (!isDraggie) {
        const iframeContent = document.querySelector(".particle-pwe-iframe-content");
        if ((_b = (_a2 = iframeContent == null ? void 0 : iframeContent.classList) == null ? void 0 : _a2.contains) == null ? void 0 : _b.call(_a2, "particle-pwe-iframe-content-show")) {
          this.closeWallet();
        } else {
          this.openWallet();
        }
      }
    }, 30);
    walletBtn.addEventListener("touchend", (event) => {
      setTimeout(() => {
        controlIframe();
      });
    });
    walletBtn.addEventListener("click", (event) => {
      var _a2;
      (_a2 = event == null ? void 0 : event.stopPropagation) == null ? void 0 : _a2.call(event);
      setTimeout(() => {
        controlIframe();
      });
    });
    window.walletEntryPlugin = this;
    if (!isListen) {
      isListen = true;
      window.addEventListener("resize", window.walletEntryPlugin.resize(), false);
      window.addEventListener(
        "message",
        (events2) => {
          var _a2, _b, _c, _d, _e, _f;
          if (((_a2 = events2 == null ? void 0 : events2.data) == null ? void 0 : _a2.type) === "PARTICLE_WALLET_RESIZE_IFRAME") {
            const walletEntryPlugin2 = window.walletEntryPlugin;
            const iframeContent = document.querySelector(".particle-pwe-iframe-content");
            const classList = iframeContent == null ? void 0 : iframeContent.classList;
            if ((_b = classList == null ? void 0 : classList.contains) == null ? void 0 : _b.call(classList, fullScreenClass)) {
              if (!((_c = this.walletEntryOptions) == null ? void 0 : _c.visible) || window.screen.width < 600) {
                walletEntryPlugin2.closeWallet();
              } else {
                (_d = classList == null ? void 0 : classList.remove) == null ? void 0 : _d.call(classList, fullScreenClass);
                walletEntryPlugin2.resize();
                walletEntryPlugin2.updateIframeContentPosition();
              }
            } else {
              (_e = classList == null ? void 0 : classList.add) == null ? void 0 : _e.call(classList, fullScreenClass);
            }
          } else if (((_f = events2 == null ? void 0 : events2.data) == null ? void 0 : _f.type) === "PARTICLE_WALLET_CLOSE_IFRAME") {
            window.walletEntryPlugin.closeWallet();
          }
        },
        false
      );
    }
  }
  destroy() {
    var _a, _b, _c, _d;
    if (isServer())
      return;
    (_a = draggie == null ? void 0 : draggie.destroy) == null ? void 0 : _a.call(draggie);
    window.removeEventListener("resize", (_b = this == null ? void 0 : this.resize) == null ? void 0 : _b.call(this), false);
    (_d = (_c = document.querySelector(".particle-wallet-entry-container")) == null ? void 0 : _c.remove) == null ? void 0 : _d.call(_c);
  }
};
var WalletEntryPlugin = _WalletEntryPlugin;
_onMessage = /* @__PURE__ */ new WeakMap();
_onEthereumAccountsChanged = /* @__PURE__ */ new WeakMap();
_onEthereumChainChanged = /* @__PURE__ */ new WeakMap();
WalletEntryPlugin.WALLET_BTN_POSITION = "walletBtnPosition";
var walletEntryPlugin = new WalletEntryPlugin();

// node_modules/@particle-network/btc-connectkit/esm/index.js
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_react7 = __toESM(require_react());

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = { number, bool, bytes, hash, exists: exists2, output: output2 };
var assert_default = assert;

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes2(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
var Hash2 = class {
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor2(() => new SHA256());
var sha224 = wrapConstructor2(() => new SHA224());

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes2,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber2,
  isBytes: () => isBytes3,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  if (!isBytes3(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes2[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber2(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!isBytes3(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes3(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  let res = new Uint8Array(sum);
  let pad2 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset2 = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset2();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset2();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root2 = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root2 = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root2 = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f3, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f3.ONE;
  if (power === _1n2)
    return num;
  let p = f3.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f3.mul(p, d);
    d = f3.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f3, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f3.is0(num))
      return acc;
    tmp[i] = acc;
    return f3.mul(acc, num);
  }, f3.ONE);
  const inverted = f3.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f3.is0(num))
      return acc;
    tmp[i] = f3.mul(acc, tmp[i]);
    return f3.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f3 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f3, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f3, n)),
    invertBatch: (lst) => FpInvertBatch(f3, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f3);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f3 = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f3 };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!isBytes3(data))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice2(h(sig.s));
    const r = slice2(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f3 } = this.wNAF(n);
        point = p;
        fake = f3;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes5(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes3(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (isBytes3(dst))
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function abytes(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  abytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  abytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes3(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root2 = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root2), y))
    throw new Error("Cannot find square root");
  return root2;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2562);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2562(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2562(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  ],
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2562
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/ethereum-cryptography/esm/utils.js
var assertBool = assert_default.bool;
var assertBytes = assert_default.bytes;
function wrapHash(hash2) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash2(msg);
  };
}
var crypto3 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/@ethereumjs/util/dist/esm/internal.js
function isHexPrefixed(str) {
  if (typeof str !== "string") {
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
  }
  return str[0] === "0" && str[1] === "x";
}
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexPrefixed(str) ? str.slice(2) : str;
};
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
    return false;
  return true;
}

// node_modules/@ethereumjs/util/dist/esm/helpers.js
var assertIsHexString = function(input) {
  if (!isHexString(input)) {
    const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
    throw new Error(msg);
  }
};
var assertIsBytes = function(input) {
  if (!(input instanceof Uint8Array)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw new Error(msg);
  }
};

// node_modules/@ethereumjs/util/dist/esm/bytes.js
var BIGINT_0 = BigInt(0);
var hexToBytesMapFirstKey = {};
var hexToBytesMapSecondKey = {};
for (let i = 0; i < 16; i++) {
  const vSecondKey = i;
  const vFirstKey = i * 16;
  const key = i.toString(16).toLowerCase();
  hexToBytesMapSecondKey[key] = vSecondKey;
  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;
  hexToBytesMapFirstKey[key] = vFirstKey;
  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;
}
function _unprefixedHexToBytes(hex) {
  const byteLen = hex.length;
  const bytes2 = new Uint8Array(byteLen / 2);
  for (let i = 0; i < byteLen; i += 2) {
    bytes2[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];
  }
  return bytes2;
}
var unprefixedHexToBytes = (inp) => {
  if (inp.slice(0, 2) === "0x") {
    throw new Error("hex string is prefixed with 0x, should be unprefixed");
  } else {
    return _unprefixedHexToBytes(padToEven(inp));
  }
};
var hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
var bytesToHex4 = (bytes2) => {
  let hex = "0x";
  if (bytes2 === void 0 || bytes2.length === 0)
    return hex;
  for (const byte of bytes2) {
    hex += hexByByte[byte];
  }
  return hex;
};
var BIGINT_CACHE = [];
for (let i = 0; i <= 256 * 256 - 1; i++) {
  BIGINT_CACHE[i] = BigInt(i);
}
var bytesToBigInt = (bytes2, littleEndian = false) => {
  if (littleEndian) {
    bytes2.reverse();
  }
  const hex = bytesToHex4(bytes2);
  if (hex === "0x") {
    return BIGINT_0;
  }
  if (hex.length === 4) {
    return BIGINT_CACHE[bytes2[0]];
  }
  if (hex.length === 6) {
    return BIGINT_CACHE[bytes2[0] * 256 + bytes2[1]];
  }
  return BigInt(hex);
};
var hexToBytes3 = (hex) => {
  if (typeof hex !== "string") {
    throw new Error(`hex argument type ${typeof hex} must be of type string`);
  }
  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {
    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
  }
  hex = hex.slice(2);
  if (hex.length % 2 !== 0) {
    hex = padToEven(hex);
  }
  return _unprefixedHexToBytes(hex);
};
var intToHex = (i) => {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw new Error(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
var intToBytes = (i) => {
  const hex = intToHex(i);
  return hexToBytes3(hex);
};
var zeros = (bytes2) => {
  return new Uint8Array(bytes2);
};
var setLength = (msg, length, right) => {
  if (right) {
    if (msg.length < length) {
      return new Uint8Array([...msg, ...zeros(length - msg.length)]);
    }
    return msg.subarray(0, length);
  } else {
    if (msg.length < length) {
      return new Uint8Array([...zeros(length - msg.length), ...msg]);
    }
    return msg.subarray(-length);
  }
};
var setLengthLeft = (msg, length) => {
  assertIsBytes(msg);
  return setLength(msg, length, false);
};
var toBytes4 = (v) => {
  if (v === null || v === void 0) {
    return new Uint8Array();
  }
  if (Array.isArray(v) || v instanceof Uint8Array) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes3(v);
  }
  if (typeof v === "number") {
    return intToBytes(v);
  }
  if (typeof v === "bigint") {
    if (v < BIGINT_0) {
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = "0" + n;
    return unprefixedHexToBytes(n);
  }
  if (v.toBytes !== void 0) {
    return v.toBytes();
  }
  throw new Error("invalid type");
};
var concatBytes3 = (...arrays) => {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad2);
    pad2 += arr.length;
  }
  return result;
};

// node_modules/@ethereumjs/util/dist/esm/constants.js
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
var SECP256K1_ORDER = secp256k1.CURVE.n;
var SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2);
var TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var KECCAK256_NULL = hexToBytes3(KECCAK256_NULL_S);
var KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
var KECCAK256_RLP_ARRAY = hexToBytes3(KECCAK256_RLP_ARRAY_S);
var KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
var KECCAK256_RLP = hexToBytes3(KECCAK256_RLP_S);
var RLP_EMPTY_STRING = Uint8Array.from([128]);
var BIGINT_NEG1 = BigInt(-1);
var BIGINT_02 = BigInt(0);
var BIGINT_1 = BigInt(1);
var BIGINT_2 = BigInt(2);
var BIGINT_3 = BigInt(3);
var BIGINT_7 = BigInt(7);
var BIGINT_8 = BigInt(8);
var BIGINT_27 = BigInt(27);
var BIGINT_28 = BigInt(28);
var BIGINT_31 = BigInt(31);
var BIGINT_32 = BigInt(32);
var BIGINT_64 = BigInt(64);
var BIGINT_128 = BigInt(128);
var BIGINT_255 = BigInt(255);
var BIGINT_256 = BigInt(256);
var BIGINT_96 = BigInt(96);
var BIGINT_100 = BigInt(100);
var BIGINT_160 = BigInt(160);
var BIGINT_224 = BigInt(224);
var BIGINT_2EXP96 = BigInt(7922816251426434e13);
var BIGINT_2EXP160 = BigInt(1461501637330903e33);
var BIGINT_2EXP224 = BigInt(2695994666715064e52);
var BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256;

// node_modules/@ethereumjs/util/dist/esm/units.js
var GWEI_TO_WEI = BigInt(1e9);

// node_modules/@ethereumjs/util/node_modules/@ethereumjs/rlp/dist/esm/index.js
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

// node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n6, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n6;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n6 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n5)
      t ^= _1n6 << (_1n6 << BigInt(j)) - _1n6;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class extends Hash2 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists2(this);
    const { blockLen, state } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists2(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_224);
var keccak2562 = (() => {
  const k = wrapHash(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak384 = wrapHash(keccak_384);
var keccak512 = wrapHash(keccak_512);

// node_modules/@ethereumjs/util/dist/esm/account.js
var toChecksumAddress = function(hexAddress, eip1191ChainId) {
  assertIsHexString(hexAddress);
  const address = stripHexPrefix(hexAddress).toLowerCase();
  let prefix = "";
  if (eip1191ChainId !== void 0) {
    const chainId = bytesToBigInt(toBytes4(eip1191ChainId));
    prefix = chainId.toString() + "0x";
  }
  const bytes2 = utf8ToBytes(prefix + address);
  const hash2 = bytesToHex4(keccak2562(bytes2)).slice(2);
  let ret = "0x";
  for (let i = 0; i < address.length; i++) {
    if (parseInt(hash2[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }
  return ret;
};
var pubToAddress = function(pubKey, sanitize = false) {
  assertIsBytes(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
  }
  if (pubKey.length !== 64) {
    throw new Error("Expected pubKey to be of length 64");
  }
  return keccak2562(pubKey).subarray(-20);
};
var publicToAddress = pubToAddress;
var emptyUint8Arr = new Uint8Array(0);

// node_modules/@ethereumjs/util/dist/esm/db.js
var KeyEncoding;
(function(KeyEncoding2) {
  KeyEncoding2["String"] = "string";
  KeyEncoding2["Bytes"] = "view";
  KeyEncoding2["Number"] = "number";
})(KeyEncoding || (KeyEncoding = {}));
var ValueEncoding;
(function(ValueEncoding2) {
  ValueEncoding2["String"] = "string";
  ValueEncoding2["Bytes"] = "view";
  ValueEncoding2["JSON"] = "json";
})(ValueEncoding || (ValueEncoding = {}));

// node_modules/@ethereumjs/util/dist/esm/types.js
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));

// node_modules/@ethereumjs/util/dist/esm/signature.js
function calculateSigRecovery(v, chainId) {
  if (v === BIGINT_02 || v === BIGINT_1)
    return v;
  if (chainId === void 0) {
    return v - BIGINT_27;
  }
  return v - (chainId * BIGINT_2 + BigInt(35));
}
function isValidSigRecovery(recovery) {
  return recovery === BIGINT_02 || recovery === BIGINT_1;
}
var toRpcSig = function(v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  return bytesToHex4(concatBytes3(setLengthLeft(r, 32), setLengthLeft(s, 32), toBytes4(v)));
};

// node_modules/@ethereumjs/util/dist/esm/asyncEventEmitter.js
var import_events2 = __toESM(require_events(), 1);

// node_modules/ethereum-cryptography/esm/sha256.js
var sha2563 = wrapHash(sha2562);

// node_modules/@ethereumjs/util/dist/esm/blobs.js
var BYTES_PER_FIELD_ELEMENT = 32;
var FIELD_ELEMENTS_PER_BLOB = 4096;
var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
var MAX_BLOBS_PER_TX = 2;
var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;

// node_modules/@particle-network/btc-connectkit/esm/index.js
var import_react8 = __toESM(require_react());
var import_events4 = __toESM(require_events());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React9 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React5 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
      }
      buffer2 = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React3 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React4 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React4.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React5.forwardRef(function(props, parentRef) {
  var ref = React5.useRef(null);
  var _a = React5.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React5.createElement(
    React5.Fragment,
    null,
    enabled && React5.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React5.cloneElement(React5.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React5.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React8 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React7 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React6 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css9) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css9;
  } else {
    tag.appendChild(document.createTextNode(css9));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React6.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React7.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React7.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React7.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React8.useRef([]);
  var touchStartRef = React8.useRef([0, 0]);
  var activeAxis = React8.useRef();
  var id = React8.useState(idCounter++)[0];
  var Style2 = React8.useState(styleSingleton)[0];
  var lastProps = React8.useRef(props);
  React8.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React8.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React8.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React8.useCallback(function(_event2) {
    var event = _event2;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React8.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React8.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React8.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React8.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React8.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React8.createElement(
    React8.Fragment,
    null,
    inert ? React8.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React8.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React9.forwardRef(function(props, ref) {
  return React9.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@particle-network/btc-connectkit/esm/index.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());

// node_modules/viem/_esm/utils/getAction.js
function getAction(client, action, name) {
  return (params) => client[action.name || name]?.(params) ?? action(client, params);
}

// node_modules/viem/_esm/errors/log.js
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
};

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath });
  const definition = formatAbiItem(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method: method2 }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method2 === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : void 0;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/viem/_esm/utils/errors/getContractError.js
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath4, functionName, sender }) {
  const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath4,
    functionName,
    sender
  });
}

// node_modules/viem/_esm/errors/estimateGas.js
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause, { account, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath4,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
};

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
function getEstimateGasError(err, { docsPath: docsPath4, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath4,
    ...args
  });
}

// node_modules/viem/_esm/errors/fee.js
var BaseFeeScalarError = class extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
};
var Eip1559FeesNotSupportedError = class extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
};
var MaxFeePerGasTooLowError = class extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
};

// node_modules/viem/_esm/errors/block.js
var BlockNotFoundError = class extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
};

// node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  if (typeof chain?.fees?.defaultPriorityFee === "function") {
    const block = block_ || await getAction(client, getBlock, "getBlock")({});
    return chain.fees.defaultPriorityFee({
      block,
      client,
      request
    });
  }
  if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
    return chain?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/actions/public/getChainId.js
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  });
  return hexToNumber(chainIdHex);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, chain, chainId, gas, nonce, parameters = ["chainId", "fees", "gas", "nonce", "type"], type } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  if (parameters.includes("chainId")) {
    if (chain)
      request.chainId = chain.id;
    else if (typeof chainId !== "undefined")
      request.chainId = chainId;
    else
      request.chainId = await getAction(client, getChainId, "getChainId")({});
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account)
    request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
      address: account.address,
      blockTag: "pending"
    });
  const block = await (() => {
    if (typeof request.type !== "undefined")
      return;
    return getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
  })();
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      request.type = typeof block?.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type === "eip1559" || request.type === "eip4844") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
        block,
        chain,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : void 0
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}

// node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const account_ = args.account ?? client.account;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    const { accessList, blobs, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account?.type === "local" ? await prepareTransactionRequest(client, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client.request({
      method: "eth_estimateGas",
      params: block ? [request, block] : [request]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
var docsPath2 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath2 });
  const abiItem = abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem(x)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath2 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs({ abi, eventName, logs, strict = true }) {
  return logs.map((log) => {
    try {
      const event = decodeEventLog({
        ...log,
        abi,
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events2 = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events2)
    return formattedLogs;
  return parseEventLogs({
    abi: events2,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : void 0;
  const events2 = !event ? abi.filter((x) => x.type === "event") : void 0;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events: events2,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/viem/_esm/actions/public/readContract.js
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/viem/_esm/actions/public/simulateContract.js
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter: filter2 }) {
  const strict = "strict" in filter2 && filter2.strict;
  const logs = await filter2.request({
    method: "eth_getFilterChanges",
    params: [filter2.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter2) || !filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter: filter2 }) {
  return filter2.request({
    method: "eth_uninstallFilter",
    params: [filter2.id]
  });
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter2 = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      ;
      (async () => {
        try {
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend2(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend2(combined) });
    };
  }
  return Object.assign(client, { extend: extend2(client) });
}

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry2({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { retryDelay = 150, retryCount = 3 } = {
      ...options,
      ...overrideOptions
    };
    return withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key, name, request, retryCount, retryDelay, timeout, type },
    request: buildRequest(request, { retryCount, retryDelay }),
    value
  };
}

// node_modules/viem/_esm/errors/transport.js
var UrlRequiredError = class extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
};

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal || null }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      const { body, fetchOptions = {}, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const { headers, method: method2, signal: signal_ } = { ...options.fetchOptions, ...fetchOptions };
      try {
        const response = await withTimeout(async ({ signal }) => {
          const request = new Request(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method2 || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          });
          if (onRequest)
            await onRequest(request);
          const response2 = await fetch(request);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data = await response.json();
        else
          data = await response.text();
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
  };
}

// node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      name,
      async request({ method: method2, params }) {
        const body = { method: method2, params };
        const { schedule } = createBatchScheduler({
          id: `${url}`,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}

// node_modules/viem/_esm/utils/ens/errors.js
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.data?.errorName === "ResolverNotContract")
    return true;
  if (cause.data?.errorName === "ResolverError")
    return true;
  if (cause.data?.errorName === "HttpError")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}

// node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}

// node_modules/viem/_esm/utils/ens/labelhash.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes2[offset] = encoded.length;
    bytes2.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset + 1)
    return bytes2.slice(0, offset + 1);
  return bytes2;
}

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/errors/ens.js
var EnsAvatarInvalidMetadataError = class extends BaseError {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
};
var EnsAvatarInvalidNftUriError = class extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
};
var EnsAvatarUriResolutionError = class extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
};
var EnsAvatarUnsupportedNamespaceError = class extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
};

// node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// node_modules/viem/_esm/actions/ens/getEnsText.js
async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsName.js
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsResolver.js
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}

// node_modules/viem/_esm/actions/public/createEventFilter.js
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events2 = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events2,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}

// node_modules/viem/_esm/actions/public/getBalance.js
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber(count);
}

// node_modules/viem/_esm/actions/public/getBytecode.js
async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return void 0;
  return hex;
}

// node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}

// node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter: filter2 }) {
  const strict = filter2.strict ?? false;
  const logs = await filter2.request({
    method: "eth_getFilterLogs",
    params: [filter2.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/utils/regex.js
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

// node_modules/viem/_esm/utils/signature/hashTypedData.js
function hashTypedData(parameters) {
  const { domain = {}, message, primaryType } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
}

// node_modules/viem/_esm/utils/typedData.js
function validateTypedData(parameters) {
  const { domain, message, primaryType, types } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name, type } = param;
      const value = data[name];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base, size_] = integerMatch;
        numberToHex(value, {
          signed: base === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types.EIP712Domain && domain)
    validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    const type = types[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}

// node_modules/viem/_esm/utils/abi/encodeDeployData.js
var docsPath3 = "/docs/contract/encodeDeployData";
function encodeDeployData(parameters) {
  const { abi, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => "type" in x && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath3 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/viem/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA22 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/viem/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2242 = class extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2564 = wrapConstructor(() => new SHA2562());
var sha2242 = wrapConstructor(() => new SHA2242());

// node_modules/viem/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f2(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
var BUF = new Uint32Array(16);
var RIPEMD160 = class extends SHA22 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + f2(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + f2(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = "Ethereum Signed Message:\n";

// node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes(message.raw);
  })();
  const prefixBytes = stringToBytes(`${presignMessagePrefix}${messageBytes.length}`);
  return keccak256(concat([prefixBytes, messageBytes]), to_);
}

// node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}

// node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// node_modules/viem/_esm/actions/public/getStorageAt.js
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// node_modules/viem/_esm/actions/public/getTransaction.js
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash2) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}

// node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction(client, getTransaction, "getBlockNumber")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// node_modules/viem/_esm/actions/public/getTransactionReceipt.js
async function getTransactionReceipt(client, { hash: hash2 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}

// node_modules/viem/_esm/actions/public/multicall.js
async function multicall(client, parameters) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi, address, args, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0; j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0; j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi, address, functionName, args } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// node_modules/viem/_esm/constants/contracts.js
var universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// node_modules/viem/_esm/utils/data/isBytesEqual.js
function isBytesEqual(a_, b_) {
  const a = isHex(a_) ? toBytes(a_) : a_;
  const b = isHex(b_) ? toBytes(b_) : b_;
  return equalBytes(a, b);
}

// node_modules/viem/_esm/actions/public/verifyHash.js
async function verifyHash(client, { address, hash: hash2, signature, ...callRequest }) {
  const signatureHex = isHex(signature) ? signature : toHex(signature);
  try {
    const { data } = await getAction(client, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage2(client, { address, message, signature, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData2(client, parameters) {
  const { address, signature, message, primaryType, types, domain, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/watchBlockNumber.js
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data.result?.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count }) => ~~(1 << count) * 200,
  timeout
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash2]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
      const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
              if (!transaction) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction;
                retrying = true;
                const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err));
            }
          }
        }
      });
    });
  });
}

// node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && prevBlock?.number) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n; i < block.number; i++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            if (!active)
              return;
            const format = client.chain?.formatters?.block?.format || formatBlock;
            const block = format(data.result);
            onBlock(block, prevBlock);
            prevBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// node_modules/viem/_esm/actions/public/watchEvent.js
function watchEvent(client, { address, args, batch = true, event, events: events2, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter2 = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events: events2,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address,
                args,
                event,
                events: events2,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events2 ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}

// node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter2;
      const unwatch = poll(async () => {
        try {
          if (!filter2) {
            try {
              filter2 = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit.onTransactions([hash2]);
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getContractEvents: (args) => getContractEvents(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage2(client, args),
    verifyTypedData: (args) => verifyTypedData2(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}

// node_modules/viem/_esm/constants/number.js
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint256 = 2n ** 256n - 1n;

// node_modules/@particle-network/btc-connectkit/esm/index.js
var import_bitcore_lib = __toESM(require_bitcore_lib());
var import_react11 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_events5 = __toESM(require_events());
var import_react13 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
"use client";
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var BaseConnector = class {
};
var bitget_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAORlWElmTU0AKgAAAAgABgESAAMAAAABAAEAAAEaAAUAAAABAAAAVgEbAAUAAAABAAAAXgExAAIAAAAfAAAAZgEyAAIAAAAUAAAAhodpAAQAAAABAAAAmgAAAAAAAABIAAAAAQAAAEgAAAABQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpAAAyMDIzOjA4OjA0IDE0OjA5OjI0AAAEkAQAAgAAABQAAADQoAEAAwAAAAEAAQAAoAIABAAAAAEAAACAoAMABAAAAAEAAACAAAAAADIwMjM6MDg6MDQgMTA6MDk6MDkAdpUVnwAAAAlwSFlzAAALEwAACxMBAJqcGAAACW9pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMjMtMDgtMDRUMTQ6MDk6MjQrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAyMy0wOC0wNFQxMDowOTowOSswODowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMjMtMDgtMDRUMTQ6MDk6MjQrMDg6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAyMy0wOC0wNFQxMDowOTowOSswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpjZmU0ZDc0NC0wMGY0LTRhOTEtYjI2Mi0xMDFmNmYyYjYwYTk8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAyMy0wOC0wNFQxNDowOToyNCswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozMDlmN2NhZS0wOThiLTQ3ZDUtOWE0NC02MTg3MjQ1ZTEwMDY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6Y2ZlNGQ3NDQtMDBmNC00YTkxLWIyNjItMTAxZjZmMmI2MGE5PC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPnhtcC5kaWQ6Y2ZlNGQ3NDQtMDBmNC00YTkxLWIyNjItMTAxZjZmMmI2MGE5PC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjMwOWY3Y2FlLTA5OGItNDdkNS05YTQ0LTYxODcyNDVlMTAwNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHBob3Rvc2hvcDpJQ0NQcm9maWxlPnNSR0IgSUVDNjE5NjYtMi4xPC9waG90b3Nob3A6SUNDUHJvZmlsZT4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzI8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyPC90aWZmOllSZXNvbHV0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KM5CZ7gAAQABJREFUeAG1fQm0ZlV15ql6Qw1QDIIoMlUxCNgqgoqJdhoHBrO6lVlM7NUmxgk1JnFpEkSSiETECY0uxcQ5ogTBOQngmKTjkKitSa84MFQxK1FmqupVvfeqv+/b+zv33Pv/rwreqz5w75732efsfc4d/v9/teyYbffPLCtlYlvZVvL/MtIgcoOu9EwTkrdMOssSmoYA/JBDRuVt2zp9yqqcetAQL/0AX44jeOlTcvPsM/3MB98+BJOn+OQr+yAfR8e3bch7Mojoqz1ot21b1z+G1fmiPlqMN3DZJqq4jFco7bAhL8gEdJ6sBopnPULKxsBlOcmdDHFTb/m2uUkkfhJmmmdxOVAK2TgqNtLJ56BJyAEF4EtLM2Jlwkh0+FR5kQmSNrCQA1mGD9D03LbgpE4Kqpb7a8XLoUTXTG5EhUHCgjqMe97KwDlidihZA6nDxKYsbCGnCn3QTDYYH8fR49GIciqwUZ942omHk8WiOU9hZ7EonUKxSjlHSQgCJ2mcBJMtFenCHuOUf8k63WWYK7ImcUKIGZGxXoAOCxD8ZanLcRmXhmwaw3AsHXJBZpMhOs1AwbXc0DPU0baFJAeoJFTLTi6s6wwGMTrFqpmi13GeWzbl0dr00Ecn6TSMqTLkmoMn19qAjMlkNfC8dII2dKop5NTXSjYPitTtJz/9UcYJqsUQetZ1kUBtG3aAaEooPbKZGVScKTO/xVsd4uyYq0I4TrSxXzGTR1z8RjiiO8IY66/xoB7apBVWOt1wgDqwHki3u4GscPIOIn3a8EDSuSMQR6sh93QgSDoSBkL60BbMGGhMOgMWSDm4Zlck1Wqfom0LaNqJpQ8ySUcBxI5hefBDBxuj2qQDJFVjobAS0osT+CoUUi2edLWpRQAl+xIMp6wPki4UBUiRmBRE9zIBrslvZFIYOTngalXdhYQbIbHsKJOt8Zg9DvI+QeNJU+vQe3al+Co/4o01gFI0X7ppw9jJZyO/AxWv4lZuc0PaUZ6HEpw8XWqp1xwKWQGlHXRx/acFjuyRwCThdpsVU6mnL1k4jes+lFJBMbTKUKtFMOIrhQ5suwGFMFxzu2bSWx5XBBwx6/OW0DFbpxu0WGFvlVCLuQKvjoNy+iSPFqTR+vJgqFfKNWBA2QCiOSLjViHfuGSpWPlAJCdM3UqnLHaEvpw63SWAhvSOlvFXaH5Iu7P4PNkg8dDH9IsOJnFNCM0Tr/cQqRf66Z86iUYHQfHsibVc8znQDV+QcClSoT2oy5ujnqzZ6lNX/eRO0dqP+Hbf7AqFwCJwbFVEBv2ypdDjaFgSm7YPQdsAVn7lca7Rp2WElCUUv8UpSrl2AMdlWKPYAUJ9+eHJxsDFT5pJjr5w5v/gk1YLVmdQrw2QQs9k6MtrGhJUL8Cys0baaVtm/dHk2Kz64ezQDMc2XgKowFPyuu7AED/0ldBW1zZDCCOyeBKk32yigbdQybI8BUoqAwHN5LNOAw9FySWj3HrEpRYQ+GTtKTsYBxgfdKMRyYArj5Id8KsP6zVQfqSQq1KM6IcBSyT99AI8HrWIZDwUKVkNL8MCQItVImfU7R0gRMNWkCdZxI1hEAMbKQQPE6zkh1mnB5VaFMalE4uidw/EPtA4HDfipgXZD3nJjGTGyqfAsgqpLyJspN/o0UA7AHUyLvfd9exBpYS66qnhExU/dUYAeqa8TgYI4WSmsexzyVsWPOimnqAN1Il7zhXVbNc0kT31gMintmcZ5qlqhC6V8rJg/SiITq9akwV16ZGZuCLK+wF1TAaa9GwTLNhkISRtnQrNp71xIMIFm50EdLsLaOelzuCgG/KWS+CbQHFxymBJRuOooD3ChxRs84m6GTcMxZQ2NrTnQNsbRNmwryqz186LdDo2VNMgzCQZ1WkMemgOjAZEcVTbhhc3eGCkDvMrvZpo2oY8+OmPBtSlXc4jgRr5ximWDiCFOFlEnYqHKO1yUaWw6sGRcNrh6BdF8Lr7hW3dTSD7HW3hnY40+EZBkiG/pYVLq7EaoHTsiWgnwGqWmRYMmzor0kljyEd6JINiNMlMk5eHJl8aqWRZjwem+Jh42zW+6hxRBn71mbpa7VJKmYLp9FJU409xj6YO+bnuI9GkmXTBkJPgc770CS0DI/DceUDEY6Cc1nkChZYDCQJnWpI3aAocfIrVgHjwCmBgY32rV7/230K7pH/zwTOumxvqWC59KmZrbGo/g3isOk4u8/TReU0HDKK9ZDXsOndNX4oZnckP+PZX54qBtPwMjHqtLVNYE24dKFmPui2uQpBN+Km2UmoKoIk13YYjEpRRX6ftKEonJ0VGskG1VRtp1AFpa6VTst0JoAdM89oq34qQNGgl2Flux10MqVuddV2SpZDpSw0IA9D2jsmmO4sYKgkdODnuHEOVkU8lqmQsWnu0Q/P4pE+fZFJXSNLUGxzRTa52y9LetnXlU04ZTvIjfFvsDCmjoO4A4EWPGSRJojImgUacbSFYhR4MJzFb+LHH1m/wNIBOHBMNI0+S3FgOvx5wDRIKfoxzfOQYN3Q8gnSO/5UkC6iYcftVkmNTLNSTDvWMhx8JsqNWVzh9ZjLkIm2pLhOKKUCzrWWCKTQ+lLX87a16joW61CFSC4C0GpEcj3mGqdEDlnUwkxPj7RLIAaNZzwQH6xs5BSda0qpLG9nhpMkhQX+kqWoby8mTLJSkQ1420XDUTTRSTaZ3DqBOunxnX+qTOPuDvnJKGi30g+hijB1EsUjUlw93BcUFFfmiz8ERYxrwocQbPdpIXxCexc9cCE8dyZsCAF3HRVyNSow14o3JAUm5dQypb9xQPBCeCEIHqMlLG+rXwXJV8z8yqU8n1XMyGM/Ar2jpUhRWNXBxwsgSqZJwH8ap5gEzCNHSjjDG0DVWynjAzGOmpT8uNo9dqV/3KSLcS4c2UiIvRkNy5ACjx0s6CoFzyLlMHcpwxK4QOGXL9XjQ7ADg5Rg8kmBQOZpnoON0WHRGvZZHwoOXc8nTfzjVWTY8aevNNKZtTLI0wrnMcUo3Q/+1Tym4L0MFkLbkoSUIAmfHoS5FpIg4DrMSElSeu7FPqhPHQT3HKpvUIc8+qo5cOolNIUBBOtmlcJyUePKEx6q3LHghI09bvyCpLIBAReeJ0bGSAIgySBFix0CAso3aBq/ygWiQCWngQVed9MMuuGqi367/2rXiCP9t3/bPQIVPTQhSh9sXeWq0J1JvzMCgrD0k5yntUsbxb5ub16G5AF++eBriEkBOW7QYF5G0oX7ahRPQ6UO6sqIu/wubHkw/NfHQaVd47ARhJ37q00fowS8I6tV7AOC1UTFmJSw1kGYwjEo6ybMhee1BvmieqAuogRJSiEZYB29G6tJIcp7Bi8kBYpx6aDGZ0MW+xuRsveduWMTk+fqlMVCZtgmJ62jpxGUtOQtyeZnfsqUsn1pZJletzu8SwAsdqWAzPuqLl30gljp3qe7YDane4qTFA4yvaUWiqOYkC8fJuuZzHpjUhQqgl3zo0p7fCKpzAHTQckSpROBgiYoWjMkmzRu6jk+taAzOyXeHoQ85EXaFJh5P8uMkMgnZh0MylCqTjw9EJifL+o98pPzwZS8ra449tszNzMhPeA2fxBkjrzbpXV2ry1Yb8m3z82V69z3K3d/8p3LAb76wPPGNbyvLJmCNT4g4HhoG5JjB4P+9uCxPPkw8D6ne06dLHvILTLrJs8xQSaYMjMozDugiUEGI3/ij3DpHb7tvFn4mcGTjCLrGgUE3g0q+HAaupIZGBhIFIBuoEPbw3JJ7vEYv/KVv29KGOLduQQHQzFIUx8TkVLnhQx8qP3z52aWsWlXKpk2htITzxKP2K3O33Vr2f8ELypPf/O4yteseZX5mCya9mxMlK6fM8bHLOg7KavzNXNiGuo2+5wV7WfAtg4AyJpRtOTqmhhNtGQvCSbes+qKPRs6L2thLQHTRBUCahmoIXFVOHo/kx4Aj+aGYcuuJmT5tYxl9Gm9lniQ4V5+QcZLVZ5UtK5MrVyL5H1bypw4/vMzeeGMUgfp8ECf6Yr+CmBbsHCsf/eiy+cc/Kute8tJyzPkXoY81SP4MdgBOZ+gKpl3El3FSziDhL3SCH3EP5iB1KKOuDvFiLkWnzAm1nmjYGJLvlW3IYm3tAs8XQjBY8BJAZ+NaDCIHlgoKiCdOIJroERge4zzQATMKyDo5+OTLJ0V1YoJgLBMrVpYbP3VZ+cGLX1KmDjusbP3JT6i+uEaH2FFWPPpwJX8tfD7xTW8tEyt3qcmX40yaBtrgLtK64h0z58U4lUgny7sJxTEHgCAqTRz6TKh40IuEZ2IrHXbcymkf+qHjAtCuQRltUkc7AB13LSjzDCk3zg5c3UQrH1jQOUIaqYWGZDhposAP3bQnwe18DN8TQ1fRd3xLY2J6Vbnpby4v3/vNF5TJQw4uW6+/niqLa3TM5GMHmUERHfKKs8vRf3YhCgzJ5w3gJKbNw1KsOY4ejvFTBzyy6xxZh/xGTjbvRzy+WgzQkQwnJ4+0cELEGrYNT75glzba9oXHau9sO58sgrE7AJ2zGbY4eeLjJFyTwsThP/NCo8qll3bEKaiDtj/Cah++6wTSBo1yF8nE9Mpy06cvL999/m+UqUMPKVvXb8DdOQpjMY2Oc+Uz+Ye/9rXlqHPOK8tQYPNbZsryieYWKf0zlIiHCP7nPDi5mcCWX8em+Qp9+Ug/SlBj54R5nrwDmG9IH8R9sB/hMKwy85q+VETgj9kBoEXFAD2cPPPH4eb1dEB4ED158t1NJyMWTW+0PClk5Q4xyZV/5RXlu89D8g/J5M/NpdVDBE5+rvwj3/CG8vjX/TGuLVNl21asfF7z0W8kt4mt6Sa4sQBUtGCIx9iJ5BhUJCDJckEwWSHPBWTd1HPiZSPe6Nbv5Fs3CiD6Md7XgQ84pM/eDkDGsLnjlm+e9HFyghfUgaC1kV3yaNOXdZcByVJZSQBjcmpVufkzV5Z/PeOs2PZ5w7eTkv+Y884rj/8jJH/ZBJK/VclX4jNIx6BrvAeh+DtCic0kphlBN0ao9gpBMu6fqZNy0kya+YE31/RGzmRat59o7wYJaYMA5Rsnwh3uAFRiG8LgJp9Crk5Xb3ZSbRKx3P7I9lF5YFSe/WUWppD8mz772fIvpz8PKx/X/BtvKmWWT7GLaMwUt/1c+Y95w3nlKCYfL5O2zTL52PbRfx14dsHYQkBRULyOE43Edsk0j12liixI94ogaaopkaSBV1r4Asm3TcJhAdSbQsjxfjR80j8O6o59DGTHbC1sccvIq3wgNcHcMiXoJiMmCcya1FChBlXrJC7gc3JyVbnlc58v3zntzDJ58Loye9PNOy35R557Lq75f6w3ifMoKL5RHE0yWGoaWAyvx8khY4CR4E4vMMiBeI46vEnKyNyETxUF+vLPGb19867eCacX44Loq6Xr4yD9UMZYgOsSkOOogAI34qaHcKjDQTHB7LjVJc1GXu8AwW215bV6LpbJidVI/ufKt049HclfW+ZuvkVbNHUfcmOQWvmP1t3+ka9/fTn69efgV5L4kRS3fSUfXjEOBsbYokWiTBFaNg7y/sXx25J6nPjKB14Lgv6S9vxJP/tRsimnj8oLeiT5qUO9SPSygheYtSDkI+mxBQC7sYOjIVsLibcHCQ0q39pFsJnkVBwZtHzENNkXk8Q2tTy2/W+fdkYk/5bblpz8lYfjJc9Pfloew+Rj9S+fmirzSP6y5dww3aJ/J49cxtY204JQ1wKAgsenuSCtagp7+qt2solVTJ7mCk5sP5ro0eQryWk7gsMpHwcrX3TEoUsD7EYuATU4CNm2R1M2emAAYHoQHHzV4ZxSxoP/cQLG+cjkTzL5V15Zvn3G87Tt74yVvxLX/M141Psv5zL5r2+Sz2lCY4xsmU3GqJgTSpYnxs7mMYjgmFLQ8ruV7/kYzlP64Y4IQ0ZDez3PC7a8Fm8SnHpMbrVPX20RyC9OhCM7ABPjWSDGw62ljRtSJ2zDRknmZCS3wpwg+7V9hTkBk8tWlRuvuKJ8+8yzcMPHa/7St/1VRxxeNv34J+Wx552L5J+Dlzt81Ovu9lV3GVgbn4rCjCwEkYNkU8/Jj/nIuSCf84NTQMyGeeA7WZTFlg09yL16xad96lq/JrXh92TosLXpF0bI6g5ARTfj42DLI+6DtsYrZAA5Ke2AO3kM1LSeJEAw+Td9Gsl/HpN/MN7t36w7c8f3kCBnHZl18h//p+fhmv9H3TUfz/n8PR+zwzjchIPdYzY05XSt4sgx0tY+Wkg9j18rOv04WdTlYVo3e7RJvqETbl0XiPmGkejcGdJP9U2f4Fm37gB06jYOJ89844aUuIPgxWQKx0kyQNJaJZww+iMv+boZhOJkwcq//NPlW2c9P5N/E5K/tEc9J//oC95UnvCHr9EHOrzb50se5p6rTj/qZFB1lMTRMlkVgiW1HAMJjkHylEne4tQF09u5xpz2Hr/v8GkbvJxT6DlZnuOgR7d+8nvJB+0dxas/fMCW8eCoBQDdHDp6TJzBsLWQeJ9ukp0y6+wQ5sToBQuUp5D8DZ/O5B+K5/wNNy35UW81tv2N2PafeOGbyxNe9xoEj+8CIPkTuOHjSDnZbAmA4RqsKQAnmb40dDppRz2OoXFA3IdkIILOeYI+k0Cm9SIpwSdveX58LD4YhK3OQivfej2Y/XS8iINPBeyrVwCga1DGO0hD38CEHs90woNBsbEjtuAF7HRAk/AkUA+zS5ZW/hVI/vOw8vluf8ONOyH5RyD5Py5PvvBCJP8Pyrbl+ErX7Dwe9bgeIjbmkP1n+LGSFSMl5McYg8gzRLbxeFQ0YJIvWYXtHMld6KQP6QPXipQN9MHkPNKnYPriLlETmTqVtgzGlQc74VW3kYHHfE46cFUrDNggUxuF3WAos5ydsBGaP4QjMigo+Qicd/sb8G7/m2cy+Vz5Ny4++QwERbXLkUeUB37043Iskn/0H0byi5If0aLbXL3EGG2eAxXNOaESn2g5cml26rlTQJY2BDpkJ6OgiYJHmeaBeIirPC4BSFCrlzq00QF6wdW/PVnac89T/9TNQuntAOArIAA10mwcfIeHTvD6O4Lth1Cdpo+QwQ5/o4eTwOf8DXi3/02829fr3aVs+xFu2QXbPpP/FCT/GCcfX+jkSx5t5xqTTzTiOCLByjJZHgQTgiN0gt/NRqjRxgmlpuVykQm1XDycXBCktbLJC/eRJPIbWgWAShSkDMoVT11d59Ffj9/qJc5+MBPSGykAyBTIENIokm75+OSz89Dtw45Pu0w+7vY3fO4z5Z/z3f7sUt7tM2C01XjJ8wCu+U975zvKUb//SqxefH+PyUcGmEcmgo0giiEZyQsBNbJ1YtZAthg7ddtki2LC04bA5oR1DlLH8uBHcmnb2wXSjjrjki6+dLI4aN/YtDd/LZ++2H8UAAMC4UbcdDfAwELWJZ825LGi2gIJXsjChjh0eM0HY5qPel/8Qvnfp55ZpvLd/qLv9hkE2i54yfMAXvL8t/e8uxz1qrPx9yLw9IDvCPALo2w61ySCDrZk9UQ5+ALWpV7yWz2b249vZnU/BH3KO1nQTAJ5vR0ADOpKlnIlK33EDtGsfvB7yYS1bc0fSTw6kJ/sRwUAP3UHYABuxIOOlHZ0l3jzWugghjz6VYHkgJT8L32h/MNzTy1T6w4qs7fcuvjXuxm0k38ckv8EJX9Ol5nl/IuItSEyBocmgHjYcJUPhGcKQIqTuHQrP5JFvbg0VJdCqOYilyYciUf9dK95Ip13++SPXfVp4+u1k6udAH4rjWi7hOO9P/35gA/S6sO8hCzESXasksxAOXQq04QwcEInH3wwLevxU18DTNx6y/PiO41r/s1I/jeek8m/7WdlG75ytZS2K67592PbP+4v3l2OUfKx6rHyOXHDRo6GTAEIhsUVS15tViLDLqpRaoG2e6tIPfni5W5HnLPpVV/nB4KQIQbisLVMCRQdeRANP4Z+jCPdSzhGYh2OyzL24w+EiLuosANEYJ6V6K4LzFPjQAU5SDiJIyw6OvgMQjyctCJA84bvFiT/60z+Wqx8Jn+G391ffNsV1/xI/rvKE3/3bAyD13ysfmTHK5SROFkjPTFIjAf/9xv5bCngkwBb9clxBavjUZ586RknH46oH0du2SyQ5Gm+YOzkkR9F0SW0TSZnvadLfR+IuT4twFGfHzF4V4gdAIZsHpyDEo98Imh0JBlO1tkelD6/vwklJv9mXPO/5m1/ZyUfn+o9831/UY45+2WYYnwtjCsfM8eVzdjYBJlIM8RtTuBTf2yjDAKORYh9tP6TZ5EgTpxPHTAlL4ojFoy2fOqkLOYWBZF+hwm0HmEkj4URReDCoA8dUKq4eYSV3xWP7gHoNFoER5y8ODh84wlrkKChVHWTLxonXV6wIqeXr8a2/8X/L8l/1vvfU5748ib5DKjXujH1EtjTAQGzBYvAunQd06FxVzzl7rlCIMR1NNd70lrdKfP1v+WTNy6J9sdv9wzlXSEsUBjor34rKPvOewBQmTxgXdDCuwlU5zg5CAZAO0LzDDUozOjU5Opy69VXla8+55QyedABZfb2n++cbR8r/1lY+U9S8rtrPleQtuuMkyHWBpmSxiDRBKxfGRJFbqk/bDRKvovfKvZHKByQ11rj5gvCh+etVwyyRQKhNCwCji2SDp+U0//IAVvodcUAHegGHYXB/kkTjjwGktkeIHu0tyjp4ETogfRkmKXpyRVK/jXP/u9l8gD8zOqOX5RtmzfT5aLbGlzz70PyT3gfVj62fez5uuHDsx62z7im0nndCDJZ6hDBapUnj7GrkUbwnWre+VChY4Yuz+BzrIkGgrP8USZcVL27l03qUKKkw4fw5Gsec6dQYiF0gm3Dbb+XXPrC0fJ8szfk25chffLnDmioqGZAmrwmuNDwwBLCmjZhH5AOdeAt3xS+uv3L7323XI3kTx10YJn7TyR/ib/Xm953XyX/pPe/Fyv/pUgmbjD0Q032ir4JPA7GDwbJkEby+YPPsU1KaVwtUtPsxtDqhFzj8a6BWLTgR0ycp5bPOZMcJ0LRSLwgGITaQVNmfV/zJW9kHR0+Ojp9SbeTuU+wUQD8o8nkZJBEVQxA3DEVxW9h6tftyzQ0mYjlc7Pluk9eRlM9j89v3Ch8USc4nH74w8uW228vv37J+8qTXvYSJV+vk/M7fE61isCd5KSKRHwMbGpyZUcCI7ttQ7qVEbec88FGyL1jdha/GwRBupWJJh+Glg0hE0tbz/cwgdTv8eBLNG2Aa8XnWIc+wrZLfiunLHaADA50F3zyaMBG5eHR38YwCNvwnfvM5nLf+vWynb37bsHFnqYetmfZcscd5cjnn1WOfcmL5WYej3r8PJ/Tz7jYVLhC6ilkvDTgE8At995Xfvr1b+jHpBoNrwdpDGzBNk4Wi2RZmcM7jL3WrSv7PvbxZevcJmztTGczV2ncFofk2bWSD/02McKhRNjxmyQ2spBD1vDay0FnP/QXMdanAE+egtMAiOFRA8A8MCpOXmxTEZh1BPHufQo/3dpj3cHlJuhN7blHmbnvPpovqm298y7tAD+67G/KD044vjz5Rb9d5ph8fqDEEaI5/sARBQNBC4D9YX6urN5tTVkBzkdwWdrZ7ZXf/mY56Cm/WrbMbsJ3DaII1D9DcRFkPIxJX9POIhhZ/eD3E9fNMfntUa/3adPKiE/AuXmMg31XmnGcumnjLKaHRQMh/4tmxZHKTTmdVB3jYMge19nplavKL777vXLZk48t0wceWGZ/+csy/8ADab0IgEBW7LNPmfn5z8upH/qrcuyLXlTm5vEGkasbMvXbnoORHPSHwWOXLCuXrSjXfuNr5X3PeFbZ+6jHly24L+G3gzLyhxQYv0U0uWK63Pez28r83feVV6MI1mYR8JPHDEGQuA4EUfHkDedSCWJCodjuEJUPO+GCXYLJ66/+8TeM7J96iGRu2ekqANEjgUFHHQ0DDjqrEgRpds7rcNXF5EyvXFFuueYr5YqTnl2m99uv8FKwpCJAH7vjKeAePAU8/1OXlic+/zfLLLZd9emtQHH4BMiWlU90Hv+twEupH19zVbnkpF8va9atLQ/cdrt+/k35Ytr0wx5Wts5sKtse2FRe8x0UwbG/WmYGlwNNN5zX+Uk85s3zB9hbpf3k2rZLcifHP/sm352MPvsFQHsXDncG7Ahzy9mhDtwcVzx5dNrjVQddx5R3euwwDyRkfvNMOfjEk8pZV/192XLrrWVqjz3K8l12gZfFt3t+em3Z7bBDy2W/8YLywysuLysmVsagUHAcPL/lSlgPxgfaA58ENju/uTzmxGeXl+K19H3rN5RdHrVvWb5iBbQW17bceWeZWoG/SrJqRXnnU55abvznfyyrJ1Zhgv22LhJRY0I3xhmX4xNEloLOOQatnYCw0WVyPaZq1+hq60+bnh58mNbuftYDvATgUoGJAlQjrAcQGgTd377Mb+8TqFf59IZJWLl6VVl/9dXlU89+dlmx3/7YCe4qc0u4HCzD7/bW4LOEe6+/obzwyk+XJ+FHI1vncBfOODmq7TWKERP/m16+svwb3lB+4DnPLbutW1vuX+pOsOee+AAae8xd95TX/sPXy6H/7enYCTZjcuNyoPjQ/RB6vsh3Yq3D5AY/E6c8jSafProj5FFIYS88c6w+4BSLt9kBIOyt9qQnWMXC4bTVYYeg7Zi7gA/xqYvQJ3Ce3bipHHbSSeV//v1VZebWW8rk7ruXiV13hYfFtW14ArgPXx7Z7ZCDy8dOP7P8AD8YXTmxIuPrPhplbGMPFAn/pYy5+Zly9P94Tnn5F75Q7sVOsCveMyyfnl5cULDactdd+PPreGR9xD7l7cc9o9zwj98ou2CHWoZ3FXUVc+J5QJ+H5o84YmpXreO2XoXSCx+6AWx8hU5XHBDVfohzbehTQNsQ9pLaJtHB8flSB5SZVOvgkuGt37DK1DEGRF3g3HbnHthcHo0ieOFVV5eZ224rk7vsurQiwI3bffiB6O4ogg+ddlr5IYpgFd48KhY8HXgCF4QqAvyyHEVwzHOeU87+wufLvRs2lN3230+/FkLYi2pb+Mi7aXOZ3ufh5a0oguuzCJbjxrgXCyaftBYJkyo8eUoU8EyUZd4deoWTdrVABjRc1CKwTo+HL8rWRDrBSiT4/Bc4+aKIOjW5TRGYZxgJZ+Ij+S3fRXD4iSeWF139ZdzN/wx/dWvN0ooAv+pRERx8cPkAiuDfkUQWgSaIReBizUJUAoDzPkH3Cjnx8yiCJ+Ey8IrPfqbcfcP6sgeeWvh7wcW2LffeWwr+mhiL4EIUwbXeCXpFgDli/5nkNqldwtsigC4C8uFk9iFyRX84rNf6agsIXcelhUla+Oi2E62sga55HeRu0RUL/0mySEL4mcS1cO7+zeWI448vL77qmrL5Z7eX6TW7lQnsBott/FHnfbfcUnZft6685+RTyg9RBKtzJ+Dlq04EY0EnSnziorMIuBM8+ZRTyyvw1fQ78beG9jjwgKUVwT33oAhm8Oj68PLnKIL/+PpX43KAew8lIhOlZDFhSTthhioMF8oYG9rF0RWTbEd0U259zIWKRQnLFe7kBYQBkwnZRCN3sq0bMupG8iPhsKEtJ3rAZxHM43LwmONPKC/9u6vLpttvKyt2202XhEUXAd7G3Y+njN3XrS3vRhH84PMogqm4J1A8cMxJUUwNLh5pTDALgzvBr5x+RnmViuCGnVAE9+LDr5myet9HlDc/8/jyf7/21bIa7yEwA11hol+v/pq45MWKbRZh5YdNt/q7m3PykON6hM54uWROpLZ5JloJ71ay5Uy0kp1QtJKM5NNOyU77TL7vHZSE1JEehjy3cXN57AknlrO/dHXZiCKYXmIR8JXs/bfejrePa8vFp5xSvp9FoL4ZGyaFj6i8SauPqonzhpB36oTzeLn0VBTB7+F3CnfiKWOPA7gTLOHGEJeDrfdvLLviUfPPn3V8+bevfSWKADeGtQARG5OhAshYmXzLI4mhM8SZWiZ8yDftYmjpHs6EL8N1vk6UV6wT7cRmUq2nwmjvD5oEq5jG6FdbBMx7gvmNM+VxuCd4VRbBUneCOfxFr/tuva3suW5deQeK4Lv4oxKrkTxNJOLR9s+J5pgUA3jEk/ZOwDeMTz3t9PKaz3ym3HkDi2C/MrGEp4OteA0+g88h1qAILnjWCeUHX/1yWcWdYHCJisXBFR/Jd6IWht3uIB1k2/cAhLzO+66feNABjeMpIFa7vqGauJLriWkSy4nqZMuBs3Bgz0JIGFt+0H192KYv87kS57ETHIUi+P2/vaY8wMvBmjW4OVz8PQF3gntxOXgYiuDtp55avoOng9WTLoLRewKvMhaHCgQzE5eDLeVpsH/d5z6LIlhfdsebzCUVwf33l80ogt32e1Q5//gTy//56jUogul4WaQCxJxl4hkTEzqELS8uD6FXk592yDU8Udbf+qnXyVJHWz4D0IpnMiNRvURKlnzi25j8WDkLwd5lIQtHKy2Lhv5j8vE8jp3gqBNOKK/9uy+XB3hjuAuLYA3CXVxjEdyDr5rvhaeDt+Hp4Nv4IxM7LIIcj2JCERDOcifAPcU5n/9cuROfbO6hIlj8G8OtKIJN99yrIviz408q30cRrEYRKIHor014zM0oL4qk2yEi3k7PRWJf9u3km44CQU61or2ClSiv5kh4rFqv6E42TLAKiJOoAgFM3AUimhWuPlKuIliOgfM9wZbyBDwdnHPVV8oDP0cRrN4VTwhLKAL8jb+7br657I0iuOiMM8q38McmVmEniHjwIU5OeBRlTKAmk3HzyCLg5eBXn3tyeQOK4Jcqgn2XvBOwCHbHTnCeioD3BFOYmbwnQGb8ZODt3E8I3s677T10h8mNlY9cYYyWOeGjO4ASAmVdzxvILT2T5V3BW72TaHlLG9ckejITuhh83Y3LD4sCB27CtqIIjnrms8p5V6MI7rgdf6Z1lZ4QMI5FNT4i3skiwMuiC888s/wzbux4T+DLXtwM5tbvWNGTV99kXg64E7AI/lRFsKHsuf/SLwcugnPwNPQ93BjuwssBioAJa1dvh3cJdWINh8kdRzvxhpxQXiCWdy96/Mo3VkAkHYnJ3SEuCZDlJULJJJ5FooSbbnRq8XCCLVdx0Xf2lZPPu/Ct9+Ny8PRnlQu+8o2y6Rd34I85rCgr8ep4sU1FgL8wss8hh5Q3n3Fm+SbuCXbBSx4XI4ug21azGMGLSxRgPh3Mzm8tT0URvBFPF7/APcFeB+yPPya6hJdFeTnY/VGPKn+IG8Pv4xFRRcDXxhisi5CxRXyxmruC6Fa3C8G6pF0EljnxhtSVTmzxSL6TZsjEOmHmAfJDIyU9ZW1BmO9EO8HeFWLSMSDYtjzbcWVO4q90br1/S3ncrx1X3oIi2HzXf6LD6aUVwezW8subbioPx+XgfNwTfAvv/qMIWPTNjSEmzjeD9RJBXt0JtpanPfe55U/xdHAHHhH3XurLIt0Y4nKw777lD/CI+H3sBLv6xhD9RkIJR4/RQmChhJ6T72QPaRdIFAAmnY+BPJQIJFhJdpKY6Ey2Eig6VoiLRskco1f5XOHwX3cRFxGhXtnG7kN9HnxZNMMi+K/HlbdnEXAnWLWEnWCOlwO8Mdx77dpy3sknl29+8Yu4HHgniCJok84J1qUKUHhTBE/H08GfoQh+jiLYh6+N8TcGF9tmWAR4TNwTN5i/i53gX798DYoAOwvnJvt2sg2dQCfcheKEt/LxySc3Gi4BTA46UzIy2ZnM7rOALJBaKNwxeLBouKLzEJ4+4E/28hvFpc/H274oc7/G6QNHWwQX83Jw5x1lbttkWY2vly228engbnyx9OEognOxkr+FIvDlgDtBnXDEwsnW0eJ5Y8jLwTNRBG/EPcXP8Np4n4MOij8tu8jAWAQb8SESLyuvwvcnWARrluGCmDF1icZ8oQ/HGXhu5cknr0266Y430K+rOJNeCwJ0bO9YHVylc5F04svxC6yql3jnpysI3T+oOELfOoa6RGQRefV7R+jtBE87rvzFV7+BL3X+ssxsnC+74Bs4i22zeD9/VxbBH7MIvvSlWgT8CxpOvAoTnWjVZXEqJkwveSyC4/Gy6Hx8KYVF8EhcXnb4XYTtBD2D70fcj+8+7rX//uXlY4pAccA+kk6IedaRMfZko0UQhRDJZzH4WM5B1VXYW/nJh7xbyeDVQukS3fFCLp/Qix0k/LS49N1vC1l0LQ1cOwGeDh731OPKJf/0LfxDUPeWTfduLrvupCJ4HT4K/i6+rLIGlwPFqImMJCsW0LUoEterY0whi+BEfB/h/Ms+VW679tqyP/6ZmaU0FsED+E4Bi+DFKILvfPnLeEQctxMw+ZjXPLy6I8mjyY9kjyZf/HOvnZmFYf1GUK2MrC7seuio+66fOgGT1UddPasmbOlqJ3sERSg728AePP5NXT3X2pd4oQ80ZED4g47Vu06XH333O+Vlv/YrZcXq3cs++z+ybMW2rkiovL1Gv40cu2uZmJwo0/hn4G74tx+Wv/ra18uTnvH0shFfNnGDSrTWEBySIcMZg5jGjesXPvzhcsHv/E7Z4xGPKPfgK+z624Np/lDBSnxtbre99y534E/hf+773ytHHn1MmZnnXzbjrEf/hG3CzR/ygh5NPvloc/hhSDriWMDxQQUZgxHJRqIox4D52rgvhw70mFDtJsThjwkP2PClA3vq0B98yY5895kFp/6ow/8wyTP3by2PfdJTyl/+w7fLS4/7lXLzT/GR605qL3nmM8q78Yj4VFwWZlFsio4Bbq8hcCZ6HlvHKS96kcZ0/ot+p+yOH7Hc+wv8EopVtoi2GTvBnnvtJcu/vfRSFMDRSn43Hzl30GCI4/gdj7PX1zfNDiYnUPBmdHA0wUoSNP1XLdiBVn8sAiU+dOAPjpxg6akYwM+ikMw86maALJ6wZcK5MzTBQ4//gCOL4HEogk9859/LbTeuL9P6kAaG9MEBJBSadDA7uWicaFX1gGzB7xb5vn4VPpmcw06g3lsfNmwhOuVX1PiviZ38Wy8s/3LNl8tVl11W1iCB9+Gr8Itt9+BSwHbTDevxjeMZfOl0JQoKP4Zp5wRyhjc8PJ+MfyhrafqfxDfDNXHxle5IPJXsRBAMb992YD4nvSbOCTSUXfga0YGMvmo/thEvQrdMsaWcRbB142w57DGPLUc8/rHywROLio3x8DAeChQ0fJBwV1uqi96CH7XM85s76cSyVr8aEsEq5z8uwViv/KsPKvl74DuBd9+B9xdLaLvjC6Yb8Xh40Lp1+LLxCn3Z1DF186JhaYiMs39sP/kely4BmjSY24E7qBACyRK2/LrSKcPBR7iA/MFG8hCcV71WdvZVi6LR8yUBea7xBC/uQ9Q3HM9unsWk5P0D7KlMYMi+hYu5MI5wq53MsZJ509drzD70EnSQT0TQ53+XX3JJueDss8te+Mj3l/h28VLaStyXuIpPfgH+RTR0PodfNumfxo1QFHMOcQze5XIhHcZHWVcAGJ1/YeMEUyEmPCFpMMUnlE3QSjpOVQacCbZ+e7PHFR3Jb3YcF479896EuA94pu84WAywZX+WU0B5KglI2OfRQSSdwTc2MtaCrvxkSUmX89Qng9d33pTxv8ve//5ywSteUQ7EXym7CX+lbCltBf4RzD322bvcjhvAS/F3FR53DG4AsfUPbwA1PnRkyD45J6YfLJzko4/myQlIpyNFAL6TWRNDXfSkzoAQrwWT/Kor/7ErVB7tXXj2w37IHxw9Hn2hgqjDHYctzp2defYjmgT6U2O8xM2zAwrBT7edDtmKlRDv63lHjm3qk+9/H5L/yp2S/Gls9XvjtfCt69eXS/FjmqfjUXATk89YM1SH2dKB93Us53CMj4O5A8RkSAGndrKNK2mYANHWAWS3lEnOzsgTP3kpCztoS94WQrNT2HYAa8E0fL59lC84VhHlSJVUx0EeGvvuEs+Yk6a/LAIC6tCnWvKHOFc+/9Ywk3KpVv4ry0FY+TcudeUj+XvhgyEm/2P4rOLp+DndZiYfATAkh2W8gyHp6B3pa0TVX+wATSdKFGl4NC7Y0Jp46XRbuHjQ0Q0biEo3kQnVJFMeOsuRAenCknL3GWZc5cG3m1YunDsYkHGJr7wcD0DVU2ekyWRDXFr1mXjx2yKgCrd9XvMRMJN/Prb9nZX8vXHvwOT/Nf6Q1vH4sYpWPvr0ZZkheg46vD83Hb8bF+doHN/j1lMAVxjbyOSC377wcQBKWqsPQSQxkykawTm5lgNqNWOmY1W3+ryho034qoVBmglu+2twxcyiAo+tB0FoAphIy8CzjnYFEk3SRTa0DKmSN3z8ZPBj73lPeeOrX13WYuVv2AkrP5K/oXxiB8lnLIyPaQ9IjnnduCwjZBtHh2R4E5jKSo7wTIidwFN1xmSRj1O9mwdHNGXUrbBLNAW044l/VkU3hCKDz1VLW+lJB+jghhCXX/lQ8qlDmzBRMomziZdIuxtISDkVMtnitYl3HID8HSGv+Uz+x9/zXiV/3RFHlPX4U/RLaXyH4eRfiuSfgJW/0du+gmvGgI44Q8OxDWnG43EvJHPMlGMHiFU5NJQTnATp1LggAunRrTxlMoxZdCHQmdiEFW/12VHqSBO4t3gkgbZKevIUc5WHLhWo1yacNFvOaeBMNhuFDLPBg0gRr/nY9qdQrB9/73vLn7z6d8s6rPylJn8KyX8Evll08w244UPyT1xw2+8n3WEa1rGBQbylF9IxnxA3gZkADFQCeAhH0bFw8SIBTmblSwYbwS6Z3fbP1d/w1Yn1AyppTAKTxzBaffKYZPLyzl99Z9LUL3H2T1sc3JHsM7uLiSEfjfY6gV4Ip4Db/iRe8kwhBib/XCT/YCT/hiVu+5P44OlR+L3BjfgU8RP4htFJNfkcBP9XVDoHlnE69gFsdVrcwxzyzCdsbgJDjWcdOFVcFhGWJtoywgZPNRlG0tutP3TplIminVpjry+mmIaQKt4BqEs5s9vjozjaQKmvPlQ0RKkNSOCEkxaTvKgKy8WGkMnnh0UT+J7eR9717nLua15TDsanfUtOPr48sj++RLIByf8oPnv4dXz2sFk/EkGkdVIyPse5AIyRjdfdnoxjdNMlgP3aAMWuJh7nJmXkh14wHCtXug3Esy/CMAgfoOUrof3KRv2kIYE6o33iTGYGNlIE1JFeFmh0o/GAHTL4Jx6nBBk2FTwEq/A5f5LJR3Fc8o63ljeec0459PAjynU/Wdo1f4LJx9812HAdko9/JOO5+PEKkx9zqwgdYoWOaWdC+nJrXgTFZFEQoQTU5Fqbk0U5ToZ95bSlfHCEAYwxWtnSp1drMmRDeSac7Lpq2yJoXv7osRNqXvmtf7ll8oH0fNEvGW1hpB4/dq7Jf+dFSv5hRx5Zrv3Rj2i16MbkH7h2bVl/3XXlo/iK+imnnrZg8tmJ4t0O3J7O9mT2Sx22egkIspssKwriRMiJZDMMJmX4TwohN5+w8o3LAZ2MObgUWBQNdGK1A7gwnDiotk0uIWOr7lOXNJuh8CS0AwDnh0BMPh9B35/JPxR3+0o+B5KXCzl6CKc2+R/Dv4p2yumnl835FXBOUBuT4krfLd+44Y70xsnH2dZLgFYDNKikhBJiIkTLMpKcKP0rud7mOYlKdvLTUbx3D6d03PmrPKzh3BWGyTetPpvkk68bRval/9Iv6bY4aJgFAayLjwQadQWhx5U/heRzR3nfOy4q578e2z6Sfx0f9ZaQ/Ems/APWxsr/2OWXl1PxIxVv+w5I44tQND+JRmxj+OP0Wx5NhnS6GQGTmuRkyyizSFwHTrqho44UGmXJKO/zuFA0ZzhJ5qwM9CRsVru85A6glW8Z+zHOMIwTto3+swCItt0qjpTRRHL6Be6VP49P3N7zzreUN//JG+Kav1OSf5C2/Y8j+afhxymb+EKJ/fNly6ANOdujW5lxw9btOF4rH70EQKrJshY9pBfy7TASm7LKDLrac4UpSVAQjhMTTH1PgGmwQhcQPO0KKSOOe6VIPP3wYKMcMrrTAT5hbamnuI2nUPo4aeVPTegLIBe/9U3lbRe8sbvho+Eit32tfHxbeD1u+D7Blc/kw5fuWXKCerEiriHtcZhvaD6heYbmcbhDHmXDhgIItbiZym0+J1LbuyfO3gCF8oSD92MtrbFJlqs/kygl9LUNy3KYXNlDT0GTYNHYzjghFaxHGs3buIiMVXjK5HvAlxyCbfjyxySSP7t1tlx80ZvK2y88vyafY1/sV7qm8Jy/Hx711vM5H9f807DtK/ksACdfg3WkHVS8HVmxlt/iVBjSC7iuvoxQT5eAcJAJA7c6TESgMqNHdUIeDhVB4jIe8C0X5MpnEgHqVg7cRUG+fWvlOx5A7gLSowILxEXBMOgvdYHGGKhHIiFR4tRl8qemI/nvuOj88k4UwKGPjke9JScfL3n4nP9J3u3jhm8T7i8UUyafYTQoydoUY6VGkcXKPRVDj7oEkCnHOLkDQk1qa9EIhVphOPMyTqeJuwjozsnXtg55m3wXhXnqHomulwAmHq0WAkfG5oIIKgZCmeUJGbJWPpO/Zba8461IPrb+Qw5D8n/6Y4x58St/Ot/wbbjhhnIZfjl0Mn48wuSzTuWXMOMzTHK7YJzug+W1jjkFtPOUUNbsACTRWs8t3srIt0xeQYiH7Z1oLYxMFG2hx6T1EgldJ9pFod0BerwJpEx2sKV7RU6EfeZhfyTJk17iBNJrIG/4uPLnsO0r+W+L5F9/7dKSz21/X658JP9v8IbvZLzkGa78Gpvj6THIjLYA22KNkeMd6mkOxvCrIRDrkEe87gBkqA29trRxwvaApzbxxH1z5u2e+r6zZ9KqTiaaJoyIQdXrOmkctpPQ+pQB545BqP7Iox/2RYROE5LWGz5c8/nHod/5dqz8nZR8vtvnNZ/b/uX4szTPxW8PN+e2r200QwGojWuEzWEGtf1zmkipxYdW9DlsQ33r9HYAKQ01W6a3ekUNAWU+gNopO9cKporlhN4BgNeV36x2J7TuAnRop4AqHOonPpJ88NlNnVXagkH9eRjzOX8b/iGLi995PlY/rvnc9pe48nW3fyDu9q+/rnzqys8o+Ztwf6GHHGeZMTVNMSbd4o3KCPpg9UYMk8GpaBv9kdd7D+DJkqJ7zEkMYzB7dHqh7riDCQ9DiZVgumiS7q3eq3yYZNpT309jhNoVyM9YYnVHotWdjLJj4Ew+7/b5vfp3vQuPerzh2wnJ5xu+A/ioh+R/En+G5tTTcM1H8jkVMSEZQwNC1jAeJMohudnHOJ51xsFWn3LSkzVDpFSx8fYvRxE8ydKi6V3beEO7CLQyoc6VrJu6xlSuuI3DjqZtMahAMtnGGZ+Sbl+mYcvEK345Clx+U4fD4TV/msnH7/je9a7zy9veekE59NDDl7zyJ/Ax8UEHrS03IPmXXnFlOQ1/d2Dz7GDlMz6PM1BNMdlLaePsx/HG9THU6+8Akg4iJo8T3LS68sizvNFR8kgzmUyccbCIOgjJSOeOUPXBEw5FrXYWjAuDxg1dVz/9QKaioD3aPFbj9Arc7c9uLhdffF5518Vvj+Rf9xPEtPi7fSV/3bpyAz7Y+evL8Zx/OpK/FSsfg8PDtMbHMDlWN+KmCSnfWW3Y14PxbZ1uB2ijscchROSaZI/EctjaYSvyDiAZksYZ8K7hXaKXYOoo0ZkcJpo2NMWJujzYjMuefOhVHeBM/grc7W/ZsrFc9JbXlg984P07ZdvnjzMOXIuVj+R//LLLy+ln4t1+Jp8VkOEp2Qij0i1fA3gQJ9tQtfU1zrTVtXwcjzLy7U9vAkmwGfYIMwkHuJKZ3rTKIRfPuqTtGDh1JPfOkJCr26ta9wQgdSHClz+4S3j1O8F0T8dtEYgGmzpzTD5W/gyS/+cX/F756Ec/uFO2fXZ78CGHluuv/Wn5KP5FtDPOOhN9IEAFpBNV1FpKc0AumBUPtR5Nm6E81Ub4C+ktpD/k2378DkBtajgiBp60Em0Z5ZSlKsBIYwLlh8lOaXvD5zt5QShIhxAHfxLG17FtolUE8BNyIh3O4prDNZ/J3zzzQLnwwj8oH0PyD3v0Y8r12PZXruS/VqIeMpIGcCzbaYzjQNzwXYsvhVzywQ+X5/3GWegjfOm9B2xJtW5M1x7NyH4qfwGabJsMdS1L0xEwTn+czYIFMG4gbS8OzLyFOqx+oGAbJooJVPG0MHUo3KbkQ4e8wWE786sOPmlj8u+7/57ypje9slzx6UvLIx+5X7n2p/+hMDdvXvw/WsXf6zH5773kL8sLfuu3lXxEqXsJOucwaiORA1eMdRKqxgjSsx9IKduRfGAyVn/og3S8CGKApAAfRKxWVZ9pVu3lgE7y0PZOTSiSxeR7FRtSRj89iJmbhzK/4OlEEyLHwaN6ymg3D8Ekvr15N/45mre85ffLFVdcWo499tfKvffib+/stbf8s/92gNrNyGOTsEEbeiV+mv2v//Kd8t4PfLD8L/z+H2+Q0fcg+YhBrbFLjsZF/1ap/DHIUIc0XQ75Nh3H3xGv9bnsL9+HPz0RfwVFHXlSKmRPiMDj4lZNnPKqk3jlNbS+w0+adoCmDcfyoCs53qYQ8s+ZBgw/xvmyJfSCP4E/qTmDrZ//ktgKfO0aJdTJmxgcywiEjsY6hGBzte+2+57AgOO6Vj/Pty4F7IM0G/HAavIo4wJoG8k2YS1uvXE8ywiH8u3RA9lc/xLQRkPNQbCi85puRxowCNMMSGZpy1UqBqDcN1C6YEoHhHWtJ0ZeCiiTPKFo2tIJGncT7gIrV+2Cr3XhWg8ZC0RJZvGxkExvB9JOYxpA2s/hD2XF1927u333XRPLgGDLZlQxJs98KaSOcUPpJ9Hilrewlbc4dVp6iMfjavzJ3Ii31aAxJwA8shU7T0lw8pvxhC7EbFRRqwio1K8+05eAfYFoE8wOUg2QE87/MiYgKgBAXxL0jXHI58CY3xo7hpJO/7xRzyIgzl1Dj6jsg/wWslPTQPlYqoKgDyB+zqeIqmw1+UH2zoy5KgIV3dPoE628xVutcfyWtxBOHyGLuSTV7QCtVdsbRwkZxYlqQpSs1KsTkTrJDtDY2w+h2DipyFLHHajA2KcOBIsZlh5oJxpov2BIZ8f108jkKYEpYx/UY5dxsiCgilTCTm599ZnqDrm1Hsdr5Y6v5Q3xVqfFqbcjens6Trl1Ykm1r4ItIRyOxLRhq0MeGoNjkth6gZqAnpMtmIoS82TfgCRtFniGD8KFwOJoi4EGKsqE2hkyNuIsAi58Oc4+6It8qrUH1dggFl9EnvIKOFbW6rc4TYd065OyYRvyHgo9TLZ924ch+d0OkFoUcjLUiFjbuCEVEq82pBdqUOpdAqDnglAf6aRNMHHKYiegQYaTPHaVKkRrqPWyACGfIjwgF4ITX408JvqHPkkdpBM3pI1wnLz1U5c8NuJqjbxhdYpmVoNREVXsdxSnpOt5YT1aRrOOIbmTmuRUMLBr0ejDk2J502+dIMrsWGPywJKpyQJuyJUnEU/Aa7KJpy+KpEOYhGBjS7onox7kXKl5qe+tfLAXbGla5fTbu3ywL0gVH06EbOS5tTh51llITuM6F6k09EH2+FXdcheOw/6GkH7H/5VjaiJyTQC1xo2i4dlxw6rR1FWSSp5UJc0GkLkwOCHulyYys5x0MgVT3ku2jQB7O0HTl8ZDveQZVRGCV2moKJ5UrWMhH80ubUCatmySgaBNyw9p1wfpmIuFkykdG1J/kbjtCB3TyCVAvi0ldPNgbA2+EmXd1FMnjV07qVSxulRaX2lPQHYv0VCudPpWPzgp+YCW+77A7qQHwtdumo8ctAdTfOCEPNFWPED7Id3iINVaPhmtDvF+emVSdYLqbEjbfkeyVm8cbt4Q2u9kTaI54yCtPWaEYvkAAASMSURBVEJAkcmzvTugWi966kMofmPr1RTO0oZK0KUvHkl29wrJB6hbvPSh6F2AMtq6mc8Y6v1A47xNfASZfUPH27/9DePx5ZPvBuzS/RralnSLW97CoXwhuuWPw1ue+zXP0P1OclA1MhEYOLU8WsqTT1QinDxx5KnZBgTRttmV3bRy8Rpb2jFZZFnPULJ6GpU72YZUZSPNfgLqc0bR5LUxcdxMOnnss5W3PMdjSBmbYVCdH9PWNz2EQ3lLPxTcuobsh7hpQo+n3gOImRIrtgPySqczt9ZReyPT2rFXF8tYv3TWM8jgaEcDHO223ibX/gzVVxKtnkbuPig3zr5Bt/FR5CPFBNVEpmmfQO6lY9+GssQpaYKxLR1ZbtjqmmdI2TjcvCEM/eDGOd4E1ALwYNpO204op+H29FqZA6CPyicTBye85ywdSw8n2xrSR5tQ83uQBGylRxyHHvsAtaoJjVO1xUMdZ7lQvN4JzIO6mmIERmieBCTANN96lEkv5dJtTmLjpDmxbiMnKvsxsJW1eHu/Mc5WfcIr54r/KoqCpoNhk6xVSHwMq2fayumctFo7K+YRgk+R9Tj5bKaDShpM7wiW626/8c2BkdSLnzSmLnn1AFLx5FN1qEce9dgILXffErSnVLBNT8/G6ac1M97TT6Z5Q8hozKMqcdOG5i8E6w5AhQUbveVsGfW2SRvzenjOQJWZBhSaNG3YqMdGdrvaxUy+dNKOeNUDr+I2SDnVfTSiuDGFQLIMkjhbqz+OJyXYuFBJpwuJeKIdeW0b0q2MeCtv8ZCNJtv21l0Itr6p0+rVAiDTg7VjGYLZDlSyVFQREM+jFkUrpwFodQpIkQOgqHZqGzEHOuCFTWfJL1/7RQ9N+Umfi4Ba5O3ooB592Cv12WSXTF8KrCMFEOaTtsz20hlzsp5Fpmnn9JpHnR3hlhu2NuaNgy1PBWCGRk4vTfOgqLMjXGZQsj8NLI3aIrLc3VRZ2souhWlefdqGvTjhjMw4oW063cA8Bsp1gMHLCRuB40pW6FCYAvMpME5ov7anybCFrD0PNYK2D0Nyx+FDnukhbO0ps9z8ugOYQdgO0DcnTFK74unIk2CnI5MBhnRSseolbQfmq2+fbGNd8wkbXiQ+POjeADLHSbU4+CFutI5nWcdPlZ4uZ8wFSlv2FL7icVI2HdMupBNRVVZv8sm13H5b3kK4bVo5eQvxR/WsmU8BIPGROIh8+PdgNYIYaZ0pyQa8qkc+D995GYLHLqtt2kd/aZNyFRvs4uNcWAEXz77ppL19T3MNSX6xK1AFfLWqz1GG320KBFIqVV/YgCUPs5B1OpY5lkqnivUdB+MnLn26ZF9g2L5mi/wQVZZ8JC/Nqo51xUidVj/4cTEZ8oPuy7B4lvFF0CwCi38jARNiQzpTfDzlUWWgyTJNnE0TM4DkUz7cmqs9nYCYhzf7iVVNy2GDMvX9pkh2GR74Nd8qItLNSx85p3HqVxg8+qW+5ATQdzziSYJTqkvGk3UBnXD+e3801nuM1Emzai/aTDmLDswyJNf49mE/d9Tdvr7kc/8P7VWdJEuQiI4AAAAASUVORK5CYII=";
var InjectedConnector = class extends BaseConnector {
  constructor(propertity) {
    var _a;
    super();
    this.propertity = propertity;
    const props = (_a = this.propertity) == null ? void 0 : _a.split(".");
    if (!this.propertity || props.length > 2) {
      throw new Error("please input valid propertity");
    }
  }
  isReady() {
    if (typeof window !== "undefined") {
      const props = this.propertity.split(".");
      if (props.length === 1) {
        return typeof window[props[0]] !== "undefined";
      } else {
        return typeof window[props[0]] !== "undefined" && typeof window[props[0]][props[1]] !== "undefined";
      }
    }
    return false;
  }
  requestAccounts() {
    return __async2(this, null, function* () {
      const accounts = yield this.getProviderOrThrow().requestAccounts();
      return accounts;
    });
  }
  getAccounts() {
    return __async2(this, null, function* () {
      const accounts = yield this.getProviderOrThrow().getAccounts();
      return accounts;
    });
  }
  getPublicKey() {
    return __async2(this, null, function* () {
      return this.getProviderOrThrow().getPublicKey();
    });
  }
  signMessage(signStr, type) {
    return __async2(this, null, function* () {
      const addresses = yield this.getAccounts();
      if (addresses.length === 0) {
        throw new Error(`${this.metadata.name} not connected!`);
      }
      return this.getProviderOrThrow().signMessage(signStr, type);
    });
  }
  on(event, handler) {
    var _a;
    const provider = this.getProvider();
    return (_a = provider == null ? void 0 : provider.on) == null ? void 0 : _a.call(provider, event, handler);
  }
  removeListener(event, handler) {
    var _a;
    const provider = this.getProvider();
    return (_a = provider == null ? void 0 : provider.removeListener) == null ? void 0 : _a.call(provider, event, handler);
  }
  getProvider() {
    if (this.isReady()) {
      const props = this.propertity.split(".");
      if (props.length === 1) {
        return window[props[0]];
      } else {
        return window[props[0]][props[1]];
      }
    }
  }
  getProviderOrThrow() {
    const provider = this.getProvider();
    if (!provider) {
      throw new Error(`${this.metadata.name} is not install or not create Bitcoin wallet!`);
    }
    return provider;
  }
  getNetwork() {
    return __async2(this, null, function* () {
      return this.getProviderOrThrow().getNetwork();
    });
  }
  switchNetwork(network) {
    return __async2(this, null, function* () {
      return this.getProviderOrThrow().switchNetwork(network);
    });
  }
  sendBitcoin(toAddress, satoshis, options) {
    return __async2(this, null, function* () {
      return this.getProviderOrThrow().sendBitcoin(toAddress, satoshis, options);
    });
  }
  sendInscription(address, inscriptionId, options) {
    return __async2(this, null, function* () {
      const result = yield this.getProviderOrThrow().sendInscription(address, inscriptionId, options);
      if (typeof result === "string") {
        return {
          txid: result
        };
      }
      return result;
    });
  }
  disconnect() {
  }
};
var BitgetConnector = class extends InjectedConnector {
  constructor() {
    super("bitkeep.unisat");
    this.metadata = {
      id: "bitget",
      name: "Bitget Wallet",
      icon: bitget_default,
      downloadUrl: "https://web3.bitget.com/en/wallet-download"
    };
  }
};
var bybit_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAGQAAAABAAAAZAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAgKADAAQAAAABAAAAgAAAAACicmImAAAACXBIWXMAAA9hAAAPYQGoP6dpAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoZXuEHAAAThUlEQVR4Ae1cC3hVxbVeSc7Jycn7ASSQ8AgByQMC8ghQK9D79Vqt1var7e3thd5Li7dSqxS9gtRW1CuKLSJFvIiSBGyr1GLh4le5WBFRQZFnBJTw0Ii8SYC834+7/tlnTs5JTk7OicNjf3tWvrMfs2fWrFnrn7Vn1sxOSO++2W2kybIaCLVsy3XDhQY0ACwOBA0ADQCLa8DizdceQAPA4hqwePO1B9AAsLgGLN587QE0ACyuAYs3X3sADQCLa8DizdceQAPA4hqwePO1B9AAsLgGLN587QE0ACyuAYs3X3sADQCLa8DizdceQAPA4hqwePO1B9AAsLgGLN587QE0ACyuAYs3X3sADQCLa8DizdceQAPA4hqwePO1B9AAsLgGLN587QE0ACyuAYs3X3sADQCLa8DizdceQAPA4hqwePO1B7A4AGwWb/9laT7+8WKMnSg8jKjN9V8YQ0KI6puJqpuIwvj6WvnnjBoAiiEAw4azXy35kq3sg9LS2qiOgRDq+7GPEpc3SQNAsX4dbPxTlUSzbm2i/kkt1NRsWDrc1kbFp22Uvz2M0pKIGloUV9xDdhoAPVRcV8ViwvlJVQj9dEoZjcq4SE2NRk67g2jzvr6UvzmJ4hytdL62Kw5XNl0DQLG+5bu9sSWUWtjVNzYb42xbWCs1tRjeQI4LFFfdI3YaAD1SW/eFQkLaxHseZxBML1/78iweXOWDngZeZQNc7eo1AK62Ba5y/UG/AuC+WvglFhsVQRERdmrl6xC3c+vcGjhAlGltbaX6hiZqaGgWZTrmlHyjnOEUGeng+bM338qqOmpsaqYQTKh9EN6rNlsoxcU63fK08Ww7lPPX1jVSdU0DhfEEvLW1jeJinGQPt3WqoyNbKXsLZK9n2Rub3PP6jnl7cg+Z4+OcZAsLY0m92xsMP1m2qqae9dvUpY588QwaADC+02Gnks/2+eLXTVoIDcoYSZFOB10sr6Hm5lYW1ijSwoaJdNrpy5KPffKwRWVQ70QnNTW1dGogDAXjwkhnTx70Wb7/oFyqrm0kJ4P2s6N7febxnxhNQ64bxiALE7IDoD0llJSAPXZ4T0/Z+CjXh1IHJDNQu+4oHQsFDQAo8OQXx+lXs+fQ0KEZPM1hxPmLanBrYeTqmho6cPAQ/eWV1UKG1AEjyBntoIrKOjZeKBs/nE588QndNfNeys0dzkhuoNDQ9jfU2rWv0/adR6lvnyhqbmn1akcY1w/jpvfvRQ8/tNToUVxva1srORwOOnLkGC39wxIaPDSXPj96in790HxK7deX5+jdKAqWYtmrKitpX9FBWve3V0S9GUNHc9kWquE6Q/213UvK9hvoA97qLM8FH33sCUpKSuTO0I0s7cU7XQGMNpuNtmx5j9ave5tSB6ZQI4MgEAoaAHExkXSSKmjqv/2Ixo0bE0gd7jxNTU206HcL6N1336dp06ZzegMNGTaGLlyqoXB2yUTNlJiYQHf/4ufuMvJi0MCBtP1736GkxImsuHIvL5CYEE3nTn1Esxc9RDNmTJdF3OclS5bxdTO722g+n6M7Z0ynwYPT3c8DuQAgTy96gt78x2b6xcz/5CL9KH1IMlVU1RMAGCxFOLi9jZ/TTOaV3Kd3sMW7zL9+3RqKiRpEFxqru8zj+aC9i3mm+rmWrg/GBLW0tIh3KdK7+9ntdkpLS6WpU/+Vjh8/Srfd/kOCC0yIi6RLFbWUM2ICLXzyv2nHjp1u3hg7gCZN+jplDZ9IX5woo3B7O24xJqivaxB5br75JnGGTPiBDh0qpvvvn0XDssZRTU2dSGtsNKIzwcgOT5KePohm3nUnffppMY0eO5RKjp1gZWO8ItgGd3CVaeqBLB31LNsKLwLCmCBQChoAkrEcjOEsf/JZx3O7wHj3tQnjDBjQn1a+sIzd1Sg6X1ZF6BG1LkPmF7wk8oTx4AivAYAgISGe5s35JVVfOkrx8VHuKgCeks+K6PeLnqHU1H6CvyyHTC+/8qrIi8GfpOBlN+SGHPhlZQ2jV9cUMLsywgDRhtWdy0BSr55n1dX0GAC+BPEU1PMaRjTe5zzSZcDAQEBtSkoyFby4SBg1IS6KKtmdDs+dQAX5y2n3HmOgBoWjDOimm77JxxSqqKhxv3tdj+i7t98m8gBgssyhQ4fpiQWPUlZOnvAwIoPPgyGXp8zy2pDdqF+2A7IPGZJBa9b8lcdD+wmvoKDJhZnwcMSOMYgNc3ckWbcvnvKZ5xllQRgHgPAsUGr3pYGW8JEPSkelxcVHaMPrf+epWCz3DB6t8x8GYtHRUZQ3bhxlZ2e6SxuAIJowPo8ycyZSyYlSiufpWU2t4c7z81fT2DFjxAARhVAHAPPssvk06967KTM7TwzEij/dRXMf/A1dd91QwRt8kRf0iqv3e842xAOPg5R9794iemvzFm/ZGXzx8XH0ta9N8BozSNknT76ROdmpqrpOANLTy3hU4fOynqfDZEunlfmrOg0CoTeAbNq0HwvPJ9sDHW/Z8i7t2btP6BRAB+E5jL/13W18l0TV1fUiPZCDUgCcPnOG5j34X13Wu/H/3qRb+D0tlY5zXFws/eD7N9OCxx+hfsljqJzHAvAC+SuX04yf/QdNmJDn7tFgfPt3bmUAEE8HmzkOYfSeH/3LD0SdUiEw0KHiw7RgwSOi95deqGaA+hZLylJSUuJX9m3bP6QbGAgyP7j16tWLpk77d3r5zwU0cPAoEW/wXYt3KvAJUKakRNFvf/Og90OPuzvu+J4AgEeSMP7cOfd5Jnlc9+JpYD8RbwnUCygBgJQgnAd5oLwJ36DKyhpxjQFJBLu5L06W0qzZD9PeXRMpJibG3UuRKTm5j8iLgAgEr+aABui5/3mBxo4dLdANxeM3cOAAenzBU/Twb+dxjmSa/tO7eNo4QuRHWdnwwsI/irRGETcQl34PjghermPqKHtUZATt3b2NFi9+lvLyxpKdexrkANl5MJqVaXgeB89iEHAKhIBFABIgwCzIzrEFF0shP2Iax06Uu16b3hzhTUFj8yZzTzcGtbgHvyru+Qi2SR0gvTtSOgaQisFou+xSNU/vqukiT/FOnb1Iyb1jecR/jOf9VZ1kCg3xFgNRu+G5E7lnFdIHH+wQ+SUAcHPH97/r4nGOpk+fygAJE15C1l/08X56etGTPKsYz/UFtu7a5hokQnbILWU/feYSxfcexu0o50BTZ9dqsxvv32CU7hJeGA1xkLKLRn2izvJq9oI1VH/pohtoMj/O0svB+FJOnMEjmACQ5KnUA0glxMZGuVEID+BgD7B393v09Unf4nl8oqzbfS4tLRXXLa4AD/hUVsFwkfSHZ5+n8TxOcDjC3QrJysqkWb96gN58630xtkBhlMEPIJC9v44jg1ImUYGfg3yve8nOvCLZA+z6aCsNTp9C0VHtsw/wbeZgUPHhzwRXhGDNSEoB0NBguMAPt7/tUxdLFj9JTmeE25BQ4iXuWSsK1lJin0y360dhuNMRI0fSeo6+fXjPXTRlyiRRDgaGseAFxo8fK/jJXgF+RUUf07JnF4uYwrnSioABUFtreApfsjsTsmju3PvcAIMMqOvs2bO0unAFpWfg/W9hAEAZoGHDhtLGjZsI79M2MUJFOkaodp47Z1IfjnhJ5eEMeoPznz3xsRiswY1JAk/DfUfxWOBFmjhxgpcXkIND5Ede/MBz1ao/CxZ19Y0iTfLr6ixlHzNmtLfsLn4RjgjKGZ5NCfHxbtllmbWvrRdsw8PtIhTdVR3XcroSDyCVjygffl2Rp/FR5qOPdtFPeKqD2DreYx0JXmB4bi797bWX6Z5f/tztBVBWzp9RRvIVvX9ZcL1fyo7QsL/wsKwDgGbI0aZN/6D777tXRBgRymaRTEneo6+v0ASpSLhjXz+pQHl+Z+t7YoqHIA0M7XIIXhKApzEWSKAlS5eLQRjcP3iA5FmmFa76k0gPtPeLzHwIRnYYf936DXTLLd+iUdffIIBrVuOj/coAAGZQJIzh6wdjSeMj71h2ufkFq+nQJzspJrp9XIBnnmSMBTLp9f99ld57f7t4JA2P+uT7f9fuPfTcsmdEDAF7B4KlYGT/xpTJhAWmon3beVAbzTIYgAy2zmshv1IA+GqQ7NkAhexpSIuJiRaBnpUrC+lI8W7qleQdG5C8UOYS7x0gSqOFC5+hqqpqATADUIxg5ouFqRUr8kWRGp5CoowK8i17mwjOzJ59Dz25cBEd5kgkQCDzqqj3SvJQMgZAL4Qhior209Jlz1PflD7UzJE69pZCMQh0DB+RQ7fd+m2KjTUMjV6DMlOn/pj++toGeuvNHdR/UDIHMowVLU8lILiRO2oAbX1noxjl33jjDS73j9F4KB048AmtKnxBxA7O8FIxdgEFSlL2bds+oAIOHvXtm+wlO6afo0ePom/fcjNHHo2dSrIMVgZXvLiGzp2voCjexYQ9AmYjJQCQjS4vLxfTIiJE1YyYvnyG89SfzOAVwOfE1A29FIrEtHDGz6YxADbwq2AQA6BzoAh5ZYxALuV68q1zBWiEYYIwvicPxCJWr3qBk3zLPu/XD4uFJenJUBdWKOfcfyfdy2sTKcnjRNBLjBGZS1sb2mecGaa8JoJlcwOY19ILQykA5GrUmHHjqZwjWtw9DRfACklOTqSX/1RAd8+8UyyuQIGShmRkyMsuz9KuvnYf9WRXTseKsFcB1C4737ClAL6kpFh6auHjNI29VU5OlnvcgfzZfA+ClwNJOR32FgpjLDlDWgUmQnnZwmE32tyD/SOC9+U4KAWAHJzV8xy8ssOKlCPCmOZVVlZ4tMPoERgPgDpu9fLI2H7pq/v4SmsvEdCVP9nDeQ8kqKysrBMvZ4RTpMmBYK3rDbZ5fzwdPx/FH4YYbYTx93wewXnbqDqwJYNOdV2OBKUAkIOvKN4xnIj3IdrOxoF94jg8DEpK6iXOxgFPQsQgDvdXs2e4ZefQb2J8u+xoAxaEQCkpKeLsecCyN0iWr+GAID4AfeClSKSKZ+2HNurPz6o4z9Vsa7s8vCLtefNVrzEaB+3csVWcOx7mzH2Irr9+pEjGu1S+BsrKLog0ubGhY7krcd/g2pq1k+P+vmjhU4tEpBPPPGW/4JJdlsHmIHz9mzGQV0HDeHOK6wGmW/AOldz7kUeB05JVfqWzEgBI9CPUO3/+Y2JwZOxT45aisTziz+RQ8D9/85/cS7uyDKTff+CgaEQzb4K40iTl6J+WRvMfYdk55OspOyw1atRImjx5khANrwqUkeU+dO1fxEwFBMOid8PQ/JFwJ8Kza8X4EE4pAHJysumxx+Z3arRnglSgGLGzF7hw8SI9+sRySkzO5Khf8AEcT949uZaGxFo/fv5Iyg6AwFuVlByn3z21gLebXy/W4v2VvVafKQ0EQUFd/WBwPINLgALhRkH5K1fRxbMH+aOPGB4LSIcpHl3RQ1dyI71ddmMXNIyPNGO7Od7/7eHpKyq0gsp67AEMY7I7cylIysIezk3S1Xm6TEyToECAoLDwJZo37wHeE5hHpbwz2N90TvLyrFdWJNPkfXdnmb872UVbXO7emN4ZG1qxMeTpxUtpGS88YW9i6QX/sncnT1fPpZwAGwh6k2ldlQk2PWgASJcpV+MgVFfkCQaZp6amVuzVX/78So7erTAU2I3xUVZG93zVK9OkbLKujmfDiPwvXHiPPyhY2St5N9MBHq/8/umlYm0CwD1XWkl2/rJJArRjnT2/N75q6iinnZfWQbIt4uYrHIIGAHbAgja8/gYdOXqMP0Hqft0dqG3gXlNaWkZvv/M+bd2yUfDIyhnP3wRU+u35IiMf5Pjg729sopMnT/H2J2MyDeNj+zdIyiZufByqxY7jOFq7dh1Px1L5Y1P/O4YAYHz8WldXR2dOn6E3Nr3Dexq3cmoMDcseR+fZ+DbFxoeusFfQFp3A3zT8Reygkh982DhYtV1skXOKj119NDHopJDefbODAi8CHuL7wOP7g67MKJBK2cPTWKlGsAifVQUiAOrFx6MneB++L0obmEvYAub3NcLKxebNU18e8MWi27RQZzpl8edgAFoNyy+9UrcFe5AB7Th36hMfJWP5YxqEzLmtCtxA0ABAr8CXvPjEGp+HG+8kX87eW3bsDUQ8H8u7gX646MkBbW1p4c/SeenYyR+Synch3D6+Cq7gGUQgYEK5eP6aCJ+X8WVABNmx/6+WPwa9kgs++OoJG16lnNBBJYMPQA/jmwDF99vGoAHgl5t+aDoNKJ0Gmq71WmC1O4K0Ps2nAe0BzGczpRJrAChVp/mYaQCYz2ZKJdYAUKpO8zHTADCfzZRKrAGgVJ3mY6YBYD6bKZVYA0CpOs3HTAPAfDZTKrEGgFJ1mo+ZBoD5bKZUYg0Apeo0HzMNAPPZTKnEGgBK1Wk+ZhoA5rOZUok1AJSq03zMNADMZzOlEmsAKFWn+ZhpAJjPZkol1gBQqk7zMdMAMJ/NlEqsAaBUneZjpgFgPpsplVgDQKk6zcdMA8B8NlMqsQaAUnWaj5kGgPlsplRiDQCl6jQfMw0A89lMqcQaAErVaT5mGgDms5lSiTUAlKrTfMw0AMxnM6USawAoVaf5mGkAmM9mSiXWAFCqTvMx0wAwn82USqwBoFSd5mOmAWA+mymVWANAqTrNx0wDwHw2UyqxBoBSdZqPmQaA+WymVGINAKXqNB8zDQDz2UypxP8PgU8imnq8OqUAAAAASUVORK5CYII=";
var BybitConnector = class extends InjectedConnector {
  constructor() {
    super("bybitWallet.bitcoin");
    this.metadata = {
      id: "bybit",
      name: "Bybit Wallet",
      icon: bybit_default,
      downloadUrl: "https://www.bybit.com/download/"
    };
  }
};
var okx_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiB2aWV3Qm94PSIwIDAgMTAwMCAxMDAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTM5My45NDkgMjE4LjUxOEgyMzEuMDQ5QzIyNC4xMjkgMjE4LjUxOCAyMTguNTE5IDIyNC4xMjggMjE4LjUxOSAyMzEuMDQ4VjM5My45NDhDMjE4LjUxOSA0MDAuODY5IDIyNC4xMjkgNDA2LjQ3OSAyMzEuMDQ5IDQwNi40NzlIMzkzLjk0OUM0MDAuODcgNDA2LjQ3OSA0MDYuNDggNDAwLjg2OSA0MDYuNDggMzkzLjk0OFYyMzEuMDQ4QzQwNi40OCAyMjQuMTI4IDQwMC44NyAyMTguNTE4IDM5My45NDkgMjE4LjUxOFpNNTgxLjk5MiA0MDYuNDc5SDQxOS4wOTJDNDEyLjE3MiA0MDYuNDc5IDQwNi41NjEgNDEyLjA5IDQwNi41NjEgNDE5LjAxVjU4MS45MUM0MDYuNTYxIDU4OC44MzEgNDEyLjE3MiA1OTQuNDQxIDQxOS4wOTIgNTk0LjQ0MUg1ODEuOTkyQzU4OC45MTMgNTk0LjQ0MSA1OTQuNTIzIDU4OC44MzEgNTk0LjUyMyA1ODEuOTFWNDE5LjAxQzU5NC41MjMgNDEyLjA5IDU4OC45MTMgNDA2LjQ3OSA1ODEuOTkyIDQwNi40NzlaTTYwNi45NzQgMjE4LjUxOEg3NjkuODc0Qzc3Ni43OTQgMjE4LjUxOCA3ODIuNDA1IDIyNC4xMjggNzgyLjQwNSAyMzEuMDQ4VjM5My45NDhDNzgyLjQwNSA0MDAuODY5IDc3Ni43OTQgNDA2LjQ3OSA3NjkuODc0IDQwNi40NzlINjA2Ljk3NEM2MDAuMDUzIDQwNi40NzkgNTk0LjQ0MyA0MDAuODY5IDU5NC40NDMgMzkzLjk0OFYyMzEuMDQ4QzU5NC40NDMgMjI0LjEyOCA2MDAuMDUzIDIxOC41MTggNjA2Ljk3NCAyMTguNTE4Wk0zOTMuOTUgNTk0LjQ0MkgyMzEuMDQ5QzIyNC4xMjkgNTk0LjQ0MiAyMTguNTE5IDYwMC4wNTIgMjE4LjUxOSA2MDYuOTczVjc2OS44NzNDMjE4LjUxOSA3NzYuNzkzIDIyNC4xMjkgNzgyLjQwNCAyMzEuMDQ5IDc4Mi40MDRIMzkzLjk1QzQwMC44NyA3ODIuNDA0IDQwNi40OCA3NzYuNzkzIDQwNi40OCA3NjkuODczVjYwNi45NzNDNDA2LjQ4IDYwMC4wNTIgNDAwLjg3IDU5NC40NDIgMzkzLjk1IDU5NC40NDJaTTYwNi45NzQgNTk0LjQ0Mkg3NjkuODc0Qzc3Ni43OTQgNTk0LjQ0MiA3ODIuNDA1IDYwMC4wNTIgNzgyLjQwNSA2MDYuOTczVjc2OS44NzNDNzgyLjQwNSA3NzYuNzkzIDc3Ni43OTQgNzgyLjQwNCA3NjkuODc0IDc4Mi40MDRINjA2Ljk3NEM2MDAuMDUzIDc4Mi40MDQgNTk0LjQ0MyA3NzYuNzkzIDU5NC40NDMgNzY5Ljg3M1Y2MDYuOTczQzU5NC40NDMgNjAwLjA1MiA2MDAuMDUzIDU5NC40NDIgNjA2Ljk3NCA1OTQuNDQyWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==";
var OKXConnector = class extends InjectedConnector {
  constructor() {
    super("okxwallet.bitcoin");
    this.metadata = {
      id: "okx",
      name: "OKX Wallet",
      icon: okx_default,
      downloadUrl: "https://www.okx.com/download"
    };
  }
};
var tokenpocket_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAIAAAAiOjnJAAAKd0lEQVR4nOzdC3BU5cHG8efdBHIlG0IwJPJBwtWIEL8wCgqjZBwro9V6rdfaqtVp1dZO7UytbWeY6rTacaZOO9S2UqfaokVrpe3EemuNFJgYvKBkIiZIjBoTQiSwuV92TydGISQb9mz2POecpc9vGIdZNmdf3D/vuew5Z1NL10Ug4rSA1wOQ45PCEgqFJRQKSygUllAoLKFQWEKhsIRCYQmFwhIKhSUUCksoFJZQKCyhUFhCobCEQmEJhcISCoUlFApLKBSWUCgsoVBYQqGwhEJhCYXCEgqFJRQKSygUllAoLKFQWEKhsIRCYQmFwhIKhSUUCksoFJZQKCyhUFhCobCEQmEJhcISCoUlFApLKBSWUCgsoVBYQqGwhEJhCYXCEgqFJRQKSygUllAoLKFQWEKhsIQilf0C82eaW89CaSGmpLBfapLCERzqxUcdqHkf1Y1oOmC59tLTM7GkyMzNw5w8zMxGXhaC6chOH/6jiIX+QYT60NGDlkNoPoj6NjTss9q7XRtdQkzpughv6eeeZO67BBlTea/gvF3N+PkLeP0DVl7BDKyaZ85ehPI5KAwiYOL78dZDeLsZrzbixd1o73Lv30C8iGFNS8OW75k0+pxI8ch2PPgva8jR/zf5Web2Clz6/0h1YgNkMIwtDVhfhd37/JgX8W1fUZKsVQG48UwUBc1dm62BIQeWdtpcc8VyrFn42WrOEVNScM5JWLMIVfXmqTewbY8V9lNgxHd+5jTest2wdgkWzDQ3b8S+0OTfsfNPMbesxqICR0c2SkpgOK9zTkJju3ngRbxc75e4tFd4LAtOwJ3nTPJnUwK450LzwGXEqkYrycf6q/Hrq830zDi32jgUVgznL0XprLjfqrMXmn/cai4r54xpYmsW4elbcHGZSfG6LoUVQ8Dgm2fF8fzUAO46zzx0DYpnEEd1DLOC+OnFePgrHk9dCiu2isXIzbT1zGCGefwmc/1K+pBiWlmCDdch07sDPQortpQALi2L/a8/J9385hqcUuTKmGwoLUTlbaZstjfzlsKy5YvLYjyhKGg23oiy2S6Nx6aCHDx8LTxpS2HZUpJ/rD/NzzJ//jrmz3RvPPZlp2P9VShw/dCPwrIlLRUTHeydkoIHv4z8bLeHZF9eFh6/yczOdXXeUlh2TfSh3k2rTPkctwcTr8Ig7v2Sq6+osGzpHUDvYJTHV5SYm1d5MJ5JOL0Yl5e7N2kpLFt2fhTlwaVF5nfXJtO5G3evxWlzXWpLYdmydU+UB+88178nmUWVPgW/ugrT0tx4LYUV28AQNr819sPdy8vN6cUeDSgBOem4ebUbk5bCiq2yFh09Rz1ySpH58fmejSdB16+EC3uICiu2jTVjH7n6tCRbCY42NRU3nEF/FYUVQ+Uu1LUctR6cnmnWnuzdgJxwwVLk2fv0c9KIYUX8cs7Z5L1Sj3WVY/8a152eTHuCUeVk4PvncdeGxLBCvbxlu2H7e7h9k9XdP/bxC5Z6Mx5nXbgMs3KIyyeGtaPJ6h3gLZ5oYAiPVeOOp6zwuIspVs03c/K8GZXjvnAycdIihtXehftf4C2epb0LX3sU9z0fZa4a2aU6bqxZSFw49zKaJ1+3whHz7YokuLCiNYSaRmzbi6p6q7Mv+nPys83KErcHxnPq/yGYgUOcLRb69VlPv2n99c3hsOK9mO6By82pjp7e9N2n8HZzlB2KsIWOHti5zGv1/CQ+yjBe+hRcXGYerabsZLlx4Z8FtHXG/VOOXNA32ifd+PhQQktY5rPz+BJ3bikeraYsOWmvKPXCkkLiwsMRvPgOnq3Fe/utUB+y0zB3hjlzHq4oJx7dKJuNrKnoJuxjKSy7UgNYeAJr4f+sxc+et9q7jjzySTeaDlhbGvDb/+C2NebK5Ugh7GilBLC4wLzxofNrQx15t2tWcHijhOEvb+DOp4+qarSOHtz7rPXQFspLAyAdPVFYdhXmUI76bN2Dn4w7uD/ew1utuhbG6+PEXMpiFZZdBYTj1BEL978AO/e0GQzj/uedHwDvFhsKy65ghvPLfHff8Ka6zSfvaLKaDzo/hlzC30thxSGLsGu288P4nv9srfNjIF0trbDsYhwabY3zuFrdx86PYSrnwIDC8lK8t0oLJM/blTwjPR7Fe8fDuYRDA4Nh55epsDw2Lc47R65a4PwYol4vmTiF5aVgBtJtT1rFM8xywiXXpLMbFJaXAgZLbN/26O61lDG0x39+gB0Ky0sGmJdv6yPI8042qwnrwZET0RgUlpesT+OqWIQVxWaim46kBnDlcnPPRawxNH5CWazObvCeMahYjIrF5u1mvPkBWkIjvaEwaFaU4IYzsIB2VgWAes73Dygs7428sXlZuORU3LIaWWkmYmF6JrL5N1loaMPBJD01WWIaWQcenjempmJGtkvbKC+9w1qytrH8wv37hIYj2PQ666piheUX7l83XtcymWsRbFJY3vPqVgRV9cSFKywvmQl+745/v0tcuMLy0shcNWbj3R017+Nd5hcdKqz/Rb0DuHszt2SF5TPGjXXic3WJXrsbk8Lykhm/aWXR14nhCJ7YQX4NheUt6/NfR/Dnq8pdqP2YvkWnsLxnRv2XrX8Iv3zZjf0EheUx8/mMdeTdpr3v4Qh+9Df61tUIheWxKBXR5q4N21BZ69JhDYXlvaNWhbT3fe9+rK9y72CZwvLe2FUhQVc/fvh3W9fyO0WnzRz/mjvwjSfiuJbfEZqxvGRGHcoibVkNhvGtTW5XpbC8Z437jYP6h/CDZ7Cb+ZngRLQq9NLoN9zxGetgD776B6thv9PLtUczlpfMqM9wrCMPOeCDA7jhMXhVlWYsj1mET537BvHHV7Fhq9UZ7QsQXKOwvBTlTKzENodaQ/jOk9FvZ+8yheUlBw+7h/qwYSv+VGP1cW7yES+F5TPxzzV72rD5LTyz0xrzNbDeUlh+MYmpKtSH9VXYWGP58KshFZZf2GwjYg3v8VXvxXN1eK3Jj0mNUFheamzHrmYUTMOJuQhbn90ra/TU1TuA/V1o68SHHWhoQ/0+1LVYpIvinaWwvNTZj92tw78OT1gpAWRMgfk0rp4BjP8mzmShsPwlHEGXp8efnKIj70KhsIRCYQmFwhIKhSUUCksoFJZQKCyhUFhCobCEQmEJhcISCoUlFP4Ny/FvbA/1JfTj7d2OjeSwA4Rl+oR/w9q808mlhfrQ0JbQ2Zav1Dt8smb/ELbv9esJoAnzb1g7mqxnnGvrFy8hwbN4W0P4/TbHxtPVhzs2oTOxSdTPTOk6/56kmGJw3QqzdglOzMVEX+d3bH1DeK0Jj1WjrsWZueGMeeaiZSieMcnxjJy0/k4LHtmOjw4et9OV38OS5OXfVaEkNYUlFApLKBSWUCgsoVBYQqGwhEJhCYXCEgqFJRQKSygUllAoLKFQWEKhsIRCYQmFwhIKhSUUCksoFJZQKCyhUFhCobCEQmEJhcISCoUlFApLKBSWUCgsoVBYQqGwhEJhCYXCEgqFJRQKSygUllAoLKFQWEKhsIRCYQmFwhIKhSUUCksoFJZQKCyhUFhCobCEQmEJhcISCoUlFApLKP4bAAD//508bJGPN3IhAAAAAElFTkSuQmCC";
var TokenPocketConnector = class extends InjectedConnector {
  constructor() {
    super("tokenpocket.bitcoin");
    this.metadata = {
      id: "tokenpocket",
      name: "TokenPocket",
      icon: tokenpocket_default,
      downloadUrl: "https://www.tokenpocket.pro/en/download/app"
    };
  }
};
var unisat_default = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iX2ZyYW1lXzIiIGRhdGEtbmFtZT0iZnJhbWUgMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmlld0JveD0iLTEyIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogdXJsKCNfbGxfMTI2KTsKICAgICAgfQoKICAgICAgLmNscy0yIHsKICAgICAgICBmaWxsOiB1cmwoI19sbF8xMjMpOwogICAgICB9CgogICAgICAuY2xzLTMgewogICAgICAgIGZpbGw6IHVybCgjX2xsXzEyMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtNCB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgICBmb250LWZhbWlseTogSmV0QnJhaW5zTW9ub1JvbWFuLU1lZGl1bSwgJ0pldEJyYWlucyBNb25vJzsKICAgICAgICBmb250LXNpemU6IDI0Ljc5cHg7CiAgICAgICAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6ICd3Z2h0JyA1MDA7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9Il9sbF8xMjYiICB4MT0iOTYxLjY4IiB5MT0iLTQ1LjU3IiB4Mj0iOTg2LjE0IiB5Mj0iLTExMC4wNiIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSg3ODAuOTkgNjcxLjcpIHJvdGF0ZSgtMTM0LjczKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMwNzAxMDAiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIuMzYiIHN0b3AtY29sb3I9IiM3NzM5MGQiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIuNjciIHN0b3AtY29sb3I9IiNlYTgxMDEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZjRiODUyIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJfbGxfMTIxIiAgeDE9Ijk2NS4xNyIgeTE9Ii0xMzIuNDEiIHgyPSI5MjkuMjIiIHkyPSItNjUuMjIiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzgwLjk5IDY3MS43KSByb3RhdGUoLTEzNC43MykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMDcwMTAwIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iLjM3IiBzdG9wLWNvbG9yPSIjNzczOTBkIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iLjY3IiBzdG9wLWNvbG9yPSIjZWE4MTAxIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2Y0ZmI1MiIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0iX2xsXzEyMyIgIGN4PSIzNS41OSIgY3k9IjMwLjc2IiBmeD0iMzUuNTkiIGZ5PSIzMC43NiIgcj0iNy40NyIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2Y0Yjg1MiIvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii4zMyIgc3RvcC1jb2xvcj0iI2VhODEwMSIvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii42NCIgc3RvcC1jb2xvcj0iIzc3MzkwZCIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwNzAxMDAiLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxnIGlkPSJfZnJhbWVfMS0yIiA+CiAgICA8Zz4KICAgICAgPGc+CiAgICAgICAgPHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTQuODEsOC45MWwyMC4zNCwyMC4xNGMxLjczLDEuNzEsMi41OCwzLjQ0LDIuNTUsNS4xOS0uMDMsMS43NC0uNzcsMy4zNC0yLjIzLDQuNzgtMS41MiwxLjUxLTMuMTYsMi4yOC00LjkyLDIuMzEtMS43NiwuMDMtMy41LS44Mi01LjI0LTIuNTNsLTIwLjgtMjAuNmMtMi4zNi0yLjM0LTQuNjQtNC02Ljg0LTQuOTctMi4xOS0uOTctNC41LTEuMTItNi45Mi0uNDYtMi40MiwuNjYtNS4wMiwyLjM3LTcuOCw1LjEzLTMuODQsMy44LTUuNjcsNy4zNy01LjQ4LDEwLjcxLC4xOSwzLjM0LDIuMDksNi43OSw1LjcxLDEwLjM4bDIwLjk3LDIwLjc3YzEuNzUsMS43MywyLjYxLDMuNDYsMi41OCw1LjE4LS4wMywxLjcyLS43OCwzLjMyLTIuMjYsNC43OC0xLjQ4LDEuNDYtMy4xLDIuMjMtNC44OCwyLjI5LTEuNzcsLjA2LTMuNTMtLjc4LTUuMjgtMi41MUwxMy45OSw0OS4zNmMtMy4zMS0zLjI4LTUuNy02LjM4LTcuMTctOS4zLTEuNDctMi45Mi0yLjAyLTYuMjMtMS42NC05LjkyLC4zNC0zLjE2LDEuMzYtNi4yMiwzLjA0LTkuMTksMS42OS0yLjk3LDQuMS02LDcuMjMtOS4xMSwzLjczLTMuNyw3LjI5LTYuNTMsMTAuNjktOC41QzI5LjU0LDEuMzcsMzIuODIsLjI3LDM1Ljk5LC4wNGMzLjE3LS4yMyw2LjMsLjQsOS40LDEuODksMy4wOSwxLjQ5LDYuMjMsMy44MSw5LjQzLDYuOThaIi8+CiAgICAgICAgPHBhdGggY2xhc3M9ImNscy0zIiBkPSJNMjIuOTIsOTAuMTlMMi41OCw3MC4wNUMuODUsNjguMzQsMCw2Ni42MSwuMDMsNjQuODZzLjc3LTMuMzQsMi4yMy00Ljc4YzEuNTItMS41MSwzLjE2LTIuMjgsNC45Mi0yLjMxLDEuNzYtLjAzLDMuNSwuODEsNS4yNCwyLjUzbDIwLjgsMjAuNmMyLjM3LDIuMzQsNC42NCw0LDYuODQsNC45N3M0LjUsMS4xMiw2LjkyLC40NmMyLjQyLS42Niw1LjAyLTIuMzcsNy44LTUuMTMsMy44NC0zLjgsNS42Ny03LjM3LDUuNDgtMTAuNzEtLjE5LTMuMzQtMi4wOS02LjgtNS43MS0xMC4zOGwtMTEuMTctMTAuOTdjLTEuNzUtMS43My0yLjYxLTMuNDYtMi41OC01LjE4LC4wMy0xLjcyLC43OC0zLjMyLDIuMjYtNC43OCwxLjQ4LTEuNDYsMy4xLTIuMjMsNC44OC0yLjI5LDEuNzctLjA2LDMuNTMsLjc4LDUuMjgsMi41MWwxMC41MywxMC4zNGMzLjMxLDMuMjgsNS43LDYuMzgsNy4xNyw5LjMsMS40NywyLjkyLDIuMDIsNi4yMywxLjY0LDkuOTItLjM0LDMuMTYtMS4zNiw2LjIyLTMuMDQsOS4xOS0xLjY5LDIuOTctNC4xLDYtNy4yMyw5LjExLTMuNzMsMy43LTcuMjksNi41My0xMC42OSw4LjUtMy40LDEuOTctNi42OCwzLjA3LTkuODUsMy4zLTMuMTcsLjIzLTYuMy0uNC05LjQtMS44OS0zLjA5LTEuNDktNi4yNC0zLjgxLTkuNDMtNi45OFoiLz4KICAgICAgICA8Y2lyY2xlIGNsYXNzPSJjbHMtMiIgY3g9IjM1LjYiIGN5PSIzMC43NSIgcj0iNy40NyIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=";
var UnisatConnector = class extends InjectedConnector {
  constructor() {
    super("unisat");
    this.metadata = {
      id: "unisat",
      name: "Unisat Wallet",
      icon: unisat_default,
      downloadUrl: "https://unisat.io"
    };
  }
};
var wizz_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MCA0MCI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZEODE1IiBkPSJtMjkuNjExIDE1LjU4NC0yLjU5Ny0yLjU5OC0yLjU5OCAyLjU5OCAyLjU5OCAyLjU5NyAyLjU5NyAyLjU5NyAyLjU5Ny0yLjU5N3oiLz48cGF0aCBmaWxsPSIjRkY5ODEzIiBkPSJtMjkuNjExIDAtMi41OTggMi41OTcgMi41OTggMi41OTggMi41OTctMi41OTh6TTQwIDEwLjM4OWwtMi41OTctMi41OTctMi41OTggMi41OTcgMi41OTggMi41OTh6TTI0LjQxNiAzMS4xNjhsMi41OTggMi41OTcgMi41OTctMi41OTctMi41OTctMi41OTh6TTYuMjM1IDEyLjk4NmwyLjU5OCAyLjU5OCAyLjU5Ny0yLjU5OC0yLjU5Ny0yLjU5N3pNMTkuMjIyIDBsLTIuNTk4IDIuNTk3IDIuNTk4IDIuNTk4IDIuNTk3LTIuNTk4ek04LjgzMyA1LjE5NWwyLjU5NyAyLjU5NyAyLjU5Ny0yLjU5Ny0yLjU5Ny0yLjU5OHpNMzcuNDAzIDE4LjE4MWwtMi41OTggMi41OTcgMi41OTggMi41OThMNDAgMjAuNzc4ek0zMi4yMDggMjguNTdsMi41OTcgMi41OTggMi41OTgtMi41OTgtMi41OTgtMi41OTd6Ii8+PHBhdGggZmlsbD0iIzVCNUI3MiIgZD0ibTI5LjYxMSAyMC43NzgtMi41OTctMi41OTctMi41OTggMi41OTctMi41OTctMi41OTctMi41OTctMi41OTcgMi41OTctMi41OTgtMi41OTctMi41OTctMi41OTgtMi41OTctMi41OTcgMi41OTcgMi41OTcgMi41OTctMi41OTcgMi41OTggMi41OTcgMi41OTctMi41OTcgMi41OTctMS4yOTktMS4yOTgtMi41OTcgMi41OTcgMi41OTcgMi41OTctMi41OTcgMi41OTgtMi40NjggMi40NjgtMi40NjggMi40NjgtMi41OTggMi41OThMMCAzNy40MDMgMi41OTcgNDBsMi41OTgtMi41OTcgMi41OTctMi41OTcgMi40NjgtMi40NjkuMTI5LS4xMjkgMi4zMzktMi4zMzkuMTI5LS4xMjkgMi40NjktMi40NjggMi41OTcgMi41OTcgMi41OTctMi41OTctMS4yOTgtMS4yOTkgMi41OTctMi41OTcgMi41OTcgMi41OTcgMi41OTgtMi41OTcgMi41OTcgMi41OTcgMi41OTctMi41OTd6Ii8+PHBhdGggZmlsbD0iI0ZGOTgxMyIgZD0ibTI5LjYxMSAxMC4zODktMi41OTctMi41OTctMi41OTggMi41OTctMi41OTctMi41OTctMi41OTcgMi41OTcgMi41OTcgMi41OTgtMi41OTcgMi41OTcgMi41OTcgMi41OTcgMi41OTcgMi41OTcgMi41OTgtMi41OTctMi41OTgtMi41OTcgMi41OTgtMi41OTcgMi41OTcgMi41OTcgMi41OTctMi41OTd6Ii8+PC9nPjwvc3ZnPgo=";
var WizzConnector = class extends InjectedConnector {
  constructor() {
    super("wizz");
    this.metadata = {
      id: "wizz",
      name: "Wizz Wallet",
      icon: wizz_default,
      downloadUrl: "https://wizzwallet.io"
    };
  }
};
var xverse_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAALhUlEQVR4nO2dT2wc1R3Hv7+dFk/kN8u2tdBsLJThUCm0SNhCKn8utcWFG644wCk4p4I4JBZIKb2YnEokIpJbgaomioTKIWJzA6lVHFUy9JRNRapU5TA0sj3igMbOa7uO2H095D2zXu+/2Z0/783OR7IcrzzzXvz9zJs3b968IeQQ13W9Uqk0J4TwABwTQlQAePILbd878YkoFEKERBQC8AF8LYSoW5YVbm5u1lP8b6QCZV2BcXFd1wOwQESPA1gA4MnAY0fKUSeiOhFdb7Va9SAI/CTKSgvjBPA8r9JoNOaI6HkhxFKfozkViKguhKgDuBQEwXqWdRkFYwRwXXcBwMtEtJTUET4usoWolUqlq1tbW7Ws6zMMWgswOzs712w2nyei07qG3gcfwDqAszqfJrQUQB7tq/KcngeUCNqdIrQSIIfBd+JLET7MuiIKLQSYgOA70UaETAWQl3BrExT8AYioJoRYybKPYGVRqOd5Fdu2zwCoZX0ZlzHHAZxmjGFmZuZmGIaNtCuQegsgm/u1CQ++Gz6Ak2l3FFNrATzPqxw5cuR3AH4PwLRLujSoAFh2HKfCOf8srUJTaQHkuf5acdQPjQ9gMY2+QSnpAlzXfZmIbhThR8IjohvVavV00gUlegqoVqvvAngbgJ1kOTnFBvAcYwyc8+tJFZLIKcDzvMre3t6avFlTMCZEVJuamjrp+34Y+77j3qHruh4RfSKEmIt73xNOIv2CWAUoOnuJE7sEsQlQhJ8asUoQiwBF+KkTmwRjC1CEnxmxSDDWOIDneZUi/MzwiOgTmcHIjCXA3t5eMaafIUKIOZnByIw8EOS67iqAV8YpvCAWjo9z/2AkAarV6ik5wlegB08xxnzO+c2oG0buBMqBnhsGTtLMNXJG8nzUTuEofYBrRfj6ITO5FrVTGEkAeXOn6PTpi7e3t7caZYOhTwFyJs+1karVxpUrV/DMM89E3m53dxfvv/8+zp8/P24VEuW1eYYTP5+G80D/P+3dewJ377UOfPbnf+/h7S9246jG4rAzi4YSQD6OFcs9/e3t7bG2f+edd7SV4LV5htfm2Vj7+Nkfgziq4tu2PT/M3cOhTgGNRuOULk3/G2+8gddffz3rahwijvBjxGs0GkNNJhkogBzqfSuOWsWFbhJoFr5iVWbXl4ECENG7sVUpRnSRQNPwFQNHCfsK4Lruss6zerKWQPPwAWBBdt57MqgFiHRJkQVZSWBA+Iq+GfYUwHXdZV06foNIWwKDwsegVqBfC6D90d9OWhIYFr6iZ5ZdBZDGGHH0t5O0BIaGj36tQK8WwKijv52kJDA4fEXXTA8JoFbdSqVKCRG3BDkIHwAWZmdnD03V79YCGHv0txOXBDkJHwDQbDYPXdJ3EyDRo393N5abHUMxrgR5Ch/3B/VOdX52YEbQ0aNHl4QQiU7zsm17pLuBo6LK+vzzzyNtl0X4d+8J/OHv/0myCJsxdp1zvj9p5IAA09PTZwAk+kjXxsYGiEhrCZZ+egRvPllOuFaHObuxi9vffpd4OZzzq+rfBwRwHOfDNJ7k1V2CZ4/Z+EX1gRRq9T2//esOav/6X+LlEJE3MzPznlqOZn8+QFwTPqKQxTDusPMJogpw5skyHv3xD0aqU1rht7E/YWS/BWCMrSbd/Heic0uwyZuRvu41BZ49Fr3xzCB8ENEO5/xTtAvgOM5bANxUa6K5BFE4/pMfRhYgi/AlLuf8IpQAcvAns3n+eZAgqgAZhg8AFcbYJc55aAFAuVxeEEK8lFVtkAMJogiQcfiKm5zzuoX75/9XADyVdY1MlmBYATQJH0T0Nef8UyXAGV3u/pkqwTAC6BI+7gtgc87fs3C/A3hBp5W8TJRgkAA6hY/vBThnzc7OzrVarcTXo4uKaRL0E0C38CU2Y+ySNT09fRzActa16YZJEvQSQNPwAQClUum65TjOEoDnsq5ML0yRoJsAOocv+ZvlOM5LOlwB9MMECToFMCB8ENE/Lcdxfi3Xrdca3SVoF8CE8CW3LTkGoMUl4CB0luD2t99hizdx+R//xV++3kupdmMTWo7jnM7iHsCo6C7BJm+mVKt4sBhjvzHtBQ46S2AYocUYu5B1LUahkCAWKhZjTKtHv6OwsbGBBx98EE888URqZeZNAqMFAIBvvvkGJ06cSLXMPElgtADlchlra2t46KGHUi87LxIYK0C5XMaVK1fw2GOPZVaHPEhgpAA6hK8wXQKLMbZs0mWgTuErDJbAtxhjp00RQMfwFSZKQES+xRhbMmEoWOfwFQZKcNtijC2m/TxAVEwIX2GSBER003IcZ0Hn28Emha8wRQIi+sxyHOe4rhNCTAxfYYIERPSxVS6X3ayfCeiGyeErDJDgnDU9Pd0AoNWk0DyEr9BZAsuyLlqc81DOCdBiWniewlfoKAERhVtbWyvquYCXdJgUksfwFRpK8AXn/JIS4NGsrwTyHL5CJwmI6Gr7o2EugMwWhc4q/C+//BJfffUVHn744dTK1EWCUql07u7du7eVAGFWHcEsw3/hhRdw+fLliZxZJIR4c//xcM55mMVNoazDV0vWTdr0MiKqB0FwDh0rhDySZj9Al/AVEybBp2qlsPY1ghppPSOoW/iKCZJgRa0VuC/AzMxM2Gw2X0l6PEDX8BV5l4CIwiAIXlU/7wsQhmGDMfZo0ncGP/roo1Rn8SJC+IqsJLhz5w5u3bqVdFF/al8osnOt4A+TLj3NPypGCF+RxfsJ0/jblEqlqwd+bv8hCIJ1Ihr4skFTGDV8hc4vqRwRf2trq9b+waHVwoUQF1OtUkKMG74iZxIcep3sIQEsy6p1fmYacYWvyJEEZzs/OCTA5uZmvZspphB3+IocSLAeBIHf+WGvdwYdMsUUVlZWEnspheESdM20qwByJWkjW4GdnZ1E92+oBH6v18n3e2+gsa1A0hgoQc8sewpgciuQBgZJ4AdB0HN8Z9C7g4tWoA+GSNA3w74CFK3AYHSWgIhq/Y5+DNECAMDJ+KqUT3SVQAixMuh3Bgogrx2LU8EANJTgbLfr/k6GaQFg2/YFAAN3NuloJIEvMxsIDfE7QIxvFXvxxRfx9NNPj7ubrty6dQsffPBBIvuOwqj/x/Pnz+POnTtxVGGx13V/J0MLAADVavWCEOLQ60cL9IGILm5vbw89wTeSAJ7nVRqNxg0T1hOYUPwgCB6JssFQfYD9vft+CGAxT3MG8oLMZDHqdpEEgLwqGObyoiB1hur1d2IN8TuH4JzXHcf5UdaPkxXsczYIgpHe+xipD9BJtVr9RAiR2SNlBfdH+7a3t3816vaRTwHtTE1NnSSi+jj7KBgLf2pqaqyR2rFaAHz/2tlrxZVB6vjyen+sAbqxBUAhQRbEEj7iEgCFBGkSW/iIUwAUEqRBrOFj3E5gJ7Jii8WNo/iRne1Yw0fcAkBKYNv2PBEZ/3yBLhBRbWpqKvbwMepA0CDCMGxwzj9mjBGAhSTKmBTkzZ2TYRg2kth/IgIoOOfrjuPsENFTuixDZwpybP/VUUf4hi4nyZ0ris5hZGLv7PUi9j5AN4Ig8IMgeISIcvHgaZIQ0UXbtufTCB9ptQDtyJlFa0VrcAgfwMlhZ/LERSotQDtBEKzbtj1fTDQ9wFl51Kc+BT/1FqAd13U9Inp3gu8orsujPrNxk0wFULiuuwxgdYJOC+vyHn7mD91oIYBiAkTQJniFVgIoZEdxNUeDSNoFr9BSAIUcP3gLwC9NaxWIKBRCXLQsqyZXXdESrQVo5+jRo0utVmuJiJ4XQmj5nkMZeg3AJR2P9m4YI0A78hSxTESPCyGyfuWdT0RXhRA127brcuq8MRgpQDuu63qlUmlOCLEghHiciOaSaiHk+LwP4LoQot5r4SWTMF6AbszOzs41m80KEc3JvsMxIUSFiCpSjl79Cb/tu09EO/K732q16qaH3Y3/A6eWgM0UqgCVAAAAAElFTkSuQmCC";
var _network;
var _event;
var XverseConnector = class extends BaseConnector {
  constructor() {
    super();
    __privateAdd2(this, _network, "Mainnet");
    __privateAdd2(this, _event, new import_events3.default());
    this.metadata = {
      id: "xverse",
      name: "Xverse Wallet",
      icon: xverse_default,
      downloadUrl: "https://www.xverse.app"
    };
    this.loadAccounts = (network) => __async2(this, null, function* () {
      const { getAddress: getAddress2, AddressPurpose } = yield import("./dist-IJ6YAD2H.js");
      const addresses = yield new Promise((resolve, reject) => {
        const getAddressOptions = {
          payload: {
            purposes: [AddressPurpose.Payment, AddressPurpose.Ordinals],
            message: "Address for receiving Ordinals and payments",
            network: {
              type: network
            }
          },
          onFinish: (response) => {
            resolve(response.addresses);
          },
          onCancel: () => reject({
            code: 4001,
            message: "User rejected the request."
          })
        };
        getAddress2(getAddressOptions).catch((error) => reject(error));
      });
      localStorage.setItem("btc-connect-xverse-addresses-" + network, JSON.stringify(addresses));
      return addresses;
    });
    __privateGet2(this, _event).setMaxListeners(100);
  }
  isReady() {
    return typeof window !== "undefined" && typeof window.BitcoinProvider !== "undefined";
  }
  sendInscription() {
    return __async2(this, null, function* () {
      throw new Error("Unsupported");
    });
  }
  requestAccounts() {
    return __async2(this, null, function* () {
      if (!this.isReady()) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      const addresses = yield this.loadAccounts(__privateGet2(this, _network));
      return addresses.map((item) => item.address);
    });
  }
  getAccounts() {
    return __async2(this, null, function* () {
      if (!this.isReady()) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      const data = localStorage.getItem("btc-connect-xverse-addresses-" + __privateGet2(this, _network));
      if (data) {
        const addresses = JSON.parse(data);
        return addresses.map((item) => item.address);
      } else {
        return [];
      }
    });
  }
  getPublicKey() {
    return __async2(this, null, function* () {
      if (!this.isReady()) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      const data = localStorage.getItem("btc-connect-xverse-addresses-" + __privateGet2(this, _network));
      if (data) {
        const addresses = JSON.parse(data);
        return addresses[0].publicKey;
      } else {
        return "";
      }
    });
  }
  signMessage(signStr) {
    return __async2(this, null, function* () {
      if (!this.isReady()) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      const addresses = yield this.getAccounts();
      if (addresses.length === 0) {
        throw new Error(`${this.metadata.name} not connected!`);
      }
      const { signMessage: signMessage2 } = yield import("./dist-IJ6YAD2H.js");
      const sig = yield new Promise((resolve, reject) => {
        const signMessageOptions = {
          payload: {
            network: {
              type: __privateGet2(this, _network)
            },
            address: addresses[0],
            message: signStr
          },
          onFinish: (response) => {
            resolve(response);
          },
          onCancel: () => {
            reject({
              code: 4001,
              message: "User rejected the request."
            });
          }
        };
        signMessage2(signMessageOptions).catch((e) => {
          reject(e);
        });
      });
      const modifiedSig = Buffer.from(sig, "base64");
      modifiedSig[0] = 31 + (modifiedSig[0] - 31) % 4;
      return modifiedSig.toString("base64");
    });
  }
  on(event, handler) {
    return __privateGet2(this, _event).on(event, handler);
  }
  removeListener(event, handler) {
    return __privateGet2(this, _event).removeListener(event, handler);
  }
  getProvider() {
    if (!this.isReady()) {
      throw new Error(`${this.metadata.name} is not install!`);
    }
    return window.BitcoinProvider;
  }
  getNetwork() {
    return __async2(this, null, function* () {
      if (!this.isReady()) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      return __privateGet2(this, _network) === "Mainnet" ? "livenet" : "testnet";
    });
  }
  switchNetwork() {
    return __async2(this, null, function* () {
      throw new Error("Unsupported");
    });
  }
  sendBitcoin(toAddress, satoshis) {
    return __async2(this, null, function* () {
      const provider = this.getProvider();
      if (!provider) {
        throw new Error(`${this.metadata.name} is not install!`);
      }
      const { sendBtcTransaction } = yield import("./dist-IJ6YAD2H.js");
      const addresses = yield this.getAccounts();
      if (addresses.length === 0) {
        throw new Error(`${this.metadata.name} not connected!`);
      }
      const result = yield new Promise((resolve, reject) => {
        const sendBtcOptions = {
          payload: {
            network: {
              type: __privateGet2(this, _network)
            },
            recipients: [
              {
                address: toAddress,
                amountSats: BigInt(satoshis)
              }
            ],
            senderAddress: addresses[0]
          },
          onFinish: (response) => {
            resolve(response);
          },
          onCancel: () => {
            reject({
              code: 4001,
              message: "User rejected the request."
            });
          }
        };
        sendBtcTransaction(sendBtcOptions).catch((e) => reject(e));
      });
      return result;
    });
  }
  disconnect() {
    localStorage.removeItem("btc-connect-xverse-addresses-Mainnet");
    localStorage.removeItem("btc-connect-xverse-addresses-Testnet");
  }
};
_network = /* @__PURE__ */ new WeakMap();
_event = /* @__PURE__ */ new WeakMap();
var useAccounts = () => {
  const { accounts } = useConnectProvider();
  return { accounts };
};
var useBTCContractVersion = () => {
  const { btcContractVersionList, btcContractVersion, setBTCContractVersion } = useConnectProvider();
  return {
    btcContractVersionList,
    btcContractVersion,
    setBTCContractVersion
  };
};
var useBTCProvider = () => {
  const { connector, provider, accounts, getPublicKey, signMessage: signMessage2, getNetwork, switchNetwork, sendBitcoin } = useConnectProvider();
  const sendInscription = (0, import_react6.useCallback)(
    (address, inscriptionId, options) => __async2(void 0, null, function* () {
      if (!connector) {
        throw new Error("Wallet not connected!");
      }
      const result = yield connector.sendInscription(address, inscriptionId, options);
      return result;
    }),
    [connector]
  );
  return { provider, accounts, getPublicKey, signMessage: signMessage2, getNetwork, switchNetwork, sendBitcoin, sendInscription };
};
var useConnectModal = () => {
  const { openConnectModal, disconnect } = useConnectProvider();
  return { openConnectModal, disconnect };
};
var useConnector = () => {
  const { connectors, setConnectorId } = useConnectProvider();
  const connect = (0, import_react7.useCallback)(
    (connectorId) => __async2(void 0, null, function* () {
      const connector = connectors.find((item) => item.metadata.id === connectorId);
      if (!connector) {
        throw new Error(`connector id ${connectorId} not found`);
      }
      const accounts = yield connector.requestAccounts();
      if (accounts.length > 0) {
        localStorage.setItem("current-connector-id", connector.metadata.id);
        setConnectorId(connector.metadata.id);
      }
    }),
    [connectors, setConnectorId]
  );
  return { connectors, connect };
};
var EthereumProvider = class {
  constructor(sendUserOp, signer, account) {
    this.sendUserOp = sendUserOp;
    this.signer = signer;
    this.account = account;
  }
  on(event, listener) {
    var _a;
    (_a = this.signer) == null ? void 0 : _a.on(event, listener);
    return this;
  }
  once(event, listener) {
    var _a;
    (_a = this.signer) == null ? void 0 : _a.once(event, listener);
    return this;
  }
  off(event, listener) {
    var _a;
    (_a = this.signer) == null ? void 0 : _a.off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    var _a;
    (_a = this.signer) == null ? void 0 : _a.removeListener(event, listener);
    return this;
  }
  request(arg) {
    return __async2(this, null, function* () {
      var _a, _b;
      const method2 = arg.method;
      if (!method2) {
        throw new Error("Method not found.");
      }
      if (method2 === "eth_accounts" || method2 === "eth_requestAccounts") {
        return this.account ? [this.account] : [];
      } else if (method2 === "eth_sendTransaction") {
        const txData = (_a = arg.params) == null ? void 0 : _a[0];
        const result = yield this.sendUserOp({ tx: txData });
        return result;
      }
      return (_b = this.signer) == null ? void 0 : _b.request(arg);
    });
  }
};
var events = new import_events4.EventEmitter();
events.setMaxListeners(100);
var eventUtils_default = events;
var txConfirm = {
  isNotRemind: () => {
    if (typeof window === "undefined")
      return false;
    const value = localStorage.getItem("tx-confirm-modal-remind");
    return value === "0";
  },
  setNotRemind: (notRemind) => {
    if (typeof window === "undefined")
      return;
    if (notRemind) {
      localStorage.setItem("tx-confirm-modal-remind", "0");
    } else {
      localStorage.removeItem("tx-confirm-modal-remind");
    }
  },
  reset: () => {
    if (typeof window === "undefined")
      return;
    localStorage.removeItem("tx-confirm-modal-remind");
  }
};
var txConfirmUtils_default = txConfirm;
var useETHProvider = () => {
  const { evmAccount, smartAccount } = useConnectProvider();
  const [chainId, setChainId] = (0, import_react8.useState)();
  (0, import_react8.useEffect)(() => {
    if (smartAccount) {
      const chainId2 = smartAccount.provider.chainId;
      setChainId(chainId2);
      const onChangeChange = (id) => {
        setChainId(Number(id));
      };
      smartAccount.provider.on("chainChanged", onChangeChange);
      return () => {
        smartAccount.provider.removeListener("chainChanged", onChangeChange);
      };
    }
  }, [smartAccount]);
  const switchChain2 = (0, import_react8.useCallback)(
    (chainId2) => __async2(void 0, null, function* () {
      if (smartAccount == null ? void 0 : smartAccount.provider) {
        yield smartAccount.provider.request({
          method: "wallet_switchEthereumChain",
          params: [
            {
              chainId: intToHex(chainId2)
            }
          ]
        });
      }
    }),
    [smartAccount == null ? void 0 : smartAccount.provider]
  );
  const getFeeQuotes = (0, import_react8.useCallback)(
    (tx) => __async2(void 0, null, function* () {
      if (!smartAccount) {
        throw new Error("The smart account is not initialized.");
      }
      return smartAccount.getFeeQuotes(tx);
    }),
    [smartAccount]
  );
  const buildUserOp = (0, import_react8.useCallback)(
    (_0) => __async2(void 0, [_0], function* ({ tx, feeQuote, tokenPaymasterAddress }) {
      if (!smartAccount) {
        throw new Error("The smart account is not initialized.");
      }
      const result = yield smartAccount.buildUserOperation({ tx, feeQuote, tokenPaymasterAddress });
      return result;
    }),
    [smartAccount]
  );
  const sendUserOp = (0, import_react8.useCallback)(
    (params, forceHideConfirmModal) => __async2(void 0, null, function* () {
      if (!smartAccount) {
        throw new Error("The smart account is not initialized.");
      }
      const showConfirmModal = !forceHideConfirmModal && !txConfirmUtils_default.isNotRemind();
      if (showConfirmModal) {
        if (eventUtils_default.listenerCount("sendUserOpResult") > 0) {
          throw new Error("Operation failed, there is a transaction being processed");
        }
      }
      let userOpBundle;
      if (Object.prototype.hasOwnProperty.call(params, "userOpHash") && Object.prototype.hasOwnProperty.call(params, "userOp")) {
        const { userOpHash, userOp } = params;
        if (userOpHash && userOp) {
          userOpBundle = { userOpHash, userOp };
        }
      }
      if (!userOpBundle) {
        const { tx, feeQuote, tokenPaymasterAddress } = params;
        userOpBundle = yield buildUserOp({ tx, feeQuote, tokenPaymasterAddress });
      }
      if (!showConfirmModal) {
        return smartAccount.sendUserOperation(userOpBundle);
      }
      return new Promise((resolve, reject) => {
        eventUtils_default.emit("sendUserOp", userOpBundle);
        eventUtils_default.once("sendUserOpResult", ({ result, error }) => {
          if (result) {
            resolve(result);
          } else {
            reject(error);
          }
        });
      });
    }),
    [smartAccount, buildUserOp]
  );
  const publicClient = (0, import_react8.useMemo)(() => {
    if (!smartAccount || !chainId) {
      return void 0;
    }
    return (smartAccount == null ? void 0 : smartAccount.provider).publicClient;
  }, [smartAccount, chainId]);
  const provider = (0, import_react8.useMemo)(() => {
    const ethereumProvider = new EthereumProvider(sendUserOp, smartAccount == null ? void 0 : smartAccount.provider, evmAccount);
    return ethereumProvider;
  }, [evmAccount, sendUserOp, smartAccount == null ? void 0 : smartAccount.provider]);
  return {
    provider,
    evmAccount,
    switchChain: switchChain2,
    chainId,
    getFeeQuotes,
    buildUserOp,
    sendUserOp,
    publicClient
  };
};
var back_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiPjxwYXRoIGQ9Ik00MDAtODAgMC00ODBsNDAwLTQwMCA3MSA3MS0zMjkgMzI5IDMyOSAzMjktNzEgNzFaIiBmaWxsPSJ3aGl0ZSIvPjwvc3ZnPg==";
var close_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiPjxwYXRoIGQ9Im0yNTYtMjAwLTU2LTU2IDIyNC0yMjQtMjI0LTIyNCA1Ni01NiAyMjQgMjI0IDIyNC0yMjQgNTYgNTYtMjI0IDIyNCAyMjQgMjI0LTU2IDU2LTIyNC0yMjQtMjI0IDIyNFoiIGZpbGw9IndoaXRlIi8+PC9zdmc+";
var retry_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiPjxwYXRoIGQ9Ik00ODAtMTYwcS0xMzQgMC0yMjctOTN0LTkzLTIyN3EwLTEzNCA5My0yMjd0MjI3LTkzcTY5IDAgMTMyIDI4LjVUNzIwLTY5MHYtMTEwaDgwdjI4MEg1MjB2LTgwaDE2OHEtMzItNTYtODcuNS04OFQ0ODAtNzIwcS0xMDAgMC0xNzAgNzB0LTcwIDE3MHEwIDEwMCA3MCAxNzB0MTcwIDcwcTc3IDAgMTM5LTQ0dDg3LTExNmg4NHEtMjggMTA2LTExNCAxNzN0LTE5NiA2N1oiIGZpbGw9IndoaXRlIi8+PC9zdmc+";
var digest = "906d42389ecad5c2ab92642c8e0775ea667c413b069684ce9d01199562f2d0be";
var classes = { "loader": "_loader_g0am3_1", "rotate": "_rotate_g0am3_1", "prixClipFix": "_prixClipFix_g0am3_1" };
var css = `._loader_g0am3_1{animation:_rotate_g0am3_1 1s linear infinite;border-radius:50%;height:20px;position:relative;width:20px}._loader_g0am3_1:before{animation:_prixClipFix_g0am3_1 2s linear infinite;border:2px solid #000;border-radius:50%;box-sizing:border-box;content:"";inset:0;position:absolute}@keyframes _rotate_g0am3_1{to{transform:rotate(1turn)}}@keyframes _prixClipFix_g0am3_1{0%{clip-path:polygon(50% 50%,0 0,0 0,0 0,0 0,0 0)}25%{clip-path:polygon(50% 50%,0 0,100% 0,100% 0,100% 0,100% 0)}50%{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,100% 100%,100% 100%)}75%{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 100%)}to{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 0)}}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest)) {
    var ele = document.createElement("style");
    ele.id = digest;
    ele.textContent = css;
    document.head.appendChild(ele);
  }
})();
var spinner_module_default = classes;
var Spinner = ({ className, style: style2 }) => {
  return (0, import_jsx_runtime.jsx)("span", { className: spinner_module_default.loader + (className ? ` ${className}` : ""), style: style2 });
};
var spinner_default = Spinner;
var digest2 = "424d614dbc2763d7cad7ca35c00bd255c6ed55da308a1f3018594201a47127bf";
var classes2 = { "btn": "_btn_ofd87_1" };
var css2 = `._btn_ofd87_1{align-items:center;background:#fff;border-radius:8px;color:#000;display:flex;flex-direction:row;font-size:16px;gap:16px;justify-content:center;padding:6px 24px;position:relative}._btn_ofd87_1:hover{opacity:.85}._btn_ofd87_1:disabled{background:hsla(0,0%,100%,.2);color:hsla(0,0%,100%,.639);cursor:not-allowed;opacity:1}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest2)) {
    var ele = document.createElement("style");
    ele.id = digest2;
    ele.textContent = css2;
    document.head.appendChild(ele);
  }
})();
var button_module_default = classes2;
var Button = ({
  children,
  isLoading,
  isDisabled,
  onClick,
  className,
  style: style2
}) => {
  return (0, import_jsx_runtime2.jsxs)(
    "button",
    {
      className: button_module_default.btn + (className ? ` ${className}` : ""),
      onClick: isLoading || isDisabled ? void 0 : onClick,
      disabled: isDisabled,
      style: style2,
      children: [
        isLoading && !isDisabled && (0, import_jsx_runtime2.jsx)(spinner_default, {}),
        children
      ]
    }
  );
};
var button_default = Button;
var digest3 = "65eada90924218eba4e72a5f00291c3cb69387ecce1351e454cdefd066d4bcff";
var classes3 = { "container": "_container_smzpm_1", "modal": "_modal_smzpm_18" };
var css3 = `._container_smzpm_1{align-items:center;backdrop-filter:blur(12px);background:rgba(0,0,0,.502);bottom:0;color:#fff;display:flex;height:100%;justify-content:center;left:0;overflow:hidden;position:fixed;right:0;top:0;width:100%;z-index:100000}._container_smzpm_1 ._modal_smzpm_18{align-items:center;background-color:#171a1f;border-radius:16px;display:flex;flex-direction:column;font-size:14px;height:auto;margin:16px;max-height:80%;max-width:100%;overflow:auto;padding:24px;position:relative;width:380px}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest3)) {
    var ele = document.createElement("style");
    ele.id = digest3;
    ele.textContent = css3;
    document.head.appendChild(ele);
  }
})();
var modal_module_default = classes3;
var stopPropagation = (event) => event.stopPropagation();
var Modal = ({ open, onClose, children, isDismissable = true, contentStyle, contentClassName }) => {
  const handleBackdropClick = (0, import_react9.useMemo)(() => isDismissable ? onClose : void 0, [onClose, isDismissable]);
  (0, import_react9.useEffect)(() => {
    if (isDismissable) {
      const handleEscape = (event) => open && event.key === "Escape" && onClose();
      document.addEventListener("keydown", handleEscape);
      return () => document.removeEventListener("keydown", handleEscape);
    }
  }, [open, onClose, isDismissable]);
  const [bodyScrollable, setBodyScrollable] = (0, import_react9.useState)(true);
  (0, import_react9.useEffect)(() => {
    setBodyScrollable(getComputedStyle(window.document.body).overflow !== "hidden");
  }, []);
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: open ? (0, import_react_dom.createPortal)(
    (0, import_jsx_runtime3.jsx)(Combination_default, { enabled: bodyScrollable, children: (0, import_jsx_runtime3.jsx)("div", { className: modal_module_default.container, onClick: handleBackdropClick, children: (0, import_jsx_runtime3.jsx)(
      "div",
      {
        className: modal_module_default.modal + (contentClassName ? ` ${contentClassName}` : ""),
        style: contentStyle,
        onClick: stopPropagation,
        children
      }
    ) }) }),
    document.body
  ) : null });
};
var modal_default = Modal;
var digest4 = "c7bbc091f1227154742a5bd0d55a3df29eb913eb0ad4cafc7ab236b574002f65";
var classes4 = { "connectModal": "_connectModal_1kqtj_1", "title": "_title_1kqtj_4", "closeBtn": "_closeBtn_1kqtj_9", "backBtn": "_backBtn_1kqtj_15", "walletItem": "_walletItem_1kqtj_21", "walletIcon": "_walletIcon_1kqtj_33", "walletName": "_walletName_1kqtj_38", "connecting": "_connecting_1kqtj_43", "connectingIconContainer": "_connectingIconContainer_1kqtj_51", "retryContainer": "_retryContainer_1kqtj_54", "retryIcon": "_retryIcon_1kqtj_63", "connectingIcon": "_connectingIcon_1kqtj_51", "connection": "_connection_1kqtj_72", "acceptRequest": "_acceptRequest_1kqtj_76", "btnDownload": "_btnDownload_1kqtj_83" };
var css4 = `._connectModal_1kqtj_1{gap:12px}._connectModal_1kqtj_1 ._title_1kqtj_4{font-size:18px;font-weight:700;margin-bottom:4px}._connectModal_1kqtj_1 ._closeBtn_1kqtj_9{cursor:pointer;position:absolute;right:16px;top:16px}._connectModal_1kqtj_1 ._backBtn_1kqtj_15{cursor:pointer;left:16px;position:absolute;top:16px}._connectModal_1kqtj_1 ._walletItem_1kqtj_21{border:1px solid #3a3a3a;border-radius:8px;box-sizing:border-box;cursor:pointer;display:flex;padding:8px;width:100%}._connectModal_1kqtj_1 ._walletItem_1kqtj_21:hover{background:hsla(0,0%,100%,.05)}._connectModal_1kqtj_1 ._walletItem_1kqtj_21 ._walletIcon_1kqtj_33{border-radius:4px;height:42px;width:42px}._connectModal_1kqtj_1 ._walletItem_1kqtj_21 ._walletName_1kqtj_38{flex-grow:1;line-height:42px;text-align:center}._connectModal_1kqtj_1 ._connecting_1kqtj_43{align-items:center;display:flex;flex-direction:column;height:204px;justify-content:center;width:100%}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._connectingIconContainer_1kqtj_51{position:relative}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._connectingIconContainer_1kqtj_51 ._retryContainer_1kqtj_54{background:#4b5563;border-radius:50%;bottom:-12px;cursor:pointer;padding:4px;position:absolute;right:-12px}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._connectingIconContainer_1kqtj_51 ._retryContainer_1kqtj_54 ._retryIcon_1kqtj_63{height:24px;width:24px}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._connectingIcon_1kqtj_51{border-radius:4px;height:60px;width:60px}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._connection_1kqtj_72{font-size:18px;margin-top:20px}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._acceptRequest_1kqtj_76{color:hsla(0,0%,100%,.4);font-size:14px;margin-top:6px;text-align:center;white-space:pre-wrap}._connectModal_1kqtj_1 ._connecting_1kqtj_43 ._btnDownload_1kqtj_83{margin-top:20px}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest4)) {
    var ele = document.createElement("style");
    ele.id = digest4;
    ele.textContent = css4;
    document.head.appendChild(ele);
  }
})();
var connect_module_default = classes4;
var ConnectModal = ({ open, onClose }) => {
  const [backVisible, setBackVisible] = (0, import_react5.useState)(false);
  const [retryVisible, setRetryVisible] = (0, import_react5.useState)(false);
  const [walletReady, setWalletReady] = (0, import_react5.useState)(true);
  const [selectConnector, setSelectConnector] = (0, import_react5.useState)();
  const { closeConnectModal } = useConnectProvider();
  const { connect, connectors } = useConnector();
  (0, import_react5.useEffect)(() => {
    if (!open) {
      setBackVisible(false);
      setRetryVisible(false);
      setWalletReady(true);
      setSelectConnector(void 0);
    }
  }, [open]);
  const onConnect = (connector) => __async2(void 0, null, function* () {
    setBackVisible(true);
    setSelectConnector(connector);
    if (connector.isReady()) {
      try {
        yield connect(connector.metadata.id);
        closeConnectModal();
      } catch (error) {
        if (error.code === 4001) {
          setRetryVisible(true);
        }
      }
    } else {
      setWalletReady(false);
    }
  });
  const onBack = () => {
    setBackVisible(false);
    setRetryVisible(false);
    setWalletReady(true);
    setSelectConnector(void 0);
  };
  const onRetry = () => {
    setRetryVisible(false);
    if (selectConnector) {
      onConnect(selectConnector);
    }
  };
  return (0, import_jsx_runtime4.jsxs)(modal_default, { open, onClose, isDismissable: false, contentClassName: connect_module_default.connectModal, children: [
    (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.title, children: (selectConnector == null ? void 0 : selectConnector.metadata.name) || "Choose Wallet" }),
    (0, import_jsx_runtime4.jsx)("img", { className: connect_module_default.closeBtn, src: close_default, onClick: onClose }),
    backVisible && (0, import_jsx_runtime4.jsx)("img", { className: connect_module_default.backBtn, src: back_default, onClick: onBack }),
    !backVisible && connectors.map((connector) => {
      return (0, import_jsx_runtime4.jsxs)("div", { className: connect_module_default.walletItem, onClick: () => onConnect(connector), children: [
        (0, import_jsx_runtime4.jsx)("img", { className: connect_module_default.walletIcon, src: connector.metadata.icon }),
        (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.walletName, children: connector.metadata.name })
      ] }, connector.metadata.id);
    }),
    backVisible && selectConnector && (0, import_jsx_runtime4.jsxs)("div", { className: connect_module_default.connecting, children: [
      (0, import_jsx_runtime4.jsxs)("div", { className: connect_module_default.connectingIconContainer, children: [
        (0, import_jsx_runtime4.jsx)("img", { className: connect_module_default.connectingIcon, src: selectConnector.metadata.icon }),
        retryVisible && (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.retryContainer, onClick: onRetry, children: (0, import_jsx_runtime4.jsx)("img", { className: connect_module_default.retryIcon, src: retry_default }) })
      ] }),
      walletReady ? (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.connection, children: retryVisible ? "Request Cancelled" : "Requesting Connection" }),
        (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.acceptRequest, children: retryVisible ? "You cancelled the request.\nClick above to try again." : "Accept the request through your wallet to connect to this app." })
      ] }) : (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        (0, import_jsx_runtime4.jsx)("div", { className: connect_module_default.connection, children: "Wallet Not Installed." }),
        (0, import_jsx_runtime4.jsx)(
          button_default,
          {
            className: connect_module_default.btnDownload,
            onClick: () => {
              window.open(selectConnector == null ? void 0 : selectConnector.metadata.downloadUrl, "_blank");
            },
            children: "Get"
          }
        )
      ] })
    ] })
  ] });
};
var connectModal_default = ConnectModal;
var check_box_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiIGZpbGw9IiNhODU1ZjciPgogICAgPHBhdGgKICAgICAgICBkPSJtNDI0LTMxMiAyODItMjgyLTU2LTU2LTIyNiAyMjYtMTE0LTExNC01NiA1NiAxNzAgMTcwWk0yMDAtMTIwcS0zMyAwLTU2LjUtMjMuNVQxMjAtMjAwdi01NjBxMC0zMyAyMy41LTU2LjVUMjAwLTg0MGg1NjBxMzMgMCA1Ni41IDIzLjVUODQwLTc2MHY1NjBxMCAzMy0yMy41IDU2LjVUNzYwLTEyMEgyMDBabTAtODBoNTYwdi01NjBIMjAwdjU2MFptMC01NjB2NTYwLTU2MFoiIC8+Cjwvc3ZnPg==";
var check_box_blank_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiIGZpbGw9IiM2YjcyODAiPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm0wLTgwaDU2MHYtNTYwSDIwMHY1NjBaIiAvPgo8L3N2Zz4=";
var copy_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiIGZpbGw9IiNmZmYiPgogICAgPHBhdGgKICAgICAgICBkPSJNMzYwLTI0MHEtMzMgMC01Ni41LTIzLjVUMjgwLTMyMHYtNDgwcTAtMzMgMjMuNS01Ni41VDM2MC04ODBoMzYwcTMzIDAgNTYuNSAyMy41VDgwMC04MDB2NDgwcTAgMzMtMjMuNSA1Ni41VDcyMC0yNDBIMzYwWm0wLTgwaDM2MHYtNDgwSDM2MHY0ODBaTTIwMC04MHEtMzMgMC01Ni41LTIzLjVUMTIwLTE2MHYtNTYwaDgwdjU2MGg0NDB2ODBIMjAwWm0xNjAtMjQwdi00ODAgNDgwWiIgLz4KPC9zdmc+";
function shortString(str) {
  if (Array.isArray(str)) {
    str = "[" + str.toString() + "]";
  }
  if (str) {
    if (typeof str.toString === "function") {
      str = str.toString();
    }
    if (str.length <= 10) {
      return str;
    }
    return `${str.slice(0, 5)}...${str.slice(str.length - 5, str.length)}`;
  }
  return "";
}
function copyToClipboard(text) {
  return __async2(this, null, function* () {
    const clipboardCopy = () => __async2(this, null, function* () {
      if (navigator.clipboard) {
        return navigator.clipboard.writeText(text);
      } else {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.setAttribute("readonly", "");
        textarea.style.position = "absolute";
        textarea.style.left = "-9999px";
        document.body.appendChild(textarea);
        textarea.select();
        const result = document.execCommand("copy");
        document.body.removeChild(textarea);
        if (!result) {
          throw new Error("Copy to clipboard failed");
        }
      }
    });
    return new Promise((resolve, reject) => {
      clipboardCopy().then(resolve).catch(reject);
    });
  });
}
var defaultTokenIcon = "https://static.particle.network/token-list/defaultToken/default.png";
var ipfsToSrc = (ipfs) => {
  if (!ipfs || !ipfs.startsWith("ipfs://")) {
    return ipfs || "";
  }
  return `https://ipfs.particle.network/${encodeURI(ipfs.slice(7))}`;
};
var checkBTCVersion = (accountContracts, version) => {
  if (!accountContracts["BTC"]) {
    return false;
  }
  return accountContracts["BTC"].some((item) => item.version === version);
};
var pubKeyToEVMAddress = (pubKey) => {
  const address = toChecksumAddress(bytesToHex4(publicToAddress(toBytes4(`0x${pubKey}`), true)));
  return address;
};
var convertSignature = (signature) => {
  const sig = import_bitcore_lib.default.crypto.Signature.fromCompact(Buffer.from(signature, "base64"));
  const v = BigInt(sig.i + 27);
  const evmSig = toRpcSig(v, sig.r.toBuffer(), sig.s.toBuffer());
  return evmSig;
};
function caculateNativeFee(userOp) {
  return (BigInt(userOp.callGasLimit) + BigInt(userOp.verificationGasLimit) + BigInt(userOp.preVerificationGas)) * BigInt(userOp.maxFeePerGas);
}
var getBTCAAAddress = (smartAccount, btcAddress, BTCVersion) => __async2(void 0, null, function* () {
  var _a;
  const addresses = yield smartAccount.provider.request({ method: "eth_accounts" });
  const owner = addresses[0];
  const localKey = `particle_BTC_${BTCVersion}_${owner}`;
  if (typeof window !== "undefined" && localStorage) {
    const localAA = localStorage.getItem(localKey);
    if (localAA) {
      return localAA;
    }
  }
  const btcPublicKey = yield smartAccount.provider.getPublicKey();
  const accountInfo = yield smartAccount.sendRpc({
    method: "particle_aa_getBTCAccount",
    params: [
      {
        name: "BTC",
        version: BTCVersion,
        btcPublicKey,
        btcAddress
      }
    ]
  });
  const address = (_a = accountInfo == null ? void 0 : accountInfo[0]) == null ? void 0 : _a.smartAccountAddress;
  if (typeof window !== "undefined" && localStorage && address) {
    localStorage.setItem(localKey, address);
  }
  return address;
});
var digest5 = "d6fbb5df7ed6ec51d41f665ca768306181bb1e7d7c1cef8eed9bd4230368d7bb";
var classes5 = { "copyText": "_copyText_smolu_1", "copied": "_copied_smolu_9" };
var css5 = `._copyText_smolu_1{cursor:pointer;text-decoration-line:underline}._copyText_smolu_1:hover{opacity:.75}._copied_smolu_9{color:#a855f7;cursor:none;text-decoration-line:none}._copied_smolu_9:hover{opacity:1}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest5)) {
    var ele = document.createElement("style");
    ele.id = digest5;
    ele.textContent = css5;
    document.head.appendChild(ele);
  }
})();
var copyText_module_default = classes5;
function CopyText({ children, value, className, style: style2 }) {
  const [copied, setCopied] = (0, import_react11.useState)();
  const handleClick = () => __async2(this, null, function* () {
    if (copied) {
      return;
    }
    try {
      if (value) {
        yield copyToClipboard(value);
      } else if (typeof children === "string" || typeof children === "number" || typeof children === "boolean") {
        yield copyToClipboard(children.toString());
      } else {
        throw new Error("please set copy value");
      }
      setCopied(true);
      setTimeout(() => setCopied(false), 1e3);
    } catch (error) {
    }
  });
  return (0, import_jsx_runtime5.jsx)(
    "div",
    {
      className: copyText_module_default.copyText + (className ? ` ${className}` : "") + (copied ? ` ${copyText_module_default.copied}` : ""),
      onClick: handleClick,
      style: style2,
      children: copied ? "Copied" : children
    }
  );
}
var unverified_default = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB0PSIxNzA5Mjg0MDMwNzM5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDExNTIgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICBwLWlkPSIxMzY3NSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij4KICAgIDxwYXRoCiAgICAgICAgZD0iTTExMjguNjQgODA2LjI3Mkw2NzYuMTYgNzIuMzJjLTU1LjE2OC05Ni4zMi0xNDUuMTUyLTk2LjMyLTIwMC4yNTYgMEwyMy4yMzIgODA2LjRDLTMxLjgwOCA5MDIuNTkyIDE0LjU5MiA5NzkuMiAxMjQuOCA5NzkuMmg5MDUuMjE2YzEwNy4zOTIgMCAxNTMuNzkyLTc5LjM2IDk4LjYyNC0xNzIuOTI4eiIKICAgICAgICBmaWxsPSIjZWFiMzA4IiBwLWlkPSIxMzY3NiI+PC9wYXRoPgogICAgPHBhdGgKICAgICAgICBkPSJNNTc0LjQ2NCA2OTUuODA4YzMyIDAgNjAuOTkyIDI4LjM1MiA2MC45OTIgNTkuNTIgMCAzMS4xNjgtMjYuMTEyIDU5LjUyLTYwLjk5MiA1OS41MmE2MC41NDQgNjAuNTQ0IDAgMCAxLTYwLjgtNTkuNTJjMC0zMS4yMzIgMjguOTI4LTU5LjUyIDYwLjgtNTkuNTJ6IG0yLjg4LTQ0NC45OTJjMjMuMjk2IDAgNDMuNTg0IDE5Ljg0IDQzLjU4NCA0Mi40OTZ2Mjk3LjZjMCAyMi42NTYtMjAuMjg4IDQyLjQ5Ni00My41MiA0Mi40OTZhNDQuMTYgNDQuMTYgMCAwIDEtNDMuNTItNDIuNDk2di0yOTcuNmMwLTIyLjY1NiAyMC4yODgtNDIuNDk2IDQzLjUyLTQyLjQ5NnoiCiAgICAgICAgZmlsbD0iI0ZGRkZGRiIgcC1pZD0iMTM2NzciPjwvcGF0aD4KPC9zdmc+";
var verified_default = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB0PSIxNzA5MjgzOTE4NzM0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICBwLWlkPSIxMjI3OCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij4KICAgIDxwYXRoIGQ9Ik01MTIgNTEybS01MTIgMGE1MTIgNTEyIDAgMSAwIDEwMjQgMCA1MTIgNTEyIDAgMSAwLTEwMjQgMFoiIGZpbGw9IiM0YWRlODAiIHAtaWQ9IjEyMjc5Ij48L3BhdGg+CiAgICA8cGF0aAogICAgICAgIGQ9Ik00NjkuMzc2IDYyMC4xNkwyOTMuNjMyIDQ2OC40OEE1Ny42IDU3LjYgMCAxIDAgMjE4LjM2OCA1NTUuNTJsMjE5LjcxMiAxODkuNzZhNjAuOCA2MC44IDAgMCAwIDg1Ljc2LTYuMjcybDIuNDk2LTMuMTM2IDI4Ny42MTYtMzgxLjI0OGE1Ny42IDU3LjYgMCAwIDAtOTEuOTA0LTY5LjM3Nkw0NjkuMzc2IDYyMC4xNnoiCiAgICAgICAgZmlsbD0iI0ZGRkZGRiIgcC1pZD0iMTIyODAiPjwvcGF0aD4KPC9zdmc+";
var digest6 = "ee15dc27fcfd209601159e7f0e0063ff4e7a886b7b892c1600a911372b82a0b1";
var classes6 = { "tipContainer": "_tipContainer_ufud7_1", "tipContent": "_tipContent_ufud7_5" };
var css6 = `._tipContainer_ufud7_1{overflow:visible;position:relative}._tipContainer_ufud7_1 ._tipContent_ufud7_5{background:#3f3f46;border-radius:8px;bottom:100%;color:#fff;font-size:11px;left:-100%;opacity:0;padding:3px 6px;position:absolute;transition:opacity .5s;visibility:hidden;white-space:nowrap;z-index:1}._tipContainer_ufud7_1:hover ._tipContent_ufud7_5{opacity:1;visibility:visible}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest6)) {
    var ele = document.createElement("style");
    ele.id = digest6;
    ele.textContent = css6;
    document.head.appendChild(ele);
  }
})();
var tooltip_module_default = classes6;
var Tooltip = ({ children, content, className }) => {
  return (0, import_jsx_runtime6.jsxs)("div", { className: tooltip_module_default.tipContainer, children: [
    children,
    (0, import_jsx_runtime6.jsx)("div", { className: tooltip_module_default.tipContent + (className ? ` ${className}` : ""), children: content })
  ] });
};
var tooltip_default = Tooltip;
var digest7 = "a81c744751497ed4b401c08b9e5aeef1991aeb86f2cbba3ee57c1926c0502f1a";
var classes7 = { "detailsCard": "_detailsCard_ml2p9_1", "title": "_title_ml2p9_13", "nftContract": "_nftContract_ml2p9_19", "row": "_row_ml2p9_26", "tokenIcon": "_tokenIcon_ml2p9_35", "nftIcon": "_nftIcon_ml2p9_41", "balanceChange": "_balanceChange_ml2p9_49", "tokenSymbol": "_tokenSymbol_ml2p9_56", "toContract": "_toContract_ml2p9_61", "right": "_right_ml2p9_71" };
var css7 = `._detailsCard_ml2p9_1{background:#232529;border:1px solid #252525;border-radius:8px;color:#fff;margin-top:16px;overflow-x:hidden;padding:10px;position:relative;width:100%}._detailsCard_ml2p9_1 ._title_ml2p9_13{font-size:16px;font-weight:600;margin-bottom:12px;text-align:left}._detailsCard_ml2p9_1 ._nftContract_ml2p9_19{color:#a855f7;font-size:16px;position:absolute;right:8px;top:8px}._detailsCard_ml2p9_1 ._row_ml2p9_26{align-items:center;display:flex;flex-direction:row;font-size:14px;gap:8px;justify-content:space-between;margin-top:6px}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._tokenIcon_ml2p9_35{border-radius:50%;height:32px;margin:10px 0;width:32px}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._nftIcon_ml2p9_41{border-radius:2px;display:inline;height:32px;margin:10px 8px 10px 0;width:32px}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._balanceChange_ml2p9_49{flex-grow:2;font-size:16px;font-weight:500;text-align:end;word-break:break-word}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._tokenSymbol_ml2p9_56{font-size:16px;font-weight:500;text-align:end}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._toContract_ml2p9_61{align-items:center;display:flex;gap:8px}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._toContract_ml2p9_61 img{display:inline;height:18px;width:18px}._detailsCard_ml2p9_1 ._row_ml2p9_26 ._right_ml2p9_71{text-align:end}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest7)) {
    var ele = document.createElement("style");
    ele.id = digest7;
    ele.textContent = css7;
    document.head.appendChild(ele);
  }
})();
var transactionDetails_module_default = classes7;
var TransactionDetails = ({ details }) => {
  const { chainId } = useETHProvider();
  const chainInfo = (0, import_react12.useMemo)(() => {
    if (chainId) {
      return chains_exports.getEVMChainInfoById(chainId);
    }
  }, [chainId]);
  const titleContent = (0, import_react12.useMemo)(() => {
    var _a;
    switch (details.type) {
      case "native_transfer":
        return `Send ${chainInfo == null ? void 0 : chainInfo.nativeCurrency.symbol}`;
      case "erc20_transfer":
        return `Send ${(_a = details.estimatedChanges.tokens[0]) == null ? void 0 : _a.symbol}`;
      case "erc20_approve":
        return "Approve Spending";
      case "erc721_transfer":
        return "Send NFT";
      case "erc1155_transfer":
        return "Send NFT";
      default:
        return "Transaction Details";
    }
  }, [details, chainInfo]);
  const nftContractType = (0, import_react12.useMemo)(() => {
    if (details.type === "erc721_transfer") {
      return "ERC721";
    } else if (details.type === "erc1155_transfer") {
      return "ERC1155";
    }
  }, [details]);
  const nativeIcon = (0, import_react12.useMemo)(() => {
    if (chainInfo) {
      if (chainInfo.nativeCurrency.symbol === "ETH") {
        return "https://static.particle.network/token-list/ethereum/native.png";
      } else {
        return chainInfo.nativeIcon || chainInfo.icon;
      }
    }
    return defaultTokenIcon;
  }, [chainInfo]);
  const to = (0, import_react12.useMemo)(() => {
    var _a, _b;
    const params = (_b = (_a = details.data) == null ? void 0 : _a.function) == null ? void 0 : _b.params;
    if (details.type == "erc20_transfer") {
      return params ? params[params.length === 3 ? 1 : 0].value : "";
    } else if (details.type == "erc20_approve") {
      return params ? params[0].value : "";
    } else if (details.type == "native_transfer") {
      return details.data.to;
    } else if (details.type == "erc721_transfer" || details.type == "erc1155_transfer") {
      return params ? params[1].value : "";
    } else {
      return details.data.to;
    }
  }, [details]);
  const balanceChangeTextColor = (0, import_react12.useCallback)((value) => {
    if (BigInt(value) > 0) {
      return "#4ade80";
    } else if (BigInt(value) < 0) {
      return "#ef4444";
    } else {
      return "white";
    }
  }, []);
  const functionContent = (0, import_react12.useMemo)(() => {
    if (details.type !== "native_transfer" && details.data.function) {
      const params = details.data.function.params.map((item) => item.name);
      return `${details.data.function.name}(${params.join(", ")})`;
    }
  }, [details]);
  const approveTokenAmount = (0, import_react12.useMemo)(() => {
    var _a, _b, _c, _d;
    if (details.type === "erc20_approve") {
      const amount = (_d = (_c = (_b = (_a = details.data) == null ? void 0 : _a.function) == null ? void 0 : _b.params) == null ? void 0 : _c[1]) == null ? void 0 : _d.value;
      return BigInt(amount || 0);
    }
    return BigInt(0);
  }, [details]);
  const tokenAmountChange = (0, import_react12.useCallback)(
    (tokenItem) => {
      const result = formatUnits(
        details.type === "erc20_approve" ? approveTokenAmount : BigInt(tokenItem.amountChange),
        tokenItem.decimals
      );
      if (details.type !== "erc20_approve" && BigInt(tokenItem.amountChange) > BigInt(0)) {
        return `+${result}`;
      }
      return result;
    },
    [approveTokenAmount, details]
  );
  const showContactAddress = (0, import_react12.useMemo)(() => {
    return details.type === "erc20_transfer" || details.type === "erc20_approve" || details.type === "erc721_transfer" || details.type === "erc1155_transfer";
  }, [details]);
  return (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.detailsCard, children: [
    (0, import_jsx_runtime7.jsx)("div", { className: transactionDetails_module_default.title, children: titleContent }),
    nftContractType && (0, import_jsx_runtime7.jsx)("div", { className: transactionDetails_module_default.nftContract, children: nftContractType }),
    details.estimatedChanges.natives.map((nativeItem) => {
      return (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
        (0, import_jsx_runtime7.jsx)("img", { className: transactionDetails_module_default.tokenIcon, src: nativeIcon }),
        (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.balanceChange, style: { color: balanceChangeTextColor(nativeItem.nativeChange) }, children: [
          BigInt(nativeItem.nativeChange) > 0 ? "+" : void 0,
          formatUnits(BigInt(nativeItem.nativeChange), (chainInfo == null ? void 0 : chainInfo.nativeCurrency.decimals) || 18)
        ] }),
        (0, import_jsx_runtime7.jsx)("div", { className: transactionDetails_module_default.tokenSymbol, children: chainInfo == null ? void 0 : chainInfo.nativeCurrency.symbol })
      ] }, nativeItem.address);
    }),
    details.estimatedChanges.tokens.map((tokenItem) => {
      return (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
        (0, import_jsx_runtime7.jsx)("img", { className: transactionDetails_module_default.tokenIcon, src: tokenItem.image || defaultTokenIcon }),
        (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.balanceChange, children: [
          (0, import_jsx_runtime7.jsx)("span", { style: { color: balanceChangeTextColor(tokenItem.amountChange) }, children: tokenAmountChange(tokenItem) }),
          ` ${tokenItem.symbol}`
        ] })
      ] }, tokenItem.address);
    }),
    details.estimatedChanges.nfts.map((nftItem) => {
      return (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
        (0, import_jsx_runtime7.jsxs)("div", { style: { fontSize: 16 }, children: [
          (0, import_jsx_runtime7.jsx)("img", { className: transactionDetails_module_default.nftIcon, src: ipfsToSrc(nftItem.image || defaultTokenIcon) }),
          nftItem.name || `NFT#${nftItem.tokenId}`
        ] }),
        (0, import_jsx_runtime7.jsx)("div", { className: transactionDetails_module_default.balanceChange, style: { color: balanceChangeTextColor(nftItem.amountChange) }, children: nftItem.amountChange })
      ] }, nftItem.address);
    }),
    to && (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
      (0, import_jsx_runtime7.jsx)("div", { children: "To" }),
      (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.toContract, children: [
        details.toVerified != null && !showContactAddress && (0, import_jsx_runtime7.jsx)(tooltip_default, { content: details.toVerified ? "Verified Contract" : "Unverified Contract", children: (0, import_jsx_runtime7.jsx)("img", { src: details.toVerified ? verified_default : unverified_default }) }),
        (0, import_jsx_runtime7.jsx)(CopyText, { value: to, children: shortString(to) })
      ] })
    ] }),
    showContactAddress && (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
      (0, import_jsx_runtime7.jsx)("div", { children: "Contract" }),
      (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.toContract, children: [
        details.toVerified != null && (0, import_jsx_runtime7.jsx)(tooltip_default, { content: details.toVerified ? "Verified Contract" : "Unverified Contract", children: (0, import_jsx_runtime7.jsx)("img", { src: details.toVerified ? verified_default : unverified_default }) }),
        (0, import_jsx_runtime7.jsx)(CopyText, { value: details.data.to, children: shortString(details.data.to) })
      ] })
    ] }),
    (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
      (0, import_jsx_runtime7.jsx)("div", { children: "Hex Data" }),
      (0, import_jsx_runtime7.jsx)(CopyText, { value: details.data.data, children: shortString(details.data.data) })
    ] }),
    functionContent && (0, import_jsx_runtime7.jsxs)("div", { className: transactionDetails_module_default.row, children: [
      (0, import_jsx_runtime7.jsx)("div", { children: "Function" }),
      (0, import_jsx_runtime7.jsx)("div", { className: transactionDetails_module_default.right, children: functionContent })
    ] })
  ] });
};
var transactionDetails_default = TransactionDetails;
var digest8 = "72313e432f73b0b64e505d7f124c42b72235a12b3842ef8816b5e500b7fc785a";
var classes8 = { "modalContent": "_modalContent_ikogv_1", "closeBtn": "_closeBtn_ikogv_5", "chainInfo": "_chainInfo_ikogv_11", "addressContainer": "_addressContainer_ikogv_24", "addressInfo": "_addressInfo_ikogv_29", "detailsContent": "_detailsContent_ikogv_44", "fill": "_fill_ikogv_53", "estimatedGas": "_estimatedGas_ikogv_56", "signBtn": "_signBtn_ikogv_61", "notRemind": "_notRemind_ikogv_65" };
var css8 = `._modalContent_ikogv_1{color:#fff;text-align:center}._modalContent_ikogv_1 ._closeBtn_ikogv_5{cursor:pointer;position:absolute;right:16px;top:16px}._modalContent_ikogv_1 ._chainInfo_ikogv_11{align-items:center;display:flex;flex-direction:row;font-size:12px;gap:8px;justify-content:center;margin-bottom:8px}._modalContent_ikogv_1 ._chainInfo_ikogv_11 img{height:18px;width:18px}._modalContent_ikogv_1 ._addressContainer_ikogv_24{height:28px;margin-bottom:16px;margin-top:8px}._modalContent_ikogv_1 ._addressContainer_ikogv_24 ._addressInfo_ikogv_29{align-items:center;background:rgba(58,58,58,.635);border-radius:20px;display:flex;flex-direction:row;font-size:12px;gap:4px;justify-content:center;padding:4px 8px}._modalContent_ikogv_1 ._addressContainer_ikogv_24 ._addressInfo_ikogv_29 img{height:18px;width:18px}._modalContent_ikogv_1 ._detailsContent_ikogv_44{max-height:0;overflow-y:auto;transition:max-height .3s linear;width:100%}._modalContent_ikogv_1 ._detailsContent_ikogv_44::-webkit-scrollbar{display:none}._modalContent_ikogv_1 ._detailsContent_ikogv_44._fill_ikogv_53{max-height:500px}._modalContent_ikogv_1 ._estimatedGas_ikogv_56{color:hsla(0,0%,100%,.631);font-size:12px;margin-top:24px}._modalContent_ikogv_1 ._signBtn_ikogv_61{margin-top:24px;min-width:200px}._modalContent_ikogv_1 ._notRemind_ikogv_65{align-items:center;color:hsla(0,0%,100%,.631);cursor:pointer;display:inline-flex;font-size:12px;gap:4px;margin-top:16px}._modalContent_ikogv_1 ._notRemind_ikogv_65:hover{opacity:.85}`;
(function() {
  if (typeof document !== "undefined" && !document.getElementById(digest8)) {
    var ele = document.createElement("style");
    ele.id = digest8;
    ele.textContent = css8;
    document.head.appendChild(ele);
  }
})();
var sign_module_default = classes8;
var SignModal = ({ open, onClose, onOpen }) => {
  const [userOpBundle, setUserOpBundle] = (0, import_react10.useState)();
  const [notRemindChecked, setNotRemindChecked] = (0, import_react10.useState)(false);
  const [loading, setLoading] = (0, import_react10.useState)(false);
  const [deserializeLoading, setDeserializeLoading] = (0, import_react10.useState)(false);
  const [deserializeResult, setDeserializeResult] = (0, import_react10.useState)();
  const [disabled, setDisabled] = (0, import_react10.useState)(false);
  const [showNotRemind, setShowNotRemind] = (0, import_react10.useState)(true);
  const [nativeBalance, setNativeBalance] = (0, import_react10.useState)();
  const { btcContractVersion } = useBTCContractVersion();
  const { chainId, publicClient, evmAccount } = useETHProvider();
  const { smartAccount } = useConnectProvider();
  (0, import_react10.useEffect)(() => {
    if (!open) {
      setDeserializeResult(void 0);
      setUserOpBundle(void 0);
      setLoading(false);
      setDisabled(false);
      setDeserializeLoading(false);
      setNativeBalance(void 0);
    }
  }, [open]);
  (0, import_react10.useEffect)(() => {
    if (open) {
      const notRemind = txConfirmUtils_default.isNotRemind();
      setShowNotRemind(!notRemind);
      if (!notRemind) {
        setNotRemindChecked(false);
      }
    }
  }, [open]);
  const chainInfo = (0, import_react10.useMemo)(() => {
    if (chainId) {
      return chains_exports.getEVMChainInfoById(chainId);
    }
  }, [chainId]);
  (0, import_react10.useEffect)(() => {
    const onSendUserOp = (opBundle) => {
      setUserOpBundle(opBundle);
      onOpen();
    };
    eventUtils_default.on("sendUserOp", onSendUserOp);
    return () => {
      eventUtils_default.off("sendUserOp", onSendUserOp);
    };
  }, [onOpen, setUserOpBundle]);
  const deserializeUserOp = (0, import_react10.useCallback)(() => __async2(void 0, null, function* () {
    if (userOpBundle && smartAccount) {
      const addresses = yield smartAccount.provider.request({ method: "eth_accounts" });
      const owner = addresses[0];
      const result = yield smartAccount.sendRpc({
        method: "particle_aa_deserializeUserOp",
        params: [
          {
            name: "BTC",
            version: btcContractVersion,
            ownerAddress: owner
          },
          userOpBundle.userOp
        ]
      });
      return result;
    }
  }), [userOpBundle, smartAccount, btcContractVersion]);
  (0, import_react10.useEffect)(() => {
    if (userOpBundle && open) {
      deserializeUserOp().then((result) => {
        setDeserializeResult(result);
      }).catch((error) => {
        eventUtils_default.emit("sendUserOpResult", {
          error
        });
        onClose();
      });
    }
  }, [deserializeUserOp, userOpBundle, open, onClose]);
  (0, import_react10.useEffect)(() => {
    if (open && publicClient && evmAccount) {
      publicClient.getBalance({ address: evmAccount }).then((result) => setNativeBalance(result)).catch((error) => {
        eventUtils_default.emit("sendUserOpResult", {
          error
        });
        onClose();
      });
    }
  }, [open, publicClient, evmAccount, onClose]);
  (0, import_react10.useEffect)(() => {
    if (nativeBalance != null && deserializeResult != null) {
      setDeserializeLoading(false);
    } else {
      setDeserializeLoading(true);
    }
  }, [nativeBalance, deserializeResult]);
  const toggleNotRemind = () => {
    setNotRemindChecked(!notRemindChecked);
    txConfirmUtils_default.setNotRemind(!notRemindChecked);
  };
  const gasFee = (0, import_react10.useMemo)(() => {
    if (userOpBundle == null ? void 0 : userOpBundle.userOp) {
      return caculateNativeFee(userOpBundle == null ? void 0 : userOpBundle.userOp);
    }
    return BigInt(0);
  }, [userOpBundle]);
  const closeModal = () => {
    eventUtils_default.emit("sendUserOpResult", {
      error: {
        code: 4001,
        message: "The user rejected the request."
      }
    });
    onClose();
  };
  const confirmTx = (0, import_react10.useCallback)(() => __async2(void 0, null, function* () {
    if (smartAccount && userOpBundle) {
      setLoading(true);
      try {
        const hash2 = yield smartAccount.sendUserOperation(userOpBundle);
        eventUtils_default.emit("sendUserOpResult", { result: hash2 });
      } catch (error) {
        eventUtils_default.emit("sendUserOpResult", {
          error
        });
      } finally {
        setLoading(false);
      }
      onClose();
    }
  }), [smartAccount, userOpBundle, onClose]);
  (0, import_react10.useEffect)(() => {
    if (userOpBundle && nativeBalance != null && deserializeResult) {
      const nativeChange = deserializeResult.filter(
        (item) => {
          var _a, _b;
          return ((_b = (_a = item.estimatedChanges.natives) == null ? void 0 : _a[0]) == null ? void 0 : _b.nativeChange) && item.estimatedChanges.natives[0].nativeChange.startsWith("-");
        }
      ).map((item) => {
        var _a, _b, _c, _d;
        return BigInt(((_d = (_c = (_b = (_a = item.estimatedChanges) == null ? void 0 : _a.natives) == null ? void 0 : _b[0]) == null ? void 0 : _c.nativeChange) == null ? void 0 : _d.replace("-", "")) || 0);
      }).reduce((accumulator, currentValue) => accumulator + currentValue, BigInt(0));
      if (userOpBundle.userOp.paymasterAndData.length > 2) {
        setDisabled(nativeBalance < nativeChange);
      } else {
        setDisabled(nativeBalance < gasFee + nativeChange);
      }
    }
  }, [userOpBundle, gasFee, nativeBalance, deserializeResult]);
  return (0, import_jsx_runtime8.jsx)(modal_default, { open, onClose, isDismissable: false, contentClassName: sign_module_default.modalContent, children: (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
    (0, import_jsx_runtime8.jsx)("img", { className: sign_module_default.closeBtn, src: close_default, onClick: closeModal }),
    (0, import_jsx_runtime8.jsxs)("div", { className: sign_module_default.chainInfo, children: [
      (0, import_jsx_runtime8.jsx)("img", { src: chainInfo == null ? void 0 : chainInfo.icon }),
      chainInfo == null ? void 0 : chainInfo.fullname.replace("Mainnet", "")
    ] }),
    (0, import_jsx_runtime8.jsx)("div", { className: sign_module_default.addressContainer, children: (0, import_jsx_runtime8.jsx)(CopyText, { value: evmAccount, style: { textDecorationLine: "none" }, children: (0, import_jsx_runtime8.jsxs)("div", { className: sign_module_default.addressInfo, children: [
      shortString(evmAccount),
      (0, import_jsx_runtime8.jsx)("img", { src: copy_default })
    ] }) }) }),
    (0, import_jsx_runtime8.jsx)("div", { className: sign_module_default.detailsContent + (deserializeResult ? ` ${sign_module_default.fill}` : ""), children: deserializeResult && deserializeResult.map((details, index2) => (0, import_jsx_runtime8.jsx)(transactionDetails_default, { details }, `${details.type}-${index2}`)) }),
    gasFee && (0, import_jsx_runtime8.jsx)("div", { className: sign_module_default.estimatedGas, children: `Estimated gas fee: ${formatEther(gasFee)} ${chainInfo == null ? void 0 : chainInfo.nativeCurrency.symbol}` }),
    (0, import_jsx_runtime8.jsx)(
      button_default,
      {
        onClick: confirmTx,
        className: sign_module_default.signBtn,
        isLoading: loading || deserializeLoading,
        isDisabled: disabled,
        children: deserializeLoading ? "LOADING" : disabled ? "INSUFFICIENT FEE" : "CONFIRM"
      }
    ),
    showNotRemind && (0, import_jsx_runtime8.jsxs)("div", { className: sign_module_default.notRemind, onClick: toggleNotRemind, children: [
      (0, import_jsx_runtime8.jsx)("img", { src: notRemindChecked ? check_box_default : check_box_blank_default }),
      "Do not remind me again"
    ] })
  ] }) });
};
var signModal_default = SignModal;
var AASignerProvider = class {
  constructor(supportChainIds, projectId, clientKey, rpcUrls) {
    this.supportChainIds = supportChainIds;
    this.projectId = projectId;
    this.clientKey = clientKey;
    this.rpcUrls = rpcUrls;
    this.chainId = 1;
    this.personalSign = (message) => __async2(this, null, function* () {
      throw new Error("Wallet not connected!");
    });
    this.getPublicKey = () => __async2(this, null, function* () {
      throw new Error("Wallet not connected!");
    });
    this.getPublicClient = () => {
      var _a, _b;
      const rpcUrl2 = ((_a = this == null ? void 0 : this.rpcUrls) == null ? void 0 : _a[this.chainId]) || ((_b = chains_exports.getEVMChainInfoById(this.chainId || 1)) == null ? void 0 : _b.rpcUrl);
      return createPublicClient({
        transport: http(rpcUrl2)
      });
    };
    this.events = new import_events5.EventEmitter();
    this.events.setMaxListeners(100);
    if (typeof window !== "undefined") {
      const localChainId = localStorage.getItem("connect-evm-chain-id");
      if (localChainId && supportChainIds.includes(Number(localChainId))) {
        this.chainId = Number(localChainId);
      } else {
        const chainId = supportChainIds[0];
        if (!chainId) {
          throw new Error("Please config valid chain id.");
        }
        localStorage.setItem("connect-evm-chain-id", chainId.toString());
        this.chainId = chainId;
      }
    }
    this.publicClient = this.getPublicClient();
  }
  request(arg) {
    return __async2(this, null, function* () {
      var _a;
      if (arg.method === "eth_sendTransaction" || arg.method === "wallet_addEthereumChain" || arg.method === "wallet_watchAsset" || arg.method === "eth_sign" || arg.method.startsWith("eth_signTypedData")) {
        throw new UnsupportedProviderMethodError(new Error("The Provider does not support the requested method."));
      }
      if (arg.method === "eth_accounts" || arg.method === "eth_requestAccounts") {
        const pubKey = yield this.getPublicKey();
        const address = pubKeyToEVMAddress(pubKey);
        return [address];
      } else if (arg.method === "eth_chainId") {
        return `0x${this.chainId.toString(16)}`;
      } else if (arg.method === "personal_sign") {
        const message = (_a = arg.params) == null ? void 0 : _a[0];
        const result = yield this.personalSign(message || "");
        const convertResult = convertSignature(result);
        if (!convertResult) {
          throw new Error("sign error");
        }
        return convertResult;
      } else if (arg.method === "wallet_switchEthereumChain") {
        if (arg.params && arg.params instanceof Array && arg.params[0] && arg.params[0].chainId) {
          const chainId = Number(arg.params[0].chainId);
          if (this.supportChainIds.includes(this.chainId)) {
            this.chainId = chainId;
            localStorage.setItem("connect-evm-chain-id", this.chainId.toString());
            this.publicClient = this.getPublicClient();
            setTimeout(() => this.events.emit("chainChanged", intToHex(this.chainId)), 0);
            return Promise.resolve(null);
          }
          throw new SwitchChainError(new Error(`The chain: ${chainId} is not supported`));
        } else {
          throw new InvalidParamsRpcError(new Error("Invalid Params"));
        }
      } else {
        const result = yield this.publicClient.request(arg);
        return result;
      }
    });
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
    return this;
  }
  on(event, listener) {
    this.events.on(event, listener);
    return this;
  }
  once(event, listener) {
    this.events.once(event, listener);
    return this;
  }
  off(event, listener) {
    this.events.off(event, listener);
    return this;
  }
  emit(event, ...args) {
    this.events.emit(event, args);
  }
};
var useModalStateValue = () => {
  const [isModalOpen, setModalOpen] = (0, import_react13.useState)(false);
  return {
    closeModal: (0, import_react13.useCallback)(() => setModalOpen(false), []),
    isModalOpen,
    openModal: (0, import_react13.useCallback)(() => setModalOpen(true), [])
  };
};
var useModalStateValue_default = useModalStateValue;
var ConnectContext = (0, import_react4.createContext)({});
var ConnectProvider = ({
  children,
  options,
  connectors,
  autoConnect = true
}) => {
  var _a;
  const {
    closeModal: closeConnectModal,
    isModalOpen: connectModalOpen,
    openModal: openConnectModal
  } = useModalStateValue_default();
  const { closeModal: closeSignModal, isModalOpen: signModalOpen, openModal: openSignModal } = useModalStateValue_default();
  const [connectorId, setConnectorId] = (0, import_react4.useState)();
  const [accounts, setAccounts] = (0, import_react4.useState)([]);
  const [evmAccount, setEVMAccount] = (0, import_react4.useState)();
  const BTCVersionKey = "particleBTCVersion";
  const [btcContractVersion, _setBTCContractVersion] = (0, import_react4.useState)(
    ((_a = options.aaOptions.accountContracts["BTC"]) == null ? void 0 : _a[0].version) || "1.0.0"
  );
  const setBTCContractVersion = (0, import_react4.useCallback)(
    (version) => {
      if (!checkBTCVersion(options.aaOptions.accountContracts, version)) {
        throw new Error(`Invalid btc version: ${version}`);
      }
      localStorage.setItem(BTCVersionKey, version);
      _setBTCContractVersion(version);
    },
    [options.aaOptions.accountContracts]
  );
  const btcContractVersionList = (0, import_react4.useMemo)(() => {
    return options.aaOptions.accountContracts["BTC"].map((item) => item.version);
  }, [options.aaOptions.accountContracts]);
  (0, import_react4.useEffect)(() => {
    const id = localStorage.getItem("current-connector-id");
    if (autoConnect && id) {
      setConnectorId(id);
    }
  }, [autoConnect]);
  const evmSupportChainIds = (0, import_react4.useMemo)(() => {
    let chainIds = options.aaOptions.accountContracts["BTC"].filter((item) => item.version === btcContractVersion).map((item) => item.chainIds).reduce((a, b) => {
      a.push(...b);
      return a;
    }, []);
    chainIds = Array.from(new Set(chainIds));
    return chainIds;
  }, [options.aaOptions.accountContracts, btcContractVersion]);
  const connector = (0, import_react4.useMemo)(() => {
    return connectors.find((item) => item.metadata.id === connectorId);
  }, [connectorId, connectors]);
  const getPublicKey = (0, import_react4.useCallback)(() => __async2(void 0, null, function* () {
    if (!connector) {
      throw new Error("Wallet not connected!");
    }
    const pubKey = yield connector.getPublicKey();
    return pubKey;
  }), [connector]);
  const signMessage2 = (0, import_react4.useCallback)(
    (message) => __async2(void 0, null, function* () {
      if (!connector) {
        throw new Error("Wallet not connected!");
      }
      const signature = yield connector.signMessage(message);
      return signature;
    }),
    [connector]
  );
  const sendBitcoin = (0, import_react4.useCallback)(
    (toAddress, satoshis, options2) => __async2(void 0, null, function* () {
      if (!connector) {
        throw new Error("Wallet not connected!");
      }
      const signature = yield connector.sendBitcoin(toAddress, satoshis, options2);
      return signature;
    }),
    [connector]
  );
  const getNetwork = (0, import_react4.useCallback)(() => __async2(void 0, null, function* () {
    if (!connector) {
      throw new Error("Wallet not connected!");
    }
    const network = yield connector.getNetwork();
    return network;
  }), [connector]);
  const switchNetwork = (0, import_react4.useCallback)(
    (network) => __async2(void 0, null, function* () {
      if (!connector) {
        throw new Error("Wallet not connected!");
      }
      yield connector.switchNetwork(network);
    }),
    [connector]
  );
  const smartAccount = (0, import_react4.useMemo)(() => {
    if (typeof window === "undefined") {
      return void 0;
    }
    if (!window.__bitcoinSmartAccount || (window == null ? void 0 : window.__bitcoinSmartAccount) && (window == null ? void 0 : window.__bitcoinSmartAccount.smartAccountContract.version) !== btcContractVersion) {
      const smartAccount2 = new SmartAccount(
        new AASignerProvider(evmSupportChainIds, options.projectId, options.clientKey, options.rpcUrls),
        options
      );
      smartAccount2.setSmartAccountContract({
        name: "BTC",
        version: btcContractVersion
      });
      window.__bitcoinSmartAccount = smartAccount2;
    }
    window.__bitcoinSmartAccount.provider.getPublicKey = getPublicKey;
    window.__bitcoinSmartAccount.provider.personalSign = signMessage2;
    return window.__bitcoinSmartAccount;
  }, [options, evmSupportChainIds, getPublicKey, signMessage2, btcContractVersion]);
  (0, import_react4.useEffect)(() => {
    if (accounts.length > 0 && smartAccount) {
      getBTCAAAddress(smartAccount, accounts[0], btcContractVersion).then((res) => {
        setEVMAccount(res);
      }).catch((e) => {
        setEVMAccount(void 0);
      });
    } else {
      setEVMAccount(void 0);
    }
  }, [accounts, smartAccount, getPublicKey, btcContractVersion]);
  const requestAccount = (0, import_react4.useCallback)(
    (connector2) => __async2(void 0, null, function* () {
      let accounts2 = yield connector2.getAccounts();
      if (accounts2.length === 0 && autoConnect) {
        accounts2 = yield connector2.requestAccounts();
      }
      setAccounts(accounts2);
    }),
    [autoConnect]
  );
  (0, import_react4.useEffect)(() => {
    if (connector) {
      requestAccount(connector).catch((e) => {
        setAccounts([]);
      });
    } else {
      setAccounts([]);
    }
  }, [connector, requestAccount]);
  (0, import_react4.useEffect)(() => {
    const onAccountChange = (accounts2) => {
      setAccounts(accounts2);
    };
    connector == null ? void 0 : connector.on("accountsChanged", onAccountChange);
    return () => {
      connector == null ? void 0 : connector.removeListener("accountsChanged", onAccountChange);
    };
  }, [connector]);
  const provider = (0, import_react4.useMemo)(() => {
    var _a2;
    if (connectorId) {
      return (_a2 = connectors.find((item) => item.metadata.id === connectorId)) == null ? void 0 : _a2.getProvider();
    }
  }, [connectorId, connectors]);
  const disconnect = (0, import_react4.useCallback)(() => {
    localStorage.removeItem("current-connector-id");
    txConfirmUtils_default.reset();
    if (connector) {
      connector.disconnect();
    }
    setConnectorId(void 0);
  }, [connector]);
  (0, import_react4.useEffect)(() => {
    let BTCVersion = localStorage.getItem(BTCVersionKey) || "1.0.0";
    if (!checkBTCVersion(options.aaOptions.accountContracts, BTCVersion)) {
      BTCVersion = options.aaOptions.accountContracts["BTC"][0].version;
    }
    setBTCContractVersion(BTCVersion);
  }, [options.aaOptions.accountContracts, setBTCContractVersion]);
  (0, import_react4.useEffect)(() => {
    var _a2;
    const supportChains = evmSupportChainIds.map((id) => chains_exports.getEVMChainInfoById(id));
    if (supportChains.some((chain) => !chain)) {
      throw new Error(`Please config valid chain ids, ${JSON.stringify(evmSupportChainIds)}`);
    }
    walletEntryPlugin.init(
      {
        projectId: options.projectId,
        clientKey: options.clientKey,
        appId: options.appId
      },
      __spreadProps2(__spreadValues2({}, options.walletOptions), {
        erc4337: {
          name: "BTC",
          version: btcContractVersion
        },
        customStyle: __spreadProps2(__spreadValues2({}, (_a2 = options.walletOptions) == null ? void 0 : _a2.customStyle), {
          supportChains,
          evmSupportWalletConnect: false
        })
      })
    );
  }, [options, evmSupportChainIds, btcContractVersion]);
  (0, import_react4.useEffect)(() => {
    if (smartAccount) {
      walletEntryPlugin.setWalletCore({
        ethereum: smartAccount.provider
      });
    }
  }, [smartAccount, options, evmSupportChainIds]);
  (0, import_react4.useEffect)(() => {
    if (evmAccount) {
      walletEntryPlugin.walletEntryCreate();
    } else {
      walletEntryPlugin.walletEntryDestroy();
    }
  }, [evmAccount, smartAccount, options, evmSupportChainIds]);
  (0, import_react4.useEffect)(() => {
    if (accounts.length === 0) {
      closeConnectModal();
      closeSignModal();
      if (eventUtils_default.listenerCount("sendUserOpResult") > 0) {
        eventUtils_default.emit("sendUserOpResult", {
          error: {
            code: -32600,
            message: "Wallet disconnected"
          }
        });
      }
    }
  }, [accounts, closeConnectModal, closeSignModal]);
  return (0, import_jsx_runtime9.jsxs)(
    ConnectContext.Provider,
    {
      value: {
        connectorId,
        setConnectorId,
        connector,
        connectors,
        openConnectModal,
        closeConnectModal,
        accounts,
        provider,
        disconnect,
        getPublicKey,
        signMessage: signMessage2,
        evmAccount,
        smartAccount,
        getNetwork,
        switchNetwork,
        sendBitcoin,
        btcContractVersion,
        setBTCContractVersion,
        btcContractVersionList
      },
      children: [
        children,
        (0, import_jsx_runtime9.jsx)(connectModal_default, { open: connectModalOpen, onClose: closeConnectModal }),
        (0, import_jsx_runtime9.jsx)(signModal_default, { open: signModalOpen, onClose: closeSignModal, onOpen: openSignModal })
      ]
    }
  );
};
var useConnectProvider = () => {
  const context = (0, import_react4.useContext)(ConnectContext);
  return context;
};
var getVersion = () => {
  return "1.0.0-alpha.17";
};
if (typeof window !== "undefined") {
  window.__PARTICLE_BTC_CONNECT_VERSION = getVersion();
}
export {
  BaseConnector,
  BitgetConnector,
  BybitConnector,
  ConnectProvider,
  InjectedConnector,
  OKXConnector,
  TokenPocketConnector,
  UnisatConnector,
  WizzConnector,
  XverseConnector,
  getVersion,
  useAccounts,
  useBTCContractVersion,
  useBTCProvider,
  useConnectModal,
  useConnector,
  useETHProvider
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
//# sourceMappingURL=@particle-network_btc-connectkit.js.map
