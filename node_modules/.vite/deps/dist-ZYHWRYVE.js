import {
  require_crypto
} from "./chunk-JOTEBLDP.js";
import {
  require_base64_js
} from "./chunk-MYBMDLPB.js";
import {
  __commonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/jsontokens/lib/base64Url.js
var require_base64Url = __commonJS({
  "node_modules/jsontokens/lib/base64Url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = exports.unescape = exports.escape = exports.pad = void 0;
    var base64_js_1 = require_base64_js();
    function pad(base64) {
      return `${base64}${"=".repeat(4 - (base64.length % 4 || 4))}`;
    }
    exports.pad = pad;
    function escape(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    exports.escape = escape;
    function unescape(base64Url) {
      return pad(base64Url).replace(/-/g, "+").replace(/_/g, "/");
    }
    exports.unescape = unescape;
    function encode(base64) {
      return escape((0, base64_js_1.fromByteArray)(new TextEncoder().encode(base64)));
    }
    exports.encode = encode;
    function decode(base64Url) {
      return new TextDecoder().decode((0, base64_js_1.toByteArray)(pad(unescape(base64Url))));
    }
    exports.decode = decode;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto2();
    var _assert_js_1 = require_assert();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/secp256k1/lib/index.js
var require_lib = __commonJS({
  "node_modules/@noble/secp256k1/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
    var nodeCrypto = require_crypto();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _8n = BigInt(8);
    var CURVE = Object.freeze({
      a: _0n,
      b: BigInt(7),
      P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: _1n,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    exports.CURVE = CURVE;
    var divNearest = (a, b) => (a + b / _2n) / b;
    var endo = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar(k) {
        const { n } = CURVE;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    };
    var fieldLen = 32;
    var groupLen = 32;
    var hashLen = 32;
    var compressedLen = fieldLen + 1;
    var uncompressedLen = 2 * fieldLen + 1;
    function weierstrass(x) {
      const { a, b } = CURVE;
      const x2 = mod(x * x);
      const x3 = mod(x2 * x);
      return mod(x3 + a * x + b);
    }
    var USE_ENDOMORPHISM = CURVE.a === _0n;
    var ShaError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    function assertJacPoint(other) {
      if (!(other instanceof JacobianPoint))
        throw new TypeError("JacobianPoint expected");
    }
    var JacobianPoint = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        if (p.equals(Point.ZERO))
          return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
      equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(B * B);
        const x1b = X1 + B;
        const D = mod(_2n * (mod(x1b * x1b) - A - C));
        const E = mod(_3n * A);
        const F = mod(E * E);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
          return this;
        if (X1 === _0n || Y1 === _0n)
          return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
          if (r === _0n) {
            return this.double();
          } else {
            return JacobianPoint.ZERO;
          }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n)
          return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p = P0;
          let d2 = this;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d2);
            d2 = d2.double();
            n >>= _1n;
          }
          return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d);
          if (k2 & _1n)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      }
      multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          k1p = constTimeNegate(k1neg, k1p);
          k2p = constTimeNegate(k2neg, k2p);
          k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n, affinePoint);
          point = p;
          fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (is0)
          return Point.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      hasEvenY() {
        return this.y % _2n === _0n;
      }
      static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
          if (isYOdd)
            y = mod(-y);
        } else {
          const isFirstByteOdd = (bytes[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen)
          return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes);
        }
        if (len === uncompressedLen && header === 4)
          return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
        const { r, s } = normalizeSignature(signature);
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("Cannot recover: invalid recovery bit");
        const h = truncateHash(ensureBytes(msgHash));
        const { n } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert(radj, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point.fromHex(prefix + numTo32bStr(radj));
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.hasEvenY() ? "02" : "03";
          return `${prefix}${x}`;
        } else {
          return `04${x}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
          throw new Error(msg);
        const left = mod(y * y);
        const right = weierstrass(x);
        if (mod(left - right) !== _0n)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point(this.x, mod(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    exports.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _0n);
    function sliceDER(s) {
      return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
    }
    function parseDERInt(data) {
      if (data.length < 2 || data[0] !== 2) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
      }
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
      }
      if (res[0] === 0 && res[1] <= 127) {
        throw new Error("Invalid signature integer: trailing length");
      }
      return { data: bytesToNumber(res), left: data.subarray(len + 2) };
    }
    function parseDERSignature(data) {
      if (data.length < 2 || data[0] != 48) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
      }
      if (data[1] !== data.length - 2) {
        throw new Error("Invalid signature: incorrect length");
      }
      const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
      const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
      if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
      }
      return { r, s };
    }
    var Signature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
          throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
      }
      static fromHex(hex) {
        return this.fromDER(hex);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
      }
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    exports.Signature = Signature;
    function concatBytes(...arrays) {
      if (!arrays.every((b) => b instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function numTo32bStr(num) {
      if (typeof num !== "bigint")
        throw new Error("Expected bigint");
      if (!(_0n <= num && num < POW_2_256))
        throw new Error("Expected number 0 <= n < 2^256");
      return num.toString(16).padStart(64, "0");
    }
    function numTo32b(num) {
      const b = hexToBytes(numTo32bStr(num));
      if (b.length !== 32)
        throw new Error("Error: expected 32 bytes");
      return b;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToNumber: expected string, got " + typeof hex);
      }
      return BigInt(`0x${hex}`);
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    function bytesToNumber(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function ensureBytes(hex) {
      return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
    }
    function normalizeScalar(num) {
      if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
      if (typeof num === "bigint" && isWithinCurveOrder(num))
        return num;
      throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function mod(a, b = CURVE.P) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow2(x, power) {
      const { P } = CURVE;
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= P;
      }
      return res;
    }
    function sqrtMod(x) {
      const { P } = CURVE;
      const _6n = BigInt(6);
      const _11n = BigInt(11);
      const _22n = BigInt(22);
      const _23n = BigInt(23);
      const _44n = BigInt(44);
      const _88n = BigInt(88);
      const b2 = x * x * x % P;
      const b3 = b2 * b2 * x % P;
      const b6 = pow2(b3, _3n) * b3 % P;
      const b9 = pow2(b6, _3n) * b3 % P;
      const b11 = pow2(b9, _2n) * b2 % P;
      const b22 = pow2(b11, _11n) * b11 % P;
      const b44 = pow2(b22, _22n) * b22 % P;
      const b88 = pow2(b44, _44n) * b44 % P;
      const b176 = pow2(b88, _88n) * b88 % P;
      const b220 = pow2(b176, _44n) * b44 % P;
      const b223 = pow2(b220, _3n) * b3 % P;
      const t1 = pow2(b223, _23n) * b22 % P;
      const t2 = pow2(t1, _6n) * b2 % P;
      const rt = pow2(t2, _2n);
      const xc = rt * rt % P;
      if (xc !== x)
        throw new Error("Cannot find square root");
      return rt;
    }
    function invert(number, modulo = CURVE.P) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
      const scratch = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
      }, _1n);
      const inverted = invert(lastMultiplied, p);
      nums.reduceRight((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
      }, inverted);
      return scratch;
    }
    function bits2int_2(bytes) {
      const delta = bytes.length * 8 - groupLen * 8;
      const num = bytesToNumber(bytes);
      return delta > 0 ? num >> BigInt(delta) : num;
    }
    function truncateHash(hash, truncateOnly = false) {
      const h = bits2int_2(hash);
      if (truncateOnly)
        return h;
      const { n } = CURVE;
      return h >= n ? h - n : h;
    }
    var _sha256Sync;
    var _hmacSha256Sync;
    var HmacDrbg = class {
      constructor(hashLen2, qByteLen) {
        this.hashLen = hashLen2;
        this.qByteLen = qByteLen;
        if (typeof hashLen2 !== "number" || hashLen2 < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        this.v = new Uint8Array(hashLen2).fill(1);
        this.k = new Uint8Array(hashLen2).fill(0);
        this.counter = 0;
      }
      hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
      }
      checkSync() {
        if (typeof _hmacSha256Sync !== "function")
          throw new ShaError("hmacSha256Sync needs to be set");
      }
      incr() {
        if (this.counter >= 1e3)
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = await this.hmac(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes(...out);
      }
      generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = this.hmacSync(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes(...out);
      }
    };
    function isWithinCurveOrder(num) {
      return _0n < num && num < CURVE.n;
    }
    function isValidFieldElement(num) {
      return _0n < num && num < CURVE.P;
    }
    function kmdToSig(kBytes, m, d, lowS = true) {
      const { n } = CURVE;
      const k = truncateHash(kBytes, true);
      if (!isWithinCurveOrder(k))
        return;
      const kinv = invert(k, n);
      const q = Point.BASE.multiply(k);
      const r = mod(q.x, n);
      if (r === _0n)
        return;
      const s = mod(kinv * mod(m + d * r, n), n);
      if (s === _0n)
        return;
      let sig = new Signature(r, s);
      let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
      if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
      }
      return { sig, recovery };
    }
    function normalizePrivateKey(key) {
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
      } else if (typeof key === "string") {
        if (key.length !== 2 * groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
      } else if (key instanceof Uint8Array) {
        if (key.length !== groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
      } else {
        throw new TypeError("Expected valid private key");
      }
      if (!isWithinCurveOrder(num))
        throw new Error("Expected private key: 0 < key < n");
      return num;
    }
    function normalizePublicKey(publicKey) {
      if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
      } else {
        return Point.fromHex(publicKey);
      }
    }
    function normalizeSignature(signature) {
      if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
      }
      try {
        return Signature.fromDER(signature);
      } catch (error) {
        return Signature.fromCompact(signature);
      }
    }
    function getPublicKey(privateKey, isCompressed = false) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    exports.getPublicKey = getPublicKey;
    function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
      return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === compressedLen * 2 || len === uncompressedLen * 2;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = false) {
      if (isProbPub(privateA))
        throw new TypeError("getSharedSecret: first arg must be private key");
      if (!isProbPub(publicB))
        throw new TypeError("getSharedSecret: second arg must be public key");
      const b = normalizePublicKey(publicB);
      b.assertValidity();
      return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
    }
    exports.getSharedSecret = getSharedSecret;
    function bits2int(bytes) {
      const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
      return bytesToNumber(slice);
    }
    function bits2octets(bytes) {
      const z1 = bits2int(bytes);
      const z2 = mod(z1, CURVE.n);
      return int2octets(z2 < _0n ? z1 : z2);
    }
    function int2octets(num) {
      return numTo32b(num);
    }
    function initSigArgs(msgHash, privateKey, extraEntropy) {
      if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
      const h1 = ensureBytes(msgHash);
      const d = normalizePrivateKey(privateKey);
      const seedArgs = [int2octets(d), bits2octets(h1)];
      if (extraEntropy != null) {
        if (extraEntropy === true)
          extraEntropy = exports.utils.randomBytes(fieldLen);
        const e = ensureBytes(extraEntropy);
        if (e.length !== fieldLen)
          throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e);
      }
      const seed = concatBytes(...seedArgs);
      const m = bits2int(h1);
      return { seed, m, d };
    }
    function finalizeSig(recSig, opts) {
      const { sig, recovery } = recSig;
      const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
      const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
      return recovered ? [hashed, recovery] : hashed;
    }
    async function sign(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      await drbg.reseed(seed);
      let sig;
      while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
        await drbg.reseed();
      return finalizeSig(sig, opts);
    }
    exports.sign = sign;
    function signSync(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      drbg.reseedSync(seed);
      let sig;
      while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
        drbg.reseedSync();
      return finalizeSig(sig, opts);
    }
    exports.signSync = signSync;
    var vopts = { strict: true };
    function verify(signature, msgHash, publicKey, opts = vopts) {
      let sig;
      try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
      } catch (error) {
        return false;
      }
      const { r, s } = sig;
      if (opts.strict && sig.hasHighS())
        return false;
      const h = truncateHash(msgHash);
      let P;
      try {
        P = normalizePublicKey(publicKey);
      } catch (error) {
        return false;
      }
      const { n } = CURVE;
      const sinv = invert(s, n);
      const u1 = mod(h * sinv, n);
      const u2 = mod(r * sinv, n);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
      if (!R)
        return false;
      const v = mod(R.x, n);
      return v === r;
    }
    exports.verify = verify;
    function schnorrChallengeFinalize(ch) {
      return mod(bytesToNumber(ch), CURVE.n);
    }
    var SchnorrSignature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
          throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
          throw new Error("Invalid signature");
      }
      toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
      toRawBytes() {
        return hexToBytes(this.toHex());
      }
    };
    function schnorrGetPublicKey(privateKey) {
      return Point.fromPrivateKey(privateKey).toRawX();
    }
    var InternalSchnorrSignature = class {
      constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
        if (message == null)
          throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32)
          throw new TypeError("sign: Expected 32 bytes of aux randomness");
      }
      getScalar(priv) {
        const point = Point.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return { point, scalar, x: point.toRawX() };
      }
      initNonce(d, t0h) {
        return numTo32b(d ^ bytesToNumber(t0h));
      }
      finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n)
          throw new Error("sign: Creation of signature failed. k is zero");
        const { point: R, x: rx, scalar: k } = this.getScalar(k0);
        return { R, rx, k };
      }
      finalizeSig(R, k, e, d) {
        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
      }
      error() {
        throw new Error("sign: Invalid signature produced");
      }
      async calc() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHash;
        const t = this.initNonce(d, await tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!await schnorrVerify(sig, m, px))
          this.error();
        return sig;
      }
      calcSync() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHashSync;
        const t = this.initNonce(d, tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!schnorrVerifySync(sig, m, px))
          this.error();
        return sig;
      }
    };
    async function schnorrSign(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
    }
    function schnorrSignSync(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
    }
    function initSchnorrVerify(signature, message, publicKey) {
      const raw = signature instanceof SchnorrSignature;
      const sig = raw ? signature : SchnorrSignature.fromHex(signature);
      if (raw)
        sig.assertValidity();
      return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey)
      };
    }
    function finalizeSchnorrVerify(r, P, s, e) {
      const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
      if (!R || !R.hasEvenY() || R.x !== r)
        return false;
      return true;
    }
    async function schnorrVerify(signature, message, publicKey) {
      try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
      } catch (error) {
        return false;
      }
    }
    function schnorrVerifySync(signature, message, publicKey) {
      try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
      } catch (error) {
        if (error instanceof ShaError)
          throw error;
        return false;
      }
    }
    exports.schnorr = {
      Signature: SchnorrSignature,
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      signSync: schnorrSignSync,
      verifySync: schnorrVerifySync
    };
    Point.BASE._setWindowSize(8);
    var crypto2 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    var TAGS = {
      challenge: "BIP0340/challenge",
      aux: "BIP0340/aux",
      nonce: "BIP0340/nonce"
    };
    var TAGGED_HASH_PREFIXES = {};
    exports.utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      mod,
      invert,
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      _bigintTo32Bytes: numTo32b,
      _normalizePrivateKey: normalizePrivateKey,
      hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) {
          throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto2.web) {
          return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto2.node) {
          const { randomBytes } = crypto2.node;
          return Uint8Array.from(randomBytes(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      },
      sha256: async (...messages) => {
        if (crypto2.web) {
          const buffer = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages));
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHash } = crypto2.node;
          const hash = createHash("sha256");
          messages.forEach((m) => hash.update(m));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages) => {
        if (crypto2.web) {
          const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message = concatBytes(...messages);
          const buffer = await crypto2.web.subtle.sign("HMAC", ckey, message);
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHmac } = crypto2.node;
          const hash = createHmac("sha256", key);
          messages.forEach((m) => hash.update(m));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
      },
      taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== "function")
          throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
      },
      _JacobianPoint: JacobianPoint
    };
    Object.defineProperties(exports.utils, {
      sha256Sync: {
        configurable: false,
        get() {
          return _sha256Sync;
        },
        set(val) {
          if (!_sha256Sync)
            _sha256Sync = val;
        }
      },
      hmacSha256Sync: {
        configurable: false,
        get() {
          return _hmacSha256Sync;
        },
        set(val) {
          if (!_hmacSha256Sync)
            _hmacSha256Sync = val;
        }
      }
    });
  }
});

// node_modules/jsontokens/lib/ecdsaSigFormatter.js
var require_ecdsaSigFormatter = __commonJS({
  "node_modules/jsontokens/lib/ecdsaSigFormatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joseToDer = exports.derToJose = void 0;
    var base64_js_1 = require_base64_js();
    var base64Url_1 = require_base64Url();
    function getParamSize(keySize) {
      return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      const paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error(`Unknown algorithm "${alg}"`);
    }
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function signatureAsBytes(signature) {
      if (signature instanceof Uint8Array) {
        return signature;
      } else if ("string" === typeof signature) {
        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
    }
    function derToJose(signature, alg) {
      const signatureBytes = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const maxEncodedParamLength = paramBytes + 1;
      const inputLength = signatureBytes.length;
      let offset = 0;
      if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      let seqLength = signatureBytes[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signatureBytes[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength - offset}" remaining`);
      }
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      const rLength = signatureBytes[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error(`"r" specified length of "${rLength}", only "${inputLength - offset - 2}" available`);
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const rOffset = offset;
      offset += rLength;
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      const sLength = signatureBytes[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error(`"s" specified length of "${sLength}", expected "${inputLength - offset}"`);
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error(`Expected to consume entire array, but "${inputLength - offset}" bytes remain`);
      }
      const rPadding = paramBytes - rLength;
      const sPadding = paramBytes - sLength;
      const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
      offset = paramBytes;
      for (const o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
      return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));
    }
    exports.derToJose = derToJose;
    function countPadding(buf, start, stop) {
      let padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      const needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(`"${alg}" signatures must be "${paramBytes * 2}" bytes, saw "${signatureBytes}"`);
      }
      const rPadding = countPadding(signature, 0, paramBytes);
      const sPadding = countPadding(signature, paramBytes, signature.length);
      const rLength = paramBytes - rPadding;
      const sLength = paramBytes - sPadding;
      const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      const shortLength = rsBytes < MAX_OCTET;
      const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);
      let offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(0, paramBytes), offset);
        offset += paramBytes;
      } else {
        dst.set(signature.subarray(rPadding, paramBytes), offset);
        offset += paramBytes - rPadding;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(paramBytes), offset);
      } else {
        dst.set(signature.subarray(paramBytes + sPadding), offset);
      }
      return dst;
    }
    exports.joseToDer = joseToDer;
  }
});

// node_modules/jsontokens/lib/errors.js
var require_errors = __commonJS({
  "node_modules/jsontokens/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidTokenError = exports.MissingParametersError = void 0;
    var MissingParametersError = class extends Error {
      constructor(message) {
        super();
        this.name = "MissingParametersError";
        this.message = message || "";
      }
    };
    exports.MissingParametersError = MissingParametersError;
    var InvalidTokenError = class extends Error {
      constructor(message) {
        super();
        this.name = "InvalidTokenError";
        this.message = message || "";
      }
    };
    exports.InvalidTokenError = InvalidTokenError;
  }
});

// node_modules/jsontokens/lib/cryptoClients/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SECP256K1Client = void 0;
    var hmac_1 = require_hmac();
    var sha256_1 = require_sha256();
    var secp = require_lib();
    var ecdsaSigFormatter_1 = require_ecdsaSigFormatter();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    secp.utils.hmacSha256Sync = (key, ...msgs) => {
      const h = hmac_1.hmac.create(sha256_1.sha256, key);
      msgs.forEach((msg) => h.update(msg));
      return h.digest();
    };
    var SECP256K1Client = class {
      static derivePublicKey(privateKey, compressed = true) {
        if (privateKey.length === 66) {
          privateKey = privateKey.slice(0, 64);
        }
        if (privateKey.length < 64) {
          privateKey = privateKey.padStart(64, "0");
        }
        return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));
      }
      static signHash(signingInputHash, privateKey, format = "jose") {
        if (!signingInputHash || !privateKey) {
          throw new errors_1.MissingParametersError("a signing input hash and private key are all required");
        }
        const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {
          der: true,
          canonical: false
        });
        if (format === "der")
          return (0, utils_1.bytesToHex)(derSignature);
        if (format === "jose")
          return (0, ecdsaSigFormatter_1.derToJose)(derSignature, "ES256");
        throw Error("Invalid signature format");
      }
      static loadSignature(joseSignature) {
        return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, "ES256");
      }
      static verifyHash(signingInputHash, derSignatureBytes, publicKey) {
        if (!signingInputHash || !derSignatureBytes || !publicKey) {
          throw new errors_1.MissingParametersError("a signing input hash, der signature, and public key are all required");
        }
        return secp.verify(derSignatureBytes, signingInputHash, publicKey, { strict: false });
      }
    };
    exports.SECP256K1Client = SECP256K1Client;
    SECP256K1Client.algorithmName = "ES256K";
  }
});

// node_modules/jsontokens/lib/cryptoClients/index.js
var require_cryptoClients = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cryptoClients = exports.SECP256K1Client = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "SECP256K1Client", { enumerable: true, get: function() {
      return secp256k1_1.SECP256K1Client;
    } });
    var cryptoClients = {
      ES256K: secp256k1_1.SECP256K1Client
    };
    exports.cryptoClients = cryptoClients;
  }
});

// node_modules/jsontokens/lib/cryptoClients/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/sha256.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashSha256Async = exports.hashSha256 = void 0;
    var sha256_1 = require_sha256();
    function hashSha256(input) {
      return (0, sha256_1.sha256)(input);
    }
    exports.hashSha256 = hashSha256;
    function hashSha256Async(input) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const isSubtleCryptoAvailable = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
          if (isSubtleCryptoAvailable) {
            const bytes = typeof input === "string" ? new TextEncoder().encode(input) : input;
            const hash = yield crypto.subtle.digest("SHA-256", bytes);
            return new Uint8Array(hash);
          } else {
            const nodeCrypto = require_crypto();
            if (!nodeCrypto.createHash) {
              throw new Error("`crypto` module does not contain `createHash`");
            }
            return Promise.resolve(nodeCrypto.createHash("sha256").update(input).digest());
          }
        } catch (error) {
          console.log(error);
          console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.');
          return Promise.resolve(hashSha256(input));
        }
      });
    }
    exports.hashSha256Async = hashSha256Async;
  }
});

// node_modules/jsontokens/lib/signer.js
var require_signer = __commonJS({
  "node_modules/jsontokens/lib/signer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenSigner = exports.createUnsecuredToken = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    function createSigningInput(payload, header) {
      const tokenParts = [];
      const encodedHeader = base64url.encode(JSON.stringify(header));
      tokenParts.push(encodedHeader);
      const encodedPayload = base64url.encode(JSON.stringify(payload));
      tokenParts.push(encodedPayload);
      const signingInput = tokenParts.join(".");
      return signingInput;
    }
    function createUnsecuredToken(payload) {
      const header = { typ: "JWT", alg: "none" };
      return createSigningInput(payload, header) + ".";
    }
    exports.createUnsecuredToken = createUnsecuredToken;
    var TokenSigner = class {
      constructor(signingAlgorithm, rawPrivateKey) {
        if (!(signingAlgorithm && rawPrivateKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and private key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw new Error("signing algorithm parameter must be a string");
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw new Error("invalid signing algorithm");
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPrivateKey = rawPrivateKey;
      }
      header(header = {}) {
        const defaultHeader = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
        return Object.assign({}, defaultHeader, header);
      }
      sign(payload, expanded = false, customHeader = {}) {
        const header = this.header(customHeader);
        const signingInput = createSigningInput(payload, header);
        const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
      }
      signAsync(payload, expanded = false, customHeader = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const header = this.header(customHeader);
          const signingInput = createSigningInput(payload, header);
          const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);
          return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
        });
      }
      createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {
        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
        if (expanded) {
          const signedToken = {
            header: [base64url.encode(JSON.stringify(header))],
            payload: JSON.stringify(payload),
            signature: [signature]
          };
          return signedToken;
        } else {
          return [signingInput, signature].join(".");
        }
      }
    };
    exports.TokenSigner = TokenSigner;
  }
});

// node_modules/jsontokens/lib/verifier.js
var require_verifier = __commonJS({
  "node_modules/jsontokens/lib/verifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenVerifier = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    var TokenVerifier = class {
      constructor(signingAlgorithm, rawPublicKey) {
        if (!(signingAlgorithm && rawPublicKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw "signing algorithm parameter must be a string";
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw "invalid signing algorithm";
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPublicKey = rawPublicKey;
      }
      verify(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, false);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, false);
        } else {
          return false;
        }
      }
      verifyAsync(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, true);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, true);
        } else {
          return Promise.resolve(false);
        }
      }
      verifyCompact(token, async) {
        const tokenParts = token.split(".");
        const signingInput = tokenParts[0] + "." + tokenParts[1];
        const performVerify = (signingInputHash) => {
          const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);
          return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
      verifyExpanded(token, async) {
        const signingInput = [token["header"].join("."), base64url.encode(token["payload"])].join(".");
        let verified = true;
        const performVerify = (signingInputHash) => {
          token["signature"].map((signature) => {
            const derSignatureBytes = this.cryptoClient.loadSignature(signature);
            const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
            if (!signatureVerified) {
              verified = false;
            }
          });
          return verified;
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
    };
    exports.TokenVerifier = TokenVerifier;
  }
});

// node_modules/jsontokens/lib/decode.js
var require_decode = __commonJS({
  "node_modules/jsontokens/lib/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeToken = void 0;
    var base64url = require_base64Url();
    function decodeToken(token) {
      if (typeof token === "string") {
        const tokenParts = token.split(".");
        const header = JSON.parse(base64url.decode(tokenParts[0]));
        const payload = JSON.parse(base64url.decode(tokenParts[1]));
        const signature = tokenParts[2];
        return {
          header,
          payload,
          signature
        };
      } else if (typeof token === "object") {
        if (typeof token.payload !== "string") {
          throw new Error("Expected token payload to be a base64 or json string");
        }
        let payload = token.payload;
        if (token.payload[0] !== "{") {
          payload = base64url.decode(payload);
        }
        const allHeaders = [];
        token.header.map((headerValue) => {
          const header = JSON.parse(base64url.decode(headerValue));
          allHeaders.push(header);
        });
        return {
          header: allHeaders,
          payload: JSON.parse(payload),
          signature: token.signature
        };
      }
    }
    exports.decodeToken = decodeToken;
  }
});

// node_modules/jsontokens/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/jsontokens/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_signer(), exports);
    __exportStar(require_verifier(), exports);
    __exportStar(require_decode(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_cryptoClients(), exports);
  }
});

// node_modules/sats-connect/dist/provider/types.js
var require_types = __commonJS({
  "node_modules/sats-connect/dist/provider/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/provider/index.js
var require_provider = __commonJS({
  "node_modules/sats-connect/dist/provider/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProviderOrThrow = void 0;
    async function getProviderOrThrow(getProvider) {
      const provider = await getProvider?.() || window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
      if (!provider) {
        throw new Error("No Bitcoin wallet installed");
      }
      return provider;
    }
    exports.getProviderOrThrow = getProviderOrThrow;
    __exportStar(require_types(), exports);
  }
});

// node_modules/sats-connect/dist/addresses/types.js
var require_types2 = __commonJS({
  "node_modules/sats-connect/dist/addresses/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressType = exports.AddressPurpose = void 0;
    var AddressPurpose;
    (function(AddressPurpose2) {
      AddressPurpose2["Ordinals"] = "ordinals";
      AddressPurpose2["Payment"] = "payment";
      AddressPurpose2["Stacks"] = "stacks";
    })(AddressPurpose = exports.AddressPurpose || (exports.AddressPurpose = {}));
    var AddressType;
    (function(AddressType2) {
      AddressType2["p2pkh"] = "p2pkh";
      AddressType2["p2sh"] = "p2sh";
      AddressType2["p2wpkh"] = "p2wpkh";
      AddressType2["p2wsh"] = "p2wsh";
      AddressType2["p2tr"] = "p2tr";
      AddressType2["stacks"] = "stacks";
    })(AddressType = exports.AddressType || (exports.AddressType = {}));
  }
});

// node_modules/sats-connect/dist/addresses/index.js
var require_addresses = __commonJS({
  "node_modules/sats-connect/dist/addresses/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var getAddress = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { purposes } = options.payload;
      if (!purposes) {
        throw new Error("Address purposes are required");
      }
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.connect(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during address request", error);
        options.onCancel?.();
      }
    };
    exports.getAddress = getAddress;
    __exportStar(require_types2(), exports);
  }
});

// node_modules/sats-connect/dist/call/types.js
var require_types3 = __commonJS({
  "node_modules/sats-connect/dist/call/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/call/index.js
var require_call = __commonJS({
  "node_modules/sats-connect/dist/call/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWalletPopup = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var callWalletPopup = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { method } = options.payload;
      if (!method) {
        throw new Error("A wallet method is required");
      }
      const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
      try {
        const response = await provider.call(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during call request", error);
        options.onCancel?.();
      }
    };
    exports.callWalletPopup = callWalletPopup;
    __exportStar(require_types3(), exports);
  }
});

// node_modules/sats-connect/dist/capabilities/types.js
var require_types4 = __commonJS({
  "node_modules/sats-connect/dist/capabilities/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/capabilities/index.js
var require_capabilities = __commonJS({
  "node_modules/sats-connect/dist/capabilities/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCapabilities = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var extractOrValidateCapabilities = (provider, reportedCapabilities) => {
      const validateCapability = (capability) => {
        if (!provider[capability]) {
          return false;
        }
        if (reportedCapabilities && !reportedCapabilities.has(capability)) {
          return false;
        }
        return true;
      };
      const capabilityMap = {
        call: validateCapability("call"),
        connect: validateCapability("connect"),
        signMessage: validateCapability("signMessage"),
        signTransaction: validateCapability("signTransaction"),
        sendBtcTransaction: validateCapability("sendBtcTransaction"),
        createInscription: validateCapability("createInscription"),
        createRepeatInscriptions: validateCapability("createRepeatInscriptions"),
        signMultipleTransactions: validateCapability("signMultipleTransactions")
      };
      return Object.entries(capabilityMap).reduce((acc, [capability, value]) => {
        if (value)
          return [...acc, capability];
        return acc;
      }, []);
    };
    var getCapabilities = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
      if (provider.getCapabilities) {
        try {
          const response = await provider.getCapabilities(request);
          options.onFinish?.(extractOrValidateCapabilities(provider, new Set(response)));
        } catch (error) {
          console.error("[Connect] Error during capabilities request", error);
        }
      }
      try {
        const inferredCapabilities = extractOrValidateCapabilities(provider);
        options.onFinish?.(inferredCapabilities);
      } catch (error) {
        console.error("[Connect] Error during capabilities request", error);
        options.onCancel?.();
      }
    };
    exports.getCapabilities = getCapabilities;
    __exportStar(require_types4(), exports);
  }
});

// node_modules/sats-connect/dist/inscriptions/utils.js
var require_utils2 = __commonJS({
  "node_modules/sats-connect/dist/inscriptions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateInscriptionPayload = void 0;
    var MAX_CONTENT_LENGTH_MAINNET = 4e5;
    var MAX_CONTENT_LENGTH_TESTNET = 6e4;
    var validateInscriptionPayload = (payload) => {
      const { contentType, content, payloadType, network, appFeeAddress, appFee } = payload;
      if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(contentType)) {
        throw new Error("Invalid content type detected");
      }
      if (!content || content.length === 0) {
        throw new Error("Empty content not allowed");
      }
      if (!payloadType || payloadType !== "BASE_64" && payloadType !== "PLAIN_TEXT") {
        throw new Error("Empty invalid payloadType specified");
      }
      if (content.length > (network.type === "Mainnet" ? MAX_CONTENT_LENGTH_MAINNET : MAX_CONTENT_LENGTH_TESTNET)) {
        throw new Error("Content too large");
      }
      if ((appFeeAddress?.length ?? 0) > 0 && (appFee ?? 0) <= 0) {
        throw new Error("Invalid combination of app fee address and fee provided");
      }
    };
    exports.validateInscriptionPayload = validateInscriptionPayload;
  }
});

// node_modules/sats-connect/dist/inscriptions/createInscription.js
var require_createInscription = __commonJS({
  "node_modules/sats-connect/dist/inscriptions/createInscription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInscription = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var utils_1 = require_utils2();
    var createInscription = async (options) => {
      const { getProvider } = options;
      const provider = await (0, provider_1.getProviderOrThrow)(getProvider);
      (0, utils_1.validateInscriptionPayload)(options.payload);
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.createInscription(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during create inscription", error);
        options.onCancel?.();
      }
    };
    exports.createInscription = createInscription;
  }
});

// node_modules/sats-connect/dist/inscriptions/createRepeatInscriptions.js
var require_createRepeatInscriptions = __commonJS({
  "node_modules/sats-connect/dist/inscriptions/createRepeatInscriptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRepeatInscriptions = void 0;
    var provider_1 = require_provider();
    var jsontokens_1 = require_lib2();
    var utils_1 = require_utils2();
    var createRepeatInscriptions = async (options) => {
      const { getProvider } = options;
      const provider = await (0, provider_1.getProviderOrThrow)(getProvider);
      (0, utils_1.validateInscriptionPayload)(options.payload);
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.createRepeatInscriptions(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during create repeat inscriptions", error);
        options.onCancel?.();
      }
    };
    exports.createRepeatInscriptions = createRepeatInscriptions;
  }
});

// node_modules/sats-connect/dist/inscriptions/types.js
var require_types5 = __commonJS({
  "node_modules/sats-connect/dist/inscriptions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/inscriptions/index.js
var require_inscriptions = __commonJS({
  "node_modules/sats-connect/dist/inscriptions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_createInscription(), exports);
    __exportStar(require_createRepeatInscriptions(), exports);
    __exportStar(require_types5(), exports);
  }
});

// node_modules/sats-connect/dist/messages/types.js
var require_types6 = __commonJS({
  "node_modules/sats-connect/dist/messages/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/messages/index.js
var require_messages = __commonJS({
  "node_modules/sats-connect/dist/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMessage = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var signMessage = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { address, message } = options.payload;
      if (!address) {
        throw new Error("An address is required to sign a message");
      }
      if (!message) {
        throw new Error("A message to be signed is required");
      }
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.signMessage(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during sign message request", error);
        options.onCancel?.();
      }
    };
    exports.signMessage = signMessage;
    __exportStar(require_types6(), exports);
  }
});

// node_modules/sats-connect/dist/transactions/sendBtcTransaction.js
var require_sendBtcTransaction = __commonJS({
  "node_modules/sats-connect/dist/transactions/sendBtcTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendBtcTransaction = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var serializer = (recipient) => {
      return recipient.map((value) => {
        const { address, amountSats } = value;
        return {
          address,
          amountSats: amountSats.toString()
        };
      });
    };
    var sendBtcTransaction = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { recipients, senderAddress, network, message } = options.payload;
      if (!recipients || recipients.length === 0) {
        throw new Error("At least one recipient is required");
      }
      if (recipients.some((item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint")) {
        throw new Error("Incorrect recipient format");
      }
      if (!senderAddress) {
        throw new Error("The sender address is required");
      }
      try {
        const serializedRecipients = serializer(recipients);
        const serializedPayload = {
          network,
          senderAddress,
          message,
          recipients: serializedRecipients
        };
        const request = (0, jsontokens_1.createUnsecuredToken)(serializedPayload);
        const response = await provider.sendBtcTransaction(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during send BTC transaction request", error);
        options.onCancel?.();
      }
    };
    exports.sendBtcTransaction = sendBtcTransaction;
  }
});

// node_modules/sats-connect/dist/transactions/signTransaction.js
var require_signTransaction = __commonJS({
  "node_modules/sats-connect/dist/transactions/signTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTransaction = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var signTransaction = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { psbtBase64, inputsToSign } = options.payload;
      if (!psbtBase64) {
        throw new Error("A value for psbtBase64 representing the tx hash is required");
      }
      if (!inputsToSign) {
        throw new Error("An array specifying the inputs to be signed by the wallet is required");
      }
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.signTransaction(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during sign transaction request", error);
        options.onCancel?.();
      }
    };
    exports.signTransaction = signTransaction;
  }
});

// node_modules/sats-connect/dist/transactions/signMultipleTransactions.js
var require_signMultipleTransactions = __commonJS({
  "node_modules/sats-connect/dist/transactions/signMultipleTransactions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMultipleTransactions = void 0;
    var jsontokens_1 = require_lib2();
    var provider_1 = require_provider();
    var signMultipleTransactions = async (options) => {
      const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
      const { psbts } = options.payload;
      if (!psbts || !psbts.length) {
        throw new Error("psbts array is required");
      }
      if (psbts.length > 100) {
        throw new Error("psbts array must contain less than 100 psbts");
      }
      try {
        const request = (0, jsontokens_1.createUnsecuredToken)(options.payload);
        const response = await provider.signMultipleTransactions(request);
        options.onFinish?.(response);
      } catch (error) {
        console.error("[Connect] Error during sign Multiple transactions request", error);
        options.onCancel?.();
      }
    };
    exports.signMultipleTransactions = signMultipleTransactions;
  }
});

// node_modules/sats-connect/dist/transactions/types.js
var require_types7 = __commonJS({
  "node_modules/sats-connect/dist/transactions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/sats-connect/dist/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/sats-connect/dist/transactions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_sendBtcTransaction(), exports);
    __exportStar(require_signTransaction(), exports);
    __exportStar(require_signMultipleTransactions(), exports);
    __exportStar(require_types7(), exports);
  }
});

// node_modules/sats-connect/dist/types.js
var require_types8 = __commonJS({
  "node_modules/sats-connect/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitcoinNetworkType = void 0;
    var BitcoinNetworkType;
    (function(BitcoinNetworkType2) {
      BitcoinNetworkType2["Mainnet"] = "Mainnet";
      BitcoinNetworkType2["Testnet"] = "Testnet";
    })(BitcoinNetworkType = exports.BitcoinNetworkType || (exports.BitcoinNetworkType = {}));
  }
});

// node_modules/sats-connect/dist/index.js
var require_dist = __commonJS({
  "node_modules/sats-connect/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_addresses(), exports);
    __exportStar(require_call(), exports);
    __exportStar(require_capabilities(), exports);
    __exportStar(require_inscriptions(), exports);
    __exportStar(require_messages(), exports);
    __exportStar(require_provider(), exports);
    __exportStar(require_transactions(), exports);
    __exportStar(require_types8(), exports);
  }
});
export default require_dist();
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
//# sourceMappingURL=dist-ZYHWRYVE.js.map
